
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>agentlab: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/agentlab/agentlab/cmd/agentlab/api.go (0.0%)</option>
				
				<option value="file1">github.com/agentlab/agentlab/cmd/agentlab/commands.go (6.3%)</option>
				
				<option value="file2">github.com/agentlab/agentlab/cmd/agentlab/main.go (44.3%)</option>
				
				<option value="file3">github.com/agentlab/agentlab/cmd/agentlab/ssh.go (17.5%)</option>
				
				<option value="file4">github.com/agentlab/agentlab/cmd/agentlabd/main.go (0.0%)</option>
				
				<option value="file5">github.com/agentlab/agentlab/internal/buildinfo/buildinfo.go (0.0%)</option>
				
				<option value="file6">github.com/agentlab/agentlab/internal/config/config.go (46.0%)</option>
				
				<option value="file7">github.com/agentlab/agentlab/internal/daemon/api.go (18.3%)</option>
				
				<option value="file8">github.com/agentlab/agentlab/internal/daemon/artifact_api.go (61.6%)</option>
				
				<option value="file9">github.com/agentlab/agentlab/internal/daemon/artifact_gc.go (59.7%)</option>
				
				<option value="file10">github.com/agentlab/agentlab/internal/daemon/bootstrap_api.go (61.0%)</option>
				
				<option value="file11">github.com/agentlab/agentlab/internal/daemon/daemon.go (43.6%)</option>
				
				<option value="file12">github.com/agentlab/agentlab/internal/daemon/job_orchestrator.go (60.0%)</option>
				
				<option value="file13">github.com/agentlab/agentlab/internal/daemon/metrics.go (0.0%)</option>
				
				<option value="file14">github.com/agentlab/agentlab/internal/daemon/profile_behavior.go (79.2%)</option>
				
				<option value="file15">github.com/agentlab/agentlab/internal/daemon/profile_inner_sandbox.go (76.2%)</option>
				
				<option value="file16">github.com/agentlab/agentlab/internal/daemon/profile_resources.go (94.1%)</option>
				
				<option value="file17">github.com/agentlab/agentlab/internal/daemon/profile_validation.go (83.6%)</option>
				
				<option value="file18">github.com/agentlab/agentlab/internal/daemon/profiles.go (0.0%)</option>
				
				<option value="file19">github.com/agentlab/agentlab/internal/daemon/redaction.go (93.1%)</option>
				
				<option value="file20">github.com/agentlab/agentlab/internal/daemon/runner_api.go (24.1%)</option>
				
				<option value="file21">github.com/agentlab/agentlab/internal/daemon/sandbox_alloc.go (57.1%)</option>
				
				<option value="file22">github.com/agentlab/agentlab/internal/daemon/sandbox_manager.go (55.4%)</option>
				
				<option value="file23">github.com/agentlab/agentlab/internal/daemon/workspace_manager.go (50.0%)</option>
				
				<option value="file24">github.com/agentlab/agentlab/internal/daemon/workspace_rebind.go (67.2%)</option>
				
				<option value="file25">github.com/agentlab/agentlab/internal/db/artifact_tokens.go (0.0%)</option>
				
				<option value="file26">github.com/agentlab/agentlab/internal/db/artifacts.go (0.0%)</option>
				
				<option value="file27">github.com/agentlab/agentlab/internal/db/bootstrap_tokens.go (69.8%)</option>
				
				<option value="file28">github.com/agentlab/agentlab/internal/db/db.go (59.4%)</option>
				
				<option value="file29">github.com/agentlab/agentlab/internal/db/events.go (0.0%)</option>
				
				<option value="file30">github.com/agentlab/agentlab/internal/db/jobs.go (0.0%)</option>
				
				<option value="file31">github.com/agentlab/agentlab/internal/db/migrations.go (61.8%)</option>
				
				<option value="file32">github.com/agentlab/agentlab/internal/db/sandboxes.go (0.6%)</option>
				
				<option value="file33">github.com/agentlab/agentlab/internal/db/workspaces.go (0.0%)</option>
				
				<option value="file34">github.com/agentlab/agentlab/internal/proxmox/cloudinit_snippets.go (68.9%)</option>
				
				<option value="file35">github.com/agentlab/agentlab/internal/proxmox/shell_backend.go (58.6%)</option>
				
				<option value="file36">github.com/agentlab/agentlab/internal/secrets/bundle.go (58.9%)</option>
				
				<option value="file37">github.com/agentlab/agentlab/internal/testing/mocks.go (0.0%)</option>
				
				<option value="file38">github.com/agentlab/agentlab/internal/testing/testutil.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net"
        "net/http"
        "strings"
        "time"
)

const defaultSocketPath = "/run/agentlab/agentlabd.sock"

const (
        maxJSONOutputBytes = 4 &lt;&lt; 20
)

type apiClient struct {
        socketPath string
        httpClient *http.Client
        timeout    time.Duration
}

type apiError struct {
        Error string `json:"error"`
}

type jobCreateRequest struct {
        RepoURL    string `json:"repo_url"`
        Ref        string `json:"ref,omitempty"`
        Profile    string `json:"profile"`
        Task       string `json:"task"`
        Mode       string `json:"mode,omitempty"`
        TTLMinutes *int   `json:"ttl_minutes,omitempty"`
        Keepalive  *bool  `json:"keepalive,omitempty"`
}

type jobResponse struct {
        ID          string          `json:"id"`
        RepoURL     string          `json:"repo_url"`
        Ref         string          `json:"ref"`
        Profile     string          `json:"profile"`
        Task        string          `json:"task,omitempty"`
        Mode        string          `json:"mode,omitempty"`
        TTLMinutes  *int            `json:"ttl_minutes,omitempty"`
        Keepalive   bool            `json:"keepalive"`
        Status      string          `json:"status"`
        SandboxVMID *int            `json:"sandbox_vmid,omitempty"`
        Result      json.RawMessage `json:"result,omitempty"`
        Events      []eventResponse `json:"events,omitempty"`
        CreatedAt   string          `json:"created_at"`
        UpdatedAt   string          `json:"updated_at"`
}

type artifactInfo struct {
        Name      string `json:"name"`
        Path      string `json:"path"`
        SizeBytes int64  `json:"size_bytes"`
        Sha256    string `json:"sha256"`
        MIME      string `json:"mime,omitempty"`
        CreatedAt string `json:"created_at,omitempty"`
}

type artifactsResponse struct {
        JobID     string         `json:"job_id"`
        Artifacts []artifactInfo `json:"artifacts"`
}

type sandboxCreateRequest struct {
        Name       string  `json:"name,omitempty"`
        Profile    string  `json:"profile"`
        Keepalive  *bool   `json:"keepalive,omitempty"`
        TTLMinutes *int    `json:"ttl_minutes,omitempty"`
        Workspace  *string `json:"workspace_id,omitempty"`
        VMID       *int    `json:"vmid,omitempty"`
        JobID      string  `json:"job_id,omitempty"`
}

type sandboxResponse struct {
        VMID          int     `json:"vmid"`
        Name          string  `json:"name"`
        Profile       string  `json:"profile"`
        State         string  `json:"state"`
        IP            string  `json:"ip,omitempty"`
        WorkspaceID   *string `json:"workspace_id,omitempty"`
        Keepalive     bool    `json:"keepalive"`
        LeaseExpires  *string `json:"lease_expires_at,omitempty"`
        CreatedAt     string  `json:"created_at"`
        LastUpdatedAt string  `json:"updated_at"`
}

type sandboxesResponse struct {
        Sandboxes []sandboxResponse `json:"sandboxes"`
}

type leaseRenewRequest struct {
        TTLMinutes int `json:"ttl_minutes"`
}

type leaseRenewResponse struct {
        VMID         int    `json:"vmid"`
        LeaseExpires string `json:"lease_expires_at"`
}

type workspaceCreateRequest struct {
        Name    string `json:"name"`
        SizeGB  int    `json:"size_gb"`
        Storage string `json:"storage,omitempty"`
}

type workspaceAttachRequest struct {
        VMID int `json:"vmid"`
}

type workspaceRebindRequest struct {
        Profile    string `json:"profile"`
        TTLMinutes *int   `json:"ttl_minutes,omitempty"`
        KeepOld    bool   `json:"keep_old,omitempty"`
}

type workspaceResponse struct {
        ID           string `json:"id"`
        Name         string `json:"name"`
        Storage      string `json:"storage"`
        VolumeID     string `json:"volid"`
        SizeGB       int    `json:"size_gb"`
        AttachedVMID *int   `json:"attached_vmid,omitempty"`
        CreatedAt    string `json:"created_at"`
        UpdatedAt    string `json:"updated_at"`
}

type workspacesResponse struct {
        Workspaces []workspaceResponse `json:"workspaces"`
}

type workspaceRebindResponse struct {
        Workspace workspaceResponse `json:"workspace"`
        Sandbox   sandboxResponse   `json:"sandbox"`
        OldVMID   *int              `json:"old_vmid,omitempty"`
}

type eventResponse struct {
        ID          int64           `json:"id"`
        Timestamp   string          `json:"ts"`
        Kind        string          `json:"kind"`
        SandboxVMID *int            `json:"sandbox_vmid,omitempty"`
        JobID       string          `json:"job_id,omitempty"`
        Message     string          `json:"msg,omitempty"`
        Payload     json.RawMessage `json:"json,omitempty"`
}

type eventsResponse struct {
        Events []eventResponse `json:"events"`
        LastID int64           `json:"last_id,omitempty"`
}

func newAPIClient(socketPath string, timeout time.Duration) *apiClient <span class="cov0" title="0">{
        path := socketPath
        if path == "" </span><span class="cov0" title="0">{
                path = defaultSocketPath
        }</span>
        <span class="cov0" title="0">transport := &amp;http.Transport{
                DialContext: func(ctx context.Context, _, _ string) (net.Conn, error) </span><span class="cov0" title="0">{
                        var d net.Dialer
                        return d.DialContext(ctx, "unix", path)
                }</span>,
        }
        <span class="cov0" title="0">return &amp;apiClient{
                socketPath: path,
                httpClient: &amp;http.Client{Transport: transport},
                timeout:    timeout,
        }</span>
}

func (c *apiClient) doJSON(ctx context.Context, method, path string, payload any) ([]byte, error) <span class="cov0" title="0">{
        ctx, cancel := c.withTimeout(ctx)
        defer cancel()
        var body io.Reader
        if payload != nil </span><span class="cov0" title="0">{
                buf := &amp;bytes.Buffer{}
                enc := json.NewEncoder(buf)
                if err := enc.Encode(payload); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">body = buf</span>
        }
        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, method, "http://unix"+path, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req.Header.Set("Accept", "application/json")
        if payload != nil </span><span class="cov0" title="0">{
                req.Header.Set("Content-Type", "application/json")
        }</span>
        <span class="cov0" title="0">resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request %s %s via %s: %w", method, path, c.socketPath, err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        data, err := io.ReadAll(io.LimitReader(resp.Body, maxJSONOutputBytes))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                return nil, parseAPIError(resp.StatusCode, data)
        }</span>
        <span class="cov0" title="0">return data, nil</span>
}

func (c *apiClient) doRequest(ctx context.Context, method, path string, body io.Reader, headers map[string]string) (*http.Response, error) <span class="cov0" title="0">{
        ctx, cancel := c.withTimeout(ctx)
        defer cancel()
        req, err := http.NewRequestWithContext(ctx, method, "http://unix"+path, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for key, value := range headers </span><span class="cov0" title="0">{
                if strings.TrimSpace(key) == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">req.Header.Set(key, value)</span>
        }
        <span class="cov0" title="0">resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request %s %s via %s: %w", method, path, c.socketPath, err)
        }</span>
        <span class="cov0" title="0">if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                data, readErr := io.ReadAll(io.LimitReader(resp.Body, maxJSONOutputBytes))
                _ = resp.Body.Close()
                if readErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("request failed with status %d", resp.StatusCode)
                }</span>
                <span class="cov0" title="0">return nil, parseAPIError(resp.StatusCode, data)</span>
        }
        <span class="cov0" title="0">return resp, nil</span>
}

func parseAPIError(status int, data []byte) error <span class="cov0" title="0">{
        if len(data) &gt; 0 </span><span class="cov0" title="0">{
                var apiErr apiError
                if err := json.Unmarshal(data, &amp;apiErr); err == nil &amp;&amp; apiErr.Error != "" </span><span class="cov0" title="0">{
                        return errors.New(apiErr.Error)
                }</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("request failed with status %d", status)</span>
}

func (c *apiClient) withTimeout(ctx context.Context) (context.Context, context.CancelFunc) <span class="cov0" title="0">{
        if c == nil || c.timeout &lt;= 0 </span><span class="cov0" title="0">{
                return ctx, func() </span>{<span class="cov0" title="0">}</span>
        }
        <span class="cov0" title="0">return context.WithTimeout(ctx, c.timeout)</span>
}

func prettyPrintJSON(w io.Writer, data []byte) error <span class="cov0" title="0">{
        var out bytes.Buffer
        if err := json.Indent(&amp;out, data, "", "  "); err != nil </span><span class="cov0" title="0">{
                _, err = w.Write(data)
                return err
        }</span>
        <span class="cov0" title="0">out.WriteByte('\n')
        _, err := w.Write(out.Bytes())
        return err</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "encoding/json"
        "errors"
        "flag"
        "fmt"
        "io"
        "math"
        "net/http"
        "net/url"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "text/tabwriter"
        "time"
)

const (
        defaultLogTail            = 50
        eventPollInterval         = 2 * time.Second
        defaultEventLimit         = 200
        maxEventLimit             = 1000
        defaultRequestTimeout     = 10 * time.Minute
        ttlFlagDescription        = "lease ttl in minutes or duration (e.g. 120 or 2h)"
        jsonFlagDescription       = "output json"
        defaultArtifactBundleName = "agentlab-artifacts.tar.gz"
)

var errHelp = errors.New("help requested")

type commonFlags struct {
        socketPath string
        jsonOutput bool
        timeout    time.Duration
}

func (c *commonFlags) bind(fs *flag.FlagSet) <span class="cov8" title="7">{
        fs.StringVar(&amp;c.socketPath, "socket", c.socketPath, "path to agentlabd socket")
        fs.BoolVar(&amp;c.jsonOutput, "json", c.jsonOutput, jsonFlagDescription)
        fs.DurationVar(&amp;c.timeout, "timeout", c.timeout, "request timeout (e.g. 30s, 2m)")
}</span>

func newFlagSet(name string) *flag.FlagSet <span class="cov3" title="2">{
        fs := flag.NewFlagSet(name, flag.ContinueOnError)
        fs.SetOutput(io.Discard)
        return fs
}</span>

type optionalBool struct {
        value bool
        set   bool
}

func (o *optionalBool) String() string <span class="cov6" title="4">{
        if o == nil || !o.set </span><span class="cov3" title="2">{
                return ""
        }</span>
        <span class="cov3" title="2">if o.value </span><span class="cov1" title="1">{
                return "true"
        }</span>
        <span class="cov1" title="1">return "false"</span>
}

func (o *optionalBool) Set(value string) error <span class="cov10" title="11">{
        parsed, err := strconv.ParseBool(value)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov9" title="10">o.value = parsed
        o.set = true
        return nil</span>
}

func (o *optionalBool) IsBoolFlag() bool <span class="cov1" title="1">{
        return true
}</span>

func (o *optionalBool) Ptr() *bool <span class="cov6" title="4">{
        if o == nil || !o.set </span><span class="cov3" title="2">{
                return nil
        }</span>
        <span class="cov3" title="2">value := o.value
        return &amp;value</span>
}

func parseFlags(fs *flag.FlagSet, args []string, usage func(), help *bool) error <span class="cov3" title="2">{
        fs.Usage = usage
        if err := fs.Parse(args); err != nil </span><span class="cov0" title="0">{
                usage()
                return err
        }</span>
        <span class="cov3" title="2">if help != nil &amp;&amp; *help </span><span class="cov0" title="0">{
                usage()
                return errHelp
        }</span>
        <span class="cov3" title="2">return nil</span>
}

func runJobCommand(ctx context.Context, args []string, base commonFlags) error <span class="cov1" title="1">{
        if len(args) == 0 </span><span class="cov1" title="1">{
                printJobUsage()
                return nil
        }</span>
        <span class="cov0" title="0">switch args[0] </span>{
        case "run":<span class="cov0" title="0">
                return runJobRun(ctx, args[1:], base)</span>
        case "show":<span class="cov0" title="0">
                return runJobShow(ctx, args[1:], base)</span>
        case "artifacts":<span class="cov0" title="0">
                return runJobArtifacts(ctx, args[1:], base)</span>
        default:<span class="cov0" title="0">
                printJobUsage()
                return fmt.Errorf("unknown job command %q", args[0])</span>
        }
}

func runJobRun(ctx context.Context, args []string, base commonFlags) error <span class="cov0" title="0">{
        fs := newFlagSet("job run")
        opts := base
        opts.bind(fs)
        var repo string
        var ref string
        var profile string
        var task string
        var mode string
        var ttl string
        var keepalive optionalBool
        var help bool
        fs.StringVar(&amp;repo, "repo", "", "git repository url")
        fs.StringVar(&amp;ref, "ref", "", "git ref (default main)")
        fs.StringVar(&amp;profile, "profile", "", "profile name")
        fs.StringVar(&amp;task, "task", "", "task description")
        fs.StringVar(&amp;mode, "mode", "", "mode (default dangerous)")
        fs.StringVar(&amp;ttl, "ttl", "", ttlFlagDescription)
        fs.Var(&amp;keepalive, "keepalive", "keep sandbox after job completion")
        fs.BoolVar(&amp;help, "help", false, "show help")
        fs.BoolVar(&amp;help, "h", false, "show help")
        if err := parseFlags(fs, args, printJobRunUsage, &amp;help); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if repo == "" || profile == "" || task == "" </span><span class="cov0" title="0">{
                printJobRunUsage()
                return fmt.Errorf("repo, profile, and task are required")
        }</span>
        <span class="cov0" title="0">ttlMinutes, err := parseTTLMinutes(ttl)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">client := newAPIClient(opts.socketPath, opts.timeout)
        req := jobCreateRequest{
                RepoURL:    repo,
                Ref:        ref,
                Profile:    profile,
                Task:       task,
                Mode:       mode,
                TTLMinutes: ttlMinutes,
                Keepalive:  keepalive.Ptr(),
        }
        payload, err := client.doJSON(ctx, http.MethodPost, "/v1/jobs", req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if opts.jsonOutput </span><span class="cov0" title="0">{
                return prettyPrintJSON(os.Stdout, payload)
        }</span>
        <span class="cov0" title="0">var resp jobResponse
        if err := json.Unmarshal(payload, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">printJob(resp)
        return nil</span>
}

func runJobShow(ctx context.Context, args []string, base commonFlags) error <span class="cov0" title="0">{
        fs := newFlagSet("job show")
        opts := base
        opts.bind(fs)
        var eventsTail int
        var help bool
        fs.IntVar(&amp;eventsTail, "events-tail", -1, "number of recent events to include (0 to omit)")
        fs.BoolVar(&amp;help, "help", false, "show help")
        fs.BoolVar(&amp;help, "h", false, "show help")
        if err := parseFlags(fs, args, printJobShowUsage, &amp;help); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if fs.NArg() &lt; 1 </span><span class="cov0" title="0">{
                printJobShowUsage()
                return fmt.Errorf("job_id is required")
        }</span>
        <span class="cov0" title="0">jobID := strings.TrimSpace(fs.Arg(0))
        if jobID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("job_id is required")
        }</span>

        <span class="cov0" title="0">client := newAPIClient(opts.socketPath, opts.timeout)
        query := ""
        if eventsTail &gt;= 0 </span><span class="cov0" title="0">{
                query = fmt.Sprintf("?events_tail=%d", eventsTail)
        }</span>
        <span class="cov0" title="0">payload, err := client.doJSON(ctx, http.MethodGet, fmt.Sprintf("/v1/jobs/%s%s", jobID, query), nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if opts.jsonOutput </span><span class="cov0" title="0">{
                return prettyPrintJSON(os.Stdout, payload)
        }</span>
        <span class="cov0" title="0">var resp jobResponse
        if err := json.Unmarshal(payload, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">printJob(resp)
        if len(resp.Events) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("Events:")
                printEvents(resp.Events, false)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func runJobArtifacts(ctx context.Context, args []string, base commonFlags) error <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                printJobArtifactsUsage()
                return nil
        }</span>
        <span class="cov0" title="0">switch args[0] </span>{
        case "download":<span class="cov0" title="0">
                return runJobArtifactsDownload(ctx, args[1:], base)</span>
        default:<span class="cov0" title="0">
                return runJobArtifactsList(ctx, args, base)</span>
        }
}

func runJobArtifactsList(ctx context.Context, args []string, base commonFlags) error <span class="cov0" title="0">{
        fs := newFlagSet("job artifacts")
        opts := base
        opts.bind(fs)
        var help bool
        fs.BoolVar(&amp;help, "help", false, "show help")
        fs.BoolVar(&amp;help, "h", false, "show help")
        if err := parseFlags(fs, args, printJobArtifactsUsage, &amp;help); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if fs.NArg() &lt; 1 </span><span class="cov0" title="0">{
                printJobArtifactsUsage()
                return fmt.Errorf("job_id is required")
        }</span>
        <span class="cov0" title="0">jobID := strings.TrimSpace(fs.Arg(0))
        if jobID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("job_id is required")
        }</span>

        <span class="cov0" title="0">client := newAPIClient(opts.socketPath, opts.timeout)
        payload, err := client.doJSON(ctx, http.MethodGet, fmt.Sprintf("/v1/jobs/%s/artifacts", jobID), nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if opts.jsonOutput </span><span class="cov0" title="0">{
                return prettyPrintJSON(os.Stdout, payload)
        }</span>
        <span class="cov0" title="0">var resp artifactsResponse
        if err := json.Unmarshal(payload, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">printArtifactsList(resp.Artifacts)
        return nil</span>
}

func runJobArtifactsDownload(ctx context.Context, args []string, base commonFlags) error <span class="cov0" title="0">{
        fs := newFlagSet("job artifacts download")
        opts := base
        opts.bind(fs)
        var out string
        var path string
        var name string
        var latest bool
        var bundle bool
        var help bool
        fs.StringVar(&amp;out, "out", "", "output file path or directory")
        fs.StringVar(&amp;path, "path", "", "artifact path to download")
        fs.StringVar(&amp;name, "name", "", "artifact name to download")
        fs.BoolVar(&amp;latest, "latest", false, "download latest artifact")
        fs.BoolVar(&amp;bundle, "bundle", false, "download latest bundle (agentlab-artifacts.tar.gz)")
        fs.BoolVar(&amp;help, "help", false, "show help")
        fs.BoolVar(&amp;help, "h", false, "show help")
        if err := parseFlags(fs, args, printJobArtifactsDownloadUsage, &amp;help); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if fs.NArg() &lt; 1 </span><span class="cov0" title="0">{
                printJobArtifactsDownloadUsage()
                return fmt.Errorf("job_id is required")
        }</span>
        <span class="cov0" title="0">jobID := strings.TrimSpace(fs.Arg(0))
        if jobID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("job_id is required")
        }</span>
        <span class="cov0" title="0">path = strings.TrimSpace(path)
        name = strings.TrimSpace(name)
        if path != "" &amp;&amp; name != "" </span><span class="cov0" title="0">{
                return fmt.Errorf("path and name are mutually exclusive")
        }</span>
        <span class="cov0" title="0">if path == "" &amp;&amp; name == "" &amp;&amp; !latest &amp;&amp; !bundle </span><span class="cov0" title="0">{
                bundle = true
        }</span>

        <span class="cov0" title="0">client := newAPIClient(opts.socketPath, opts.timeout)
        payload, err := client.doJSON(ctx, http.MethodGet, fmt.Sprintf("/v1/jobs/%s/artifacts", jobID), nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">var resp artifactsResponse
        if err := json.Unmarshal(payload, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if len(resp.Artifacts) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no artifacts found for job %s", jobID)
        }</span>
        <span class="cov0" title="0">artifact, err := selectArtifact(resp.Artifacts, path, name, latest, bundle)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(artifact.Path) == "" </span><span class="cov0" title="0">{
                artifact.Path = strings.TrimSpace(artifact.Name)
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(artifact.Path) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("selected artifact has no path")
        }</span>

        <span class="cov0" title="0">targetName := strings.TrimSpace(artifact.Name)
        if targetName == "" </span><span class="cov0" title="0">{
                targetName = filepath.Base(strings.TrimSpace(artifact.Path))
        }</span>
        <span class="cov0" title="0">targetPath, err := resolveArtifactOutPath(out, targetName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">downloadPath := fmt.Sprintf("/v1/jobs/%s/artifacts/download?path=%s", jobID, url.QueryEscape(artifact.Path))
        respBody, err := client.doRequest(ctx, http.MethodGet, downloadPath, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer respBody.Body.Close()

        outFile, err := os.OpenFile(targetPath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer outFile.Close()

        if _, err := io.Copy(outFile, respBody.Body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := outFile.Sync(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if opts.jsonOutput </span><span class="cov0" title="0">{
                result := map[string]any{
                        "job_id":   jobID,
                        "artifact": artifact,
                        "out":      targetPath,
                }
                data, err := json.Marshal(result)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">_, _ = os.Stdout.Write(append(data, '\n'))
                return nil</span>
        }
        <span class="cov0" title="0">fmt.Printf("downloaded %s to %s\n", artifact.Path, targetPath)
        return nil</span>
}

func runSandboxCommand(ctx context.Context, args []string, base commonFlags) error <span class="cov1" title="1">{
        if len(args) == 0 </span><span class="cov1" title="1">{
                printSandboxUsage()
                return nil
        }</span>
        <span class="cov0" title="0">switch args[0] </span>{
        case "new":<span class="cov0" title="0">
                return runSandboxNew(ctx, args[1:], base)</span>
        case "list":<span class="cov0" title="0">
                return runSandboxList(ctx, args[1:], base)</span>
        case "show":<span class="cov0" title="0">
                return runSandboxShow(ctx, args[1:], base)</span>
        case "destroy":<span class="cov0" title="0">
                return runSandboxDestroy(ctx, args[1:], base)</span>
        case "lease":<span class="cov0" title="0">
                return runSandboxLease(ctx, args[1:], base)</span>
        default:<span class="cov0" title="0">
                printSandboxUsage()
                return fmt.Errorf("unknown sandbox command %q", args[0])</span>
        }
}

func runWorkspaceCommand(ctx context.Context, args []string, base commonFlags) error <span class="cov1" title="1">{
        if len(args) == 0 </span><span class="cov1" title="1">{
                printWorkspaceUsage()
                return nil
        }</span>
        <span class="cov0" title="0">switch args[0] </span>{
        case "create":<span class="cov0" title="0">
                return runWorkspaceCreate(ctx, args[1:], base)</span>
        case "list":<span class="cov0" title="0">
                return runWorkspaceList(ctx, args[1:], base)</span>
        case "attach":<span class="cov0" title="0">
                return runWorkspaceAttach(ctx, args[1:], base)</span>
        case "detach":<span class="cov0" title="0">
                return runWorkspaceDetach(ctx, args[1:], base)</span>
        case "rebind":<span class="cov0" title="0">
                return runWorkspaceRebind(ctx, args[1:], base)</span>
        default:<span class="cov0" title="0">
                printWorkspaceUsage()
                return fmt.Errorf("unknown workspace command %q", args[0])</span>
        }
}

func runSandboxNew(ctx context.Context, args []string, base commonFlags) error <span class="cov0" title="0">{
        fs := newFlagSet("sandbox new")
        opts := base
        opts.bind(fs)
        var name string
        var profile string
        var ttl string
        var workspace string
        var vmid int
        var jobID string
        var keepalive optionalBool
        var help bool
        fs.StringVar(&amp;name, "name", "", "sandbox name")
        fs.StringVar(&amp;profile, "profile", "", "profile name")
        fs.StringVar(&amp;ttl, "ttl", "", ttlFlagDescription)
        fs.StringVar(&amp;workspace, "workspace", "", "workspace id or name")
        fs.IntVar(&amp;vmid, "vmid", 0, "vmid override")
        fs.StringVar(&amp;jobID, "job", "", "attach to existing job id")
        fs.Var(&amp;keepalive, "keepalive", "enable keepalive lease for sandbox")
        fs.BoolVar(&amp;help, "help", false, "show help")
        fs.BoolVar(&amp;help, "h", false, "show help")
        if err := parseFlags(fs, args, printSandboxNewUsage, &amp;help); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if profile == "" </span><span class="cov0" title="0">{
                printSandboxNewUsage()
                return fmt.Errorf("profile is required")
        }</span>
        <span class="cov0" title="0">ttlMinutes, err := parseTTLMinutes(ttl)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">var workspaceID *string
        if strings.TrimSpace(workspace) != "" </span><span class="cov0" title="0">{
                value := strings.TrimSpace(workspace)
                workspaceID = &amp;value
        }</span>
        <span class="cov0" title="0">var vmidPtr *int
        if vmid &gt; 0 </span><span class="cov0" title="0">{
                value := vmid
                vmidPtr = &amp;value
        }</span>

        <span class="cov0" title="0">client := newAPIClient(opts.socketPath, opts.timeout)
        req := sandboxCreateRequest{
                Name:       name,
                Profile:    profile,
                Keepalive:  keepalive.Ptr(),
                TTLMinutes: ttlMinutes,
                Workspace:  workspaceID,
                VMID:       vmidPtr,
                JobID:      jobID,
        }
        payload, err := client.doJSON(ctx, http.MethodPost, "/v1/sandboxes", req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if opts.jsonOutput </span><span class="cov0" title="0">{
                return prettyPrintJSON(os.Stdout, payload)
        }</span>
        <span class="cov0" title="0">var resp sandboxResponse
        if err := json.Unmarshal(payload, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">printSandbox(resp)
        return nil</span>
}

func runSandboxList(ctx context.Context, args []string, base commonFlags) error <span class="cov0" title="0">{
        fs := newFlagSet("sandbox list")
        opts := base
        opts.bind(fs)
        var help bool
        fs.BoolVar(&amp;help, "help", false, "show help")
        fs.BoolVar(&amp;help, "h", false, "show help")
        if err := parseFlags(fs, args, printSandboxListUsage, &amp;help); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">client := newAPIClient(opts.socketPath, opts.timeout)
        payload, err := client.doJSON(ctx, http.MethodGet, "/v1/sandboxes", nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if opts.jsonOutput </span><span class="cov0" title="0">{
                return prettyPrintJSON(os.Stdout, payload)
        }</span>
        <span class="cov0" title="0">var resp sandboxesResponse
        if err := json.Unmarshal(payload, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">printSandboxList(resp.Sandboxes)
        return nil</span>
}

func runSandboxShow(ctx context.Context, args []string, base commonFlags) error <span class="cov0" title="0">{
        fs := newFlagSet("sandbox show")
        opts := base
        opts.bind(fs)
        var help bool
        fs.BoolVar(&amp;help, "help", false, "show help")
        fs.BoolVar(&amp;help, "h", false, "show help")
        if err := parseFlags(fs, args, printSandboxShowUsage, &amp;help); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if fs.NArg() &lt; 1 </span><span class="cov0" title="0">{
                printSandboxShowUsage()
                return fmt.Errorf("vmid is required")
        }</span>
        <span class="cov0" title="0">vmid, err := parseVMID(fs.Arg(0))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">client := newAPIClient(opts.socketPath, opts.timeout)
        payload, err := client.doJSON(ctx, http.MethodGet, fmt.Sprintf("/v1/sandboxes/%d", vmid), nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if opts.jsonOutput </span><span class="cov0" title="0">{
                return prettyPrintJSON(os.Stdout, payload)
        }</span>
        <span class="cov0" title="0">var resp sandboxResponse
        if err := json.Unmarshal(payload, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">printSandbox(resp)
        return nil</span>
}

func runSandboxDestroy(ctx context.Context, args []string, base commonFlags) error <span class="cov0" title="0">{
        fs := newFlagSet("sandbox destroy")
        opts := base
        opts.bind(fs)
        var help bool
        fs.BoolVar(&amp;help, "help", false, "show help")
        fs.BoolVar(&amp;help, "h", false, "show help")
        if err := parseFlags(fs, args, printSandboxDestroyUsage, &amp;help); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if fs.NArg() &lt; 1 </span><span class="cov0" title="0">{
                printSandboxDestroyUsage()
                return fmt.Errorf("vmid is required")
        }</span>
        <span class="cov0" title="0">vmid, err := parseVMID(fs.Arg(0))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">client := newAPIClient(opts.socketPath, opts.timeout)
        payload, err := client.doJSON(ctx, http.MethodPost, fmt.Sprintf("/v1/sandboxes/%d/destroy", vmid), nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if opts.jsonOutput </span><span class="cov0" title="0">{
                return prettyPrintJSON(os.Stdout, payload)
        }</span>
        <span class="cov0" title="0">var resp sandboxResponse
        if err := json.Unmarshal(payload, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">fmt.Printf("sandbox %d destroyed (state=%s)\n", resp.VMID, resp.State)
        return nil</span>
}

func runSandboxLease(ctx context.Context, args []string, base commonFlags) error <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                printSandboxLeaseUsage()
                return nil
        }</span>
        <span class="cov0" title="0">switch args[0] </span>{
        case "renew":<span class="cov0" title="0">
                return runSandboxLeaseRenew(ctx, args[1:], base)</span>
        default:<span class="cov0" title="0">
                printSandboxLeaseUsage()
                return fmt.Errorf("unknown sandbox lease command %q", args[0])</span>
        }
}

func runSandboxLeaseRenew(ctx context.Context, args []string, base commonFlags) error <span class="cov0" title="0">{
        fs := newFlagSet("sandbox lease renew")
        opts := base
        opts.bind(fs)
        var ttl string
        var help bool
        fs.StringVar(&amp;ttl, "ttl", "", ttlFlagDescription)
        fs.BoolVar(&amp;help, "help", false, "show help")
        fs.BoolVar(&amp;help, "h", false, "show help")
        if err := parseFlags(fs, args, printSandboxLeaseRenewUsage, &amp;help); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if fs.NArg() &lt; 1 </span><span class="cov0" title="0">{
                printSandboxLeaseRenewUsage()
                return fmt.Errorf("vmid is required")
        }</span>
        <span class="cov0" title="0">if ttl == "" </span><span class="cov0" title="0">{
                printSandboxLeaseRenewUsage()
                return fmt.Errorf("ttl is required")
        }</span>
        <span class="cov0" title="0">vmid, err := parseVMID(fs.Arg(0))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">minutes, err := parseRequiredTTLMinutes(ttl)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">client := newAPIClient(opts.socketPath, opts.timeout)
        req := leaseRenewRequest{TTLMinutes: minutes}
        payload, err := client.doJSON(ctx, http.MethodPost, fmt.Sprintf("/v1/sandboxes/%d/lease/renew", vmid), req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if opts.jsonOutput </span><span class="cov0" title="0">{
                return prettyPrintJSON(os.Stdout, payload)
        }</span>
        <span class="cov0" title="0">var resp leaseRenewResponse
        if err := json.Unmarshal(payload, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">fmt.Printf("sandbox %d lease renewed until %s\n", resp.VMID, resp.LeaseExpires)
        return nil</span>
}

func runWorkspaceCreate(ctx context.Context, args []string, base commonFlags) error <span class="cov0" title="0">{
        fs := newFlagSet("workspace create")
        opts := base
        opts.bind(fs)
        var name string
        var size string
        var storage string
        var help bool
        fs.StringVar(&amp;name, "name", "", "workspace name")
        fs.StringVar(&amp;size, "size", "", "workspace size (e.g. 80G)")
        fs.StringVar(&amp;storage, "storage", "", "Proxmox storage (default local-zfs)")
        fs.BoolVar(&amp;help, "help", false, "show help")
        fs.BoolVar(&amp;help, "h", false, "show help")
        if err := parseFlags(fs, args, printWorkspaceCreateUsage, &amp;help); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">name = strings.TrimSpace(name)
        size = strings.TrimSpace(size)
        storage = strings.TrimSpace(storage)
        if name == "" || size == "" </span><span class="cov0" title="0">{
                printWorkspaceCreateUsage()
                return fmt.Errorf("name and size are required")
        }</span>
        <span class="cov0" title="0">sizeGB, err := parseSizeGB(size)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">client := newAPIClient(opts.socketPath, opts.timeout)
        req := workspaceCreateRequest{
                Name:    name,
                SizeGB:  sizeGB,
                Storage: storage,
        }
        payload, err := client.doJSON(ctx, http.MethodPost, "/v1/workspaces", req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if opts.jsonOutput </span><span class="cov0" title="0">{
                return prettyPrintJSON(os.Stdout, payload)
        }</span>
        <span class="cov0" title="0">var resp workspaceResponse
        if err := json.Unmarshal(payload, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">printWorkspace(resp)
        return nil</span>
}

func runWorkspaceList(ctx context.Context, args []string, base commonFlags) error <span class="cov0" title="0">{
        fs := newFlagSet("workspace list")
        opts := base
        opts.bind(fs)
        var help bool
        fs.BoolVar(&amp;help, "help", false, "show help")
        fs.BoolVar(&amp;help, "h", false, "show help")
        if err := parseFlags(fs, args, printWorkspaceListUsage, &amp;help); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">client := newAPIClient(opts.socketPath, opts.timeout)
        payload, err := client.doJSON(ctx, http.MethodGet, "/v1/workspaces", nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if opts.jsonOutput </span><span class="cov0" title="0">{
                return prettyPrintJSON(os.Stdout, payload)
        }</span>
        <span class="cov0" title="0">var resp workspacesResponse
        if err := json.Unmarshal(payload, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">printWorkspaceList(resp.Workspaces)
        return nil</span>
}

func runWorkspaceAttach(ctx context.Context, args []string, base commonFlags) error <span class="cov0" title="0">{
        fs := newFlagSet("workspace attach")
        opts := base
        opts.bind(fs)
        var help bool
        fs.BoolVar(&amp;help, "help", false, "show help")
        fs.BoolVar(&amp;help, "h", false, "show help")
        if err := parseFlags(fs, args, printWorkspaceAttachUsage, &amp;help); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if fs.NArg() &lt; 2 </span><span class="cov0" title="0">{
                printWorkspaceAttachUsage()
                return fmt.Errorf("workspace and vmid are required")
        }</span>
        <span class="cov0" title="0">workspace := strings.TrimSpace(fs.Arg(0))
        if workspace == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("workspace is required")
        }</span>
        <span class="cov0" title="0">vmid, err := parseVMID(fs.Arg(1))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">client := newAPIClient(opts.socketPath, opts.timeout)
        req := workspaceAttachRequest{VMID: vmid}
        payload, err := client.doJSON(ctx, http.MethodPost, fmt.Sprintf("/v1/workspaces/%s/attach", workspace), req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if opts.jsonOutput </span><span class="cov0" title="0">{
                return prettyPrintJSON(os.Stdout, payload)
        }</span>
        <span class="cov0" title="0">var resp workspaceResponse
        if err := json.Unmarshal(payload, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">printWorkspace(resp)
        return nil</span>
}

func runWorkspaceDetach(ctx context.Context, args []string, base commonFlags) error <span class="cov0" title="0">{
        fs := newFlagSet("workspace detach")
        opts := base
        opts.bind(fs)
        var help bool
        fs.BoolVar(&amp;help, "help", false, "show help")
        fs.BoolVar(&amp;help, "h", false, "show help")
        if err := parseFlags(fs, args, printWorkspaceDetachUsage, &amp;help); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if fs.NArg() &lt; 1 </span><span class="cov0" title="0">{
                printWorkspaceDetachUsage()
                return fmt.Errorf("workspace is required")
        }</span>
        <span class="cov0" title="0">workspace := strings.TrimSpace(fs.Arg(0))
        if workspace == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("workspace is required")
        }</span>
        <span class="cov0" title="0">client := newAPIClient(opts.socketPath, opts.timeout)
        payload, err := client.doJSON(ctx, http.MethodPost, fmt.Sprintf("/v1/workspaces/%s/detach", workspace), nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if opts.jsonOutput </span><span class="cov0" title="0">{
                return prettyPrintJSON(os.Stdout, payload)
        }</span>
        <span class="cov0" title="0">var resp workspaceResponse
        if err := json.Unmarshal(payload, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">printWorkspace(resp)
        return nil</span>
}

func runWorkspaceRebind(ctx context.Context, args []string, base commonFlags) error <span class="cov0" title="0">{
        fs := newFlagSet("workspace rebind")
        opts := base
        opts.bind(fs)
        var profile string
        var ttl string
        var keepOld bool
        var help bool
        fs.StringVar(&amp;profile, "profile", "", "profile name")
        fs.StringVar(&amp;ttl, "ttl", "", ttlFlagDescription)
        fs.BoolVar(&amp;keepOld, "keep-old", false, "keep old sandbox running")
        fs.BoolVar(&amp;help, "help", false, "show help")
        fs.BoolVar(&amp;help, "h", false, "show help")
        if err := parseFlags(fs, args, printWorkspaceRebindUsage, &amp;help); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if fs.NArg() &lt; 1 </span><span class="cov0" title="0">{
                printWorkspaceRebindUsage()
                return fmt.Errorf("workspace is required")
        }</span>
        <span class="cov0" title="0">workspace := strings.TrimSpace(fs.Arg(0))
        if workspace == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("workspace is required")
        }</span>
        <span class="cov0" title="0">profile = strings.TrimSpace(profile)
        if profile == "" </span><span class="cov0" title="0">{
                printWorkspaceRebindUsage()
                return fmt.Errorf("profile is required")
        }</span>
        <span class="cov0" title="0">ttlMinutes, err := parseTTLMinutes(ttl)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">client := newAPIClient(opts.socketPath, opts.timeout)
        req := workspaceRebindRequest{
                Profile:    profile,
                TTLMinutes: ttlMinutes,
                KeepOld:    keepOld,
        }
        payload, err := client.doJSON(ctx, http.MethodPost, fmt.Sprintf("/v1/workspaces/%s/rebind", workspace), req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if opts.jsonOutput </span><span class="cov0" title="0">{
                return prettyPrintJSON(os.Stdout, payload)
        }</span>
        <span class="cov0" title="0">var resp workspaceRebindResponse
        if err := json.Unmarshal(payload, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">printWorkspaceRebind(resp, keepOld)
        return nil</span>
}

func runLogsCommand(ctx context.Context, args []string, base commonFlags) error <span class="cov1" title="1">{
        fs := newFlagSet("logs")
        opts := base
        opts.bind(fs)
        var follow bool
        var tail int
        var help bool
        fs.BoolVar(&amp;follow, "follow", false, "follow new events")
        fs.IntVar(&amp;tail, "tail", defaultLogTail, "show the last N events")
        fs.BoolVar(&amp;help, "help", false, "show help")
        fs.BoolVar(&amp;help, "h", false, "show help")
        if err := parseFlags(fs, args, printLogsUsage, &amp;help); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if fs.NArg() &lt; 1 </span><span class="cov1" title="1">{
                printLogsUsage()
                return fmt.Errorf("vmid is required")
        }</span>
        <span class="cov0" title="0">vmid, err := parseVMID(fs.Arg(0))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if tail &lt;= 0 </span><span class="cov0" title="0">{
                tail = defaultLogTail
        }</span>
        <span class="cov0" title="0">if tail &gt; maxEventLimit </span><span class="cov0" title="0">{
                tail = maxEventLimit
        }</span>

        <span class="cov0" title="0">client := newAPIClient(opts.socketPath, opts.timeout)
        resp, err := fetchEvents(ctx, client, vmid, tail, 0)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">lastID := printEvents(resp.Events, opts.jsonOutput)
        if resp.LastID &gt; lastID </span><span class="cov0" title="0">{
                lastID = resp.LastID
        }</span>
        <span class="cov0" title="0">if !follow </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if lastID == 0 </span><span class="cov0" title="0">{
                lastID = resp.LastID
        }</span>

        <span class="cov0" title="0">ticker := time.NewTicker(eventPollInterval)
        defer ticker.Stop()
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        resp, err := fetchEvents(ctx, client, vmid, 0, lastID)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">latest := printEvents(resp.Events, opts.jsonOutput)
                        if latest &gt; lastID </span><span class="cov0" title="0">{
                                lastID = latest
                        }</span>
                        <span class="cov0" title="0">if resp.LastID &gt; lastID </span><span class="cov0" title="0">{
                                lastID = resp.LastID
                        }</span>
                }
        }
}

func fetchEvents(ctx context.Context, client *apiClient, vmid int, tail int, after int64) (eventsResponse, error) <span class="cov0" title="0">{
        query := ""
        limit := defaultEventLimit
        if limit &gt; maxEventLimit </span><span class="cov0" title="0">{
                limit = maxEventLimit
        }</span>
        <span class="cov0" title="0">if tail &gt; 0 </span><span class="cov0" title="0">{
                query = fmt.Sprintf("?tail=%d", tail)
        }</span> else<span class="cov0" title="0"> if after &gt; 0 </span><span class="cov0" title="0">{
                query = fmt.Sprintf("?after=%d&amp;limit=%d", after, limit)
        }</span> else<span class="cov0" title="0"> {
                query = fmt.Sprintf("?limit=%d", limit)
        }</span>
        <span class="cov0" title="0">payload, err := client.doJSON(ctx, http.MethodGet, fmt.Sprintf("/v1/sandboxes/%d/events%s", vmid, query), nil)
        if err != nil </span><span class="cov0" title="0">{
                return eventsResponse{}, err
        }</span>
        <span class="cov0" title="0">var resp eventsResponse
        if err := json.Unmarshal(payload, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return eventsResponse{}, err
        }</span>
        <span class="cov0" title="0">return resp, nil</span>
}

func printSandbox(sb sandboxResponse) <span class="cov0" title="0">{
        fmt.Printf("VMID: %d\n", sb.VMID)
        fmt.Printf("Name: %s\n", sb.Name)
        fmt.Printf("Profile: %s\n", sb.Profile)
        fmt.Printf("State: %s\n", sb.State)
        fmt.Printf("IP: %s\n", orDash(sb.IP))
        fmt.Printf("Workspace: %s\n", orDashPtr(sb.WorkspaceID))
        fmt.Printf("Keepalive: %t\n", sb.Keepalive)
        fmt.Printf("Lease Expires: %s\n", orDashPtr(sb.LeaseExpires))
        fmt.Printf("Created At: %s\n", sb.CreatedAt)
        fmt.Printf("Updated At: %s\n", sb.LastUpdatedAt)
}</span>

func printSandboxList(sandboxes []sandboxResponse) <span class="cov0" title="0">{
        w := tabwriter.NewWriter(os.Stdout, 2, 8, 2, ' ', 0)
        fmt.Fprintln(w, "VMID\tNAME\tPROFILE\tSTATE\tIP\tLEASE")
        for _, sb := range sandboxes </span><span class="cov0" title="0">{
                lease := orDashPtr(sb.LeaseExpires)
                fmt.Fprintf(w, "%d\t%s\t%s\t%s\t%s\t%s\n", sb.VMID, sb.Name, sb.Profile, sb.State, orDash(sb.IP), lease)
        }</span>
        <span class="cov0" title="0">_ = w.Flush()</span>
}

func printWorkspace(ws workspaceResponse) <span class="cov0" title="0">{
        fmt.Printf("ID: %s\n", ws.ID)
        fmt.Printf("Name: %s\n", ws.Name)
        fmt.Printf("Storage: %s\n", ws.Storage)
        fmt.Printf("Volume ID: %s\n", ws.VolumeID)
        fmt.Printf("Size GB: %d\n", ws.SizeGB)
        fmt.Printf("Attached VMID: %s\n", vmidString(ws.AttachedVMID))
        fmt.Printf("Created At: %s\n", ws.CreatedAt)
        fmt.Printf("Updated At: %s\n", ws.UpdatedAt)
}</span>

func printWorkspaceList(workspaces []workspaceResponse) <span class="cov0" title="0">{
        w := tabwriter.NewWriter(os.Stdout, 2, 8, 2, ' ', 0)
        fmt.Fprintln(w, "ID\tNAME\tSIZE(GB)\tSTORAGE\tATTACHED")
        for _, ws := range workspaces </span><span class="cov0" title="0">{
                fmt.Fprintf(w, "%s\t%s\t%d\t%s\t%s\n", ws.ID, ws.Name, ws.SizeGB, ws.Storage, vmidString(ws.AttachedVMID))
        }</span>
        <span class="cov0" title="0">_ = w.Flush()</span>
}

func printWorkspaceRebind(resp workspaceRebindResponse, keepOld bool) <span class="cov0" title="0">{
        fmt.Printf("Workspace: %s\n", resp.Workspace.Name)
        fmt.Printf("New VMID: %d\n", resp.Sandbox.VMID)
        fmt.Printf("New IP: %s\n", orDash(resp.Sandbox.IP))
        if resp.OldVMID != nil </span><span class="cov0" title="0">{
                status := "destroyed"
                if keepOld </span><span class="cov0" title="0">{
                        status = "kept"
                }</span>
                <span class="cov0" title="0">fmt.Printf("Old VMID: %d (%s)\n", *resp.OldVMID, status)</span>
        }
}

func printJob(job jobResponse) <span class="cov0" title="0">{
        fmt.Printf("Job ID: %s\n", job.ID)
        fmt.Printf("Repo: %s\n", job.RepoURL)
        fmt.Printf("Ref: %s\n", job.Ref)
        fmt.Printf("Profile: %s\n", job.Profile)
        fmt.Printf("Task: %s\n", job.Task)
        fmt.Printf("Mode: %s\n", job.Mode)
        fmt.Printf("Status: %s\n", job.Status)
        fmt.Printf("Keepalive: %t\n", job.Keepalive)
        fmt.Printf("TTL Minutes: %s\n", ttlMinutesString(job.TTLMinutes))
        fmt.Printf("Sandbox VMID: %s\n", vmidString(job.SandboxVMID))
        fmt.Printf("Created At: %s\n", job.CreatedAt)
        fmt.Printf("Updated At: %s\n", job.UpdatedAt)
}</span>

func printArtifactsList(artifacts []artifactInfo) <span class="cov0" title="0">{
        w := tabwriter.NewWriter(os.Stdout, 2, 8, 2, ' ', 0)
        fmt.Fprintln(w, "NAME\tPATH\tSIZE(B)\tMIME\tCREATED\tSHA256")
        for _, artifact := range artifacts </span><span class="cov0" title="0">{
                name := strings.TrimSpace(artifact.Name)
                if name == "" </span><span class="cov0" title="0">{
                        name = filepath.Base(strings.TrimSpace(artifact.Path))
                }</span>
                <span class="cov0" title="0">sha := strings.TrimSpace(artifact.Sha256)
                if len(sha) &gt; 12 </span><span class="cov0" title="0">{
                        sha = sha[:12]
                }</span>
                <span class="cov0" title="0">fmt.Fprintf(w, "%s\t%s\t%d\t%s\t%s\t%s\n",
                        orDash(name),
                        orDash(artifact.Path),
                        artifact.SizeBytes,
                        orDash(artifact.MIME),
                        orDash(artifact.CreatedAt),
                        orDash(sha),
                )</span>
        }
        <span class="cov0" title="0">_ = w.Flush()</span>
}

func printEvents(events []eventResponse, jsonOutput bool) int64 <span class="cov0" title="0">{
        var lastID int64
        for _, ev := range events </span><span class="cov0" title="0">{
                if ev.ID &gt; lastID </span><span class="cov0" title="0">{
                        lastID = ev.ID
                }</span>
                <span class="cov0" title="0">if jsonOutput </span><span class="cov0" title="0">{
                        data, err := json.Marshal(ev)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">_, _ = os.Stdout.Write(append(data, '\n'))
                        continue</span>
                }
                <span class="cov0" title="0">job := "-"
                if strings.TrimSpace(ev.JobID) != "" </span><span class="cov0" title="0">{
                        job = ev.JobID
                }</span>
                <span class="cov0" title="0">msg := strings.TrimSpace(ev.Message)
                if msg == "" </span><span class="cov0" title="0">{
                        msg = "-"
                }</span>
                <span class="cov0" title="0">fmt.Printf("%s\t%s\tjob=%s\t%s\n", ev.Timestamp, ev.Kind, job, msg)</span>
        }
        <span class="cov0" title="0">return lastID</span>
}

func selectArtifact(artifacts []artifactInfo, path, name string, latest, bundle bool) (artifactInfo, error) <span class="cov0" title="0">{
        if len(artifacts) == 0 </span><span class="cov0" title="0">{
                return artifactInfo{}, fmt.Errorf("no artifacts found")
        }</span>
        <span class="cov0" title="0">if path != "" </span><span class="cov0" title="0">{
                for _, artifact := range artifacts </span><span class="cov0" title="0">{
                        if strings.TrimSpace(artifact.Path) == path </span><span class="cov0" title="0">{
                                return artifact, nil
                        }</span>
                }
                <span class="cov0" title="0">return artifactInfo{}, fmt.Errorf("artifact path %q not found", path)</span>
        }
        <span class="cov0" title="0">if name != "" </span><span class="cov0" title="0">{
                if strings.ContainsAny(name, "/\\") </span><span class="cov0" title="0">{
                        return artifactInfo{}, fmt.Errorf("artifact name must not contain path separators")
                }</span>
                <span class="cov0" title="0">var match *artifactInfo
                for i := range artifacts </span><span class="cov0" title="0">{
                        if artifacts[i].Name == name </span><span class="cov0" title="0">{
                                match = &amp;artifacts[i]
                        }</span>
                }
                <span class="cov0" title="0">if match == nil </span><span class="cov0" title="0">{
                        return artifactInfo{}, fmt.Errorf("artifact name %q not found", name)
                }</span>
                <span class="cov0" title="0">return *match, nil</span>
        }
        <span class="cov0" title="0">if bundle </span><span class="cov0" title="0">{
                var match *artifactInfo
                for i := range artifacts </span><span class="cov0" title="0">{
                        if artifacts[i].Name == defaultArtifactBundleName </span><span class="cov0" title="0">{
                                match = &amp;artifacts[i]
                        }</span>
                }
                <span class="cov0" title="0">if match != nil </span><span class="cov0" title="0">{
                        return *match, nil
                }</span>
        }
        <span class="cov0" title="0">if latest || bundle </span><span class="cov0" title="0">{
                return artifacts[len(artifacts)-1], nil
        }</span>
        <span class="cov0" title="0">return artifacts[len(artifacts)-1], nil</span>
}

func resolveArtifactOutPath(out, name string) (string, error) <span class="cov0" title="0">{
        name = strings.TrimSpace(name)
        if name == "" </span><span class="cov0" title="0">{
                name = "artifact"
        }</span>
        <span class="cov0" title="0">out = strings.TrimSpace(out)
        if out == "" </span><span class="cov0" title="0">{
                return name, nil
        }</span>
        <span class="cov0" title="0">if strings.HasSuffix(out, string(os.PathSeparator)) </span><span class="cov0" title="0">{
                if err := os.MkdirAll(out, 0o750); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">return filepath.Join(out, name), nil</span>
        }
        <span class="cov0" title="0">if info, err := os.Stat(out); err == nil &amp;&amp; info.IsDir() </span><span class="cov0" title="0">{
                return filepath.Join(out, name), nil
        }</span> else<span class="cov0" title="0"> if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">dir := filepath.Dir(out)
        if dir != "." &amp;&amp; dir != "" </span><span class="cov0" title="0">{
                if err := os.MkdirAll(dir, 0o750); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }
        <span class="cov0" title="0">return out, nil</span>
}

func parseVMID(value string) (int, error) <span class="cov0" title="0">{
        vmid, err := strconv.Atoi(strings.TrimSpace(value))
        if err != nil || vmid &lt;= 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid vmid %q", value)
        }</span>
        <span class="cov0" title="0">return vmid, nil</span>
}

func parseTTLMinutes(value string) (*int, error) <span class="cov0" title="0">{
        value = strings.TrimSpace(value)
        if value == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if minutes, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                if minutes &lt;= 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("ttl must be positive")
                }</span>
                <span class="cov0" title="0">return &amp;minutes, nil</span>
        }
        <span class="cov0" title="0">dur, err := time.ParseDuration(value)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid ttl %q", value)
        }</span>
        <span class="cov0" title="0">if dur &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ttl must be positive")
        }</span>
        <span class="cov0" title="0">minutes := int(math.Ceil(dur.Minutes()))
        if minutes &lt;= 0 </span><span class="cov0" title="0">{
                minutes = 1
        }</span>
        <span class="cov0" title="0">return &amp;minutes, nil</span>
}

func parseRequiredTTLMinutes(value string) (int, error) <span class="cov0" title="0">{
        minutes, err := parseTTLMinutes(value)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">if minutes == nil || *minutes &lt;= 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("ttl must be positive")
        }</span>
        <span class="cov0" title="0">return *minutes, nil</span>
}

func parseSizeGB(value string) (int, error) <span class="cov0" title="0">{
        value = strings.TrimSpace(value)
        if value == "" </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("size is required")
        }</span>
        <span class="cov0" title="0">lower := strings.ToLower(value)
        switch </span>{
        case strings.HasSuffix(lower, "gb"):<span class="cov0" title="0">
                lower = strings.TrimSuffix(lower, "gb")</span>
        case strings.HasSuffix(lower, "g"):<span class="cov0" title="0">
                lower = strings.TrimSuffix(lower, "g")</span>
        }
        <span class="cov0" title="0">lower = strings.TrimSpace(lower)
        size, err := strconv.Atoi(lower)
        if err != nil || size &lt;= 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid size %q", value)
        }</span>
        <span class="cov0" title="0">return size, nil</span>
}

func orDash(value string) string <span class="cov0" title="0">{
        if strings.TrimSpace(value) == "" </span><span class="cov0" title="0">{
                return "-"
        }</span>
        <span class="cov0" title="0">return value</span>
}

func orDashPtr(value *string) string <span class="cov0" title="0">{
        if value == nil || strings.TrimSpace(*value) == "" </span><span class="cov0" title="0">{
                return "-"
        }</span>
        <span class="cov0" title="0">return *value</span>
}

func ttlMinutesString(value *int) string <span class="cov0" title="0">{
        if value == nil || *value == 0 </span><span class="cov0" title="0">{
                return "-"
        }</span>
        <span class="cov0" title="0">return strconv.Itoa(*value)</span>
}

func vmidString(value *int) string <span class="cov0" title="0">{
        if value == nil || *value &lt;= 0 </span><span class="cov0" title="0">{
                return "-"
        }</span>
        <span class="cov0" title="0">return strconv.Itoa(*value)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "errors"
        "flag"
        "fmt"
        "io"
        "os"
        "os/signal"
        "strings"
        "time"

        "github.com/agentlab/agentlab/internal/buildinfo"
)

const usageText = `agentlab is the CLI for agentlabd.

Usage:
  agentlab --version
  agentlab [--socket PATH] [--json] [--timeout DURATION] job run --repo &lt;url&gt; --task &lt;task&gt; --profile &lt;profile&gt; [--ref &lt;ref&gt;] [--mode &lt;mode&gt;] [--ttl &lt;ttl&gt;] [--keepalive]
  agentlab [--socket PATH] [--json] [--timeout DURATION] job show &lt;job_id&gt; [--events-tail &lt;n&gt;]
  agentlab [--socket PATH] [--json] [--timeout DURATION] job artifacts &lt;job_id&gt;
  agentlab [--socket PATH] [--json] [--timeout DURATION] job artifacts download &lt;job_id&gt; [--out &lt;path&gt;] [--path &lt;path&gt;] [--name &lt;name&gt;] [--latest] [--bundle]
  agentlab [--socket PATH] [--json] [--timeout DURATION] sandbox new --profile &lt;profile&gt; [--name &lt;name&gt;] [--ttl &lt;ttl&gt;] [--keepalive] [--workspace &lt;id&gt;] [--vmid &lt;vmid&gt;] [--job &lt;id&gt;]
  agentlab [--socket PATH] [--json] [--timeout DURATION] sandbox list
  agentlab [--socket PATH] [--json] [--timeout DURATION] sandbox show &lt;vmid&gt;
  agentlab [--socket PATH] [--json] [--timeout DURATION] sandbox destroy &lt;vmid&gt;
  agentlab [--socket PATH] [--json] [--timeout DURATION] sandbox lease renew &lt;vmid&gt; --ttl &lt;ttl&gt;
  agentlab [--socket PATH] [--json] [--timeout DURATION] workspace create --name &lt;name&gt; --size &lt;size&gt; [--storage &lt;storage&gt;]
  agentlab [--socket PATH] [--json] [--timeout DURATION] workspace list
  agentlab [--socket PATH] [--json] [--timeout DURATION] workspace attach &lt;workspace&gt; &lt;vmid&gt;
  agentlab [--socket PATH] [--json] [--timeout DURATION] workspace detach &lt;workspace&gt;
  agentlab [--socket PATH] [--json] [--timeout DURATION] workspace rebind &lt;workspace&gt; --profile &lt;profile&gt; [--ttl &lt;ttl&gt;] [--keep-old]
  agentlab [--socket PATH] [--json] [--timeout DURATION] ssh &lt;vmid&gt; [--user &lt;user&gt;] [--port &lt;port&gt;] [--identity &lt;path&gt;] [--exec]
  agentlab [--socket PATH] [--json] [--timeout DURATION] logs &lt;vmid&gt; [--follow] [--tail &lt;n&gt;]

Global Flags:
  --socket PATH   Path to agentlabd socket (default /run/agentlab/agentlabd.sock)
  --json          Output json
  --timeout       Request timeout (e.g. 30s, 2m)
`

type globalOptions struct {
        socketPath  string
        jsonOutput  bool
        showVersion bool
        timeout     time.Duration
}

func main() <span class="cov0" title="0">{
        opts, args, err := parseGlobal(os.Args[1:])
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, err)
                printUsage()
                os.Exit(2)
        }</span>
        <span class="cov0" title="0">if opts.showVersion </span><span class="cov0" title="0">{
                fmt.Println(buildinfo.String())
                return
        }</span>
        <span class="cov0" title="0">if len(args) == 0 </span><span class="cov0" title="0">{
                printUsage()
                return
        }</span>
        <span class="cov0" title="0">if isHelpToken(args[0]) </span><span class="cov0" title="0">{
                printUsage()
                return
        }</span>

        <span class="cov0" title="0">ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt)
        defer stop()

        base := commonFlags{socketPath: opts.socketPath, jsonOutput: opts.jsonOutput, timeout: opts.timeout}
        if err := dispatch(ctx, args, base); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, errHelp) </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">fmt.Fprintln(os.Stderr, err)
                os.Exit(1)</span>
        }
}

func parseGlobal(args []string) (globalOptions, []string, error) <span class="cov10" title="27">{
        opts := globalOptions{socketPath: defaultSocketPath}
        fs := flag.NewFlagSet("agentlab", flag.ContinueOnError)
        fs.SetOutput(io.Discard)
        fs.StringVar(&amp;opts.socketPath, "socket", defaultSocketPath, "path to agentlabd socket")
        fs.BoolVar(&amp;opts.jsonOutput, "json", false, jsonFlagDescription)
        fs.DurationVar(&amp;opts.timeout, "timeout", defaultRequestTimeout, "request timeout (e.g. 30s, 2m)")
        fs.BoolVar(&amp;opts.showVersion, "version", false, "print version and exit")
        if err := fs.Parse(args); err != nil </span><span class="cov5" title="5">{
                return opts, nil, err
        }</span>
        <span class="cov9" title="22">if opts.socketPath == "" </span><span class="cov1" title="1">{
                opts.socketPath = defaultSocketPath
        }</span>
        <span class="cov9" title="22">return opts, fs.Args(), nil</span>
}

func dispatch(ctx context.Context, args []string, base commonFlags) error <span class="cov6" title="7">{
        switch args[0] </span>{
        case "job":<span class="cov1" title="1">
                return runJobCommand(ctx, args[1:], base)</span>
        case "sandbox":<span class="cov1" title="1">
                return runSandboxCommand(ctx, args[1:], base)</span>
        case "workspace":<span class="cov1" title="1">
                return runWorkspaceCommand(ctx, args[1:], base)</span>
        case "ssh":<span class="cov1" title="1">
                return runSSHCommand(ctx, args[1:], base)</span>
        case "logs":<span class="cov1" title="1">
                return runLogsCommand(ctx, args[1:], base)</span>
        default:<span class="cov1" title="1">
                printUsage()
                return fmt.Errorf("unknown command %q", args[0])</span>
        }
}

func printUsage() <span class="cov4" title="3">{
        _, _ = fmt.Fprint(os.Stdout, usageText)
}</span>

func printJobUsage() <span class="cov4" title="3">{
        fmt.Fprintln(os.Stdout, "Usage: agentlab job &lt;run|show|artifacts&gt; [flags]")
}</span>

func printJobRunUsage() <span class="cov0" title="0">{
        fmt.Fprintln(os.Stdout, "Usage: agentlab job run --repo &lt;url&gt; --task &lt;task&gt; --profile &lt;profile&gt; [--ref &lt;ref&gt;] [--mode &lt;mode&gt;] [--ttl &lt;ttl&gt;] [--keepalive]")
}</span>

func printJobShowUsage() <span class="cov0" title="0">{
        fmt.Fprintln(os.Stdout, "Usage: agentlab job show &lt;job_id&gt; [--events-tail &lt;n&gt;]")
        fmt.Fprintln(os.Stdout, "Note: --events-tail=0 omits recent events from the response.")
}</span>

func printJobArtifactsUsage() <span class="cov0" title="0">{
        fmt.Fprintln(os.Stdout, "Usage: agentlab job artifacts &lt;job_id&gt;")
}</span>

func printJobArtifactsDownloadUsage() <span class="cov0" title="0">{
        fmt.Fprintln(os.Stdout, "Usage: agentlab job artifacts download &lt;job_id&gt; [--out &lt;path&gt;] [--path &lt;path&gt;] [--name &lt;name&gt;] [--latest] [--bundle]")
        fmt.Fprintln(os.Stdout, "Note: By default, downloads the latest bundle (agentlab-artifacts.tar.gz) when available.")
}</span>

func printSandboxUsage() <span class="cov4" title="3">{
        fmt.Fprintln(os.Stdout, "Usage: agentlab sandbox &lt;new|list|show|destroy|lease&gt;")
}</span>

func printSandboxNewUsage() <span class="cov0" title="0">{
        fmt.Fprintln(os.Stdout, "Usage: agentlab sandbox new --profile &lt;profile&gt; [--name &lt;name&gt;] [--ttl &lt;ttl&gt;] [--keepalive] [--workspace &lt;id&gt;] [--vmid &lt;vmid&gt;] [--job &lt;id&gt;]")
}</span>

func printSandboxListUsage() <span class="cov0" title="0">{
        fmt.Fprintln(os.Stdout, "Usage: agentlab sandbox list")
}</span>

func printSandboxShowUsage() <span class="cov0" title="0">{
        fmt.Fprintln(os.Stdout, "Usage: agentlab sandbox show &lt;vmid&gt;")
}</span>

func printSandboxDestroyUsage() <span class="cov0" title="0">{
        fmt.Fprintln(os.Stdout, "Usage: agentlab sandbox destroy &lt;vmid&gt;")
}</span>

func printSandboxLeaseUsage() <span class="cov0" title="0">{
        fmt.Fprintln(os.Stdout, "Usage: agentlab sandbox lease renew &lt;vmid&gt; --ttl &lt;ttl&gt;")
}</span>

func printSandboxLeaseRenewUsage() <span class="cov0" title="0">{
        printSandboxLeaseUsage()
}</span>

func printWorkspaceUsage() <span class="cov4" title="3">{
        fmt.Fprintln(os.Stdout, "Usage: agentlab workspace &lt;create|list|attach|detach|rebind&gt;")
}</span>

func printWorkspaceCreateUsage() <span class="cov0" title="0">{
        fmt.Fprintln(os.Stdout, "Usage: agentlab workspace create --name &lt;name&gt; --size &lt;size&gt; [--storage &lt;storage&gt;]")
}</span>

func printWorkspaceListUsage() <span class="cov0" title="0">{
        fmt.Fprintln(os.Stdout, "Usage: agentlab workspace list")
}</span>

func printWorkspaceAttachUsage() <span class="cov0" title="0">{
        fmt.Fprintln(os.Stdout, "Usage: agentlab workspace attach &lt;workspace&gt; &lt;vmid&gt;")
}</span>

func printWorkspaceDetachUsage() <span class="cov0" title="0">{
        fmt.Fprintln(os.Stdout, "Usage: agentlab workspace detach &lt;workspace&gt;")
}</span>

func printWorkspaceRebindUsage() <span class="cov0" title="0">{
        fmt.Fprintln(os.Stdout, "Usage: agentlab workspace rebind &lt;workspace&gt; --profile &lt;profile&gt; [--ttl &lt;ttl&gt;] [--keep-old]")
}</span>

func printLogsUsage() <span class="cov2" title="2">{
        fmt.Fprintln(os.Stdout, "Usage: agentlab logs &lt;vmid&gt; [--follow] [--tail &lt;n&gt;]")
        fmt.Fprintln(os.Stdout, "Note: --json outputs one JSON object per line.")
}</span>

func printSSHUsage() <span class="cov2" title="2">{
        fmt.Fprintln(os.Stdout, "Usage: agentlab ssh &lt;vmid&gt; [--user &lt;user&gt;] [--port &lt;port&gt;] [--identity &lt;path&gt;] [--exec]")
        fmt.Fprintln(os.Stdout, "Note: --exec replaces the CLI with ssh when run in a terminal.")
}</span>

func isHelpToken(value string) bool <span class="cov8" title="14">{
        switch strings.TrimSpace(value) </span>{
        case "help", "-h", "--help":<span class="cov7" title="9">
                return true</span>
        default:<span class="cov5" title="5">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "context"
        "encoding/json"
        "fmt"
        "net"
        "net/http"
        "os"
        "os/exec"
        "runtime"
        "strconv"
        "strings"
        "syscall"
        "time"

        "github.com/mattn/go-isatty"
)

const (
        defaultSSHUser       = "agent"
        defaultSSHPort       = 22
        routeCheckTimeout    = 500 * time.Millisecond
        defaultAgentSubnet   = "10.77.0.0/16"
        tailscaleInterfaceID = "tailscale"
)

type sshOutput struct {
        VMID     int      `json:"vmid"`
        IP       string   `json:"ip"`
        User     string   `json:"user"`
        Port     int      `json:"port"`
        Identity string   `json:"identity,omitempty"`
        Args     []string `json:"args"`
        Command  string   `json:"command"`
        Warning  string   `json:"warning,omitempty"`
}

type routeInfo struct {
        Device string
        Via    string
}

func runSSHCommand(ctx context.Context, args []string, base commonFlags) error <span class="cov8" title="1">{
        fs := newFlagSet("ssh")
        opts := base
        opts.bind(fs)
        user := defaultSSHUser
        port := defaultSSHPort
        identity := ""
        execFlag := false
        help := false
        fs.StringVar(&amp;user, "user", defaultSSHUser, "ssh username")
        fs.StringVar(&amp;user, "u", defaultSSHUser, "ssh username")
        fs.IntVar(&amp;port, "port", defaultSSHPort, "ssh port")
        fs.IntVar(&amp;port, "p", defaultSSHPort, "ssh port")
        fs.StringVar(&amp;identity, "identity", "", "ssh identity file")
        fs.StringVar(&amp;identity, "i", "", "ssh identity file")
        fs.BoolVar(&amp;execFlag, "exec", false, "exec ssh instead of printing the command")
        fs.BoolVar(&amp;execFlag, "e", false, "exec ssh instead of printing the command")
        fs.BoolVar(&amp;help, "help", false, "show help")
        fs.BoolVar(&amp;help, "h", false, "show help")
        if err := parseFlags(fs, args, printSSHUsage, &amp;help); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if fs.NArg() &lt; 1 </span><span class="cov8" title="1">{
                printSSHUsage()
                return fmt.Errorf("vmid is required")
        }</span>
        <span class="cov0" title="0">if fs.NArg() &gt; 1 </span><span class="cov0" title="0">{
                printSSHUsage()
                return fmt.Errorf("unexpected extra arguments")
        }</span>
        <span class="cov0" title="0">vmid, err := parseVMID(fs.Arg(0))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">user = strings.TrimSpace(user)
        if user == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("user is required")
        }</span>
        <span class="cov0" title="0">if port &lt;= 0 || port &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid port %d", port)
        }</span>
        <span class="cov0" title="0">if opts.jsonOutput &amp;&amp; execFlag </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot use --json with --exec")
        }</span>
        <span class="cov0" title="0">if execFlag &amp;&amp; !isInteractive() </span><span class="cov0" title="0">{
                return fmt.Errorf("--exec requires an interactive terminal")
        }</span>

        <span class="cov0" title="0">client := newAPIClient(opts.socketPath, opts.timeout)
        payload, err := client.doJSON(ctx, http.MethodGet, fmt.Sprintf("/v1/sandboxes/%d", vmid), nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">var resp sandboxResponse
        if err := json.Unmarshal(payload, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">ip := strings.TrimSpace(resp.IP)
        if ip == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("sandbox %d has no IP yet", vmid)
        }</span>
        <span class="cov0" title="0">parsedIP := net.ParseIP(ip)
        if parsedIP == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("sandbox %d returned invalid IP %q", vmid, ip)
        }</span>

        <span class="cov0" title="0">identity = strings.TrimSpace(identity)
        target := fmt.Sprintf("%s@%s", user, ip)
        sshArgs := buildSSHArgs(target, port, identity)
        fullArgs := append([]string{"ssh"}, sshArgs...)
        warning := tailnetWarning(ctx, parsedIP)

        if opts.jsonOutput </span><span class="cov0" title="0">{
                out := sshOutput{
                        VMID:     vmid,
                        IP:       ip,
                        User:     user,
                        Port:     port,
                        Identity: identity,
                        Args:     fullArgs,
                        Command:  formatShellCommand(fullArgs),
                        Warning:  warning,
                }
                enc := json.NewEncoder(os.Stdout)
                enc.SetEscapeHTML(false)
                return enc.Encode(out)
        }</span>

        <span class="cov0" title="0">if warning != "" </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, warning)
        }</span>

        <span class="cov0" title="0">if execFlag </span><span class="cov0" title="0">{
                return execSSH(sshArgs)
        }</span>

        <span class="cov0" title="0">fmt.Fprintln(os.Stdout, formatShellCommand(fullArgs))
        return nil</span>
}

func buildSSHArgs(target string, port int, identity string) []string <span class="cov0" title="0">{
        args := []string{}
        if identity != "" </span><span class="cov0" title="0">{
                args = append(args, "-i", identity)
        }</span>
        <span class="cov0" title="0">if port != defaultSSHPort </span><span class="cov0" title="0">{
                args = append(args, "-p", strconv.Itoa(port))
        }</span>
        <span class="cov0" title="0">args = append(args, target)
        return args</span>
}

func execSSH(args []string) error <span class="cov0" title="0">{
        path, err := exec.LookPath("ssh")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">argv := append([]string{"ssh"}, args...)
        return syscall.Exec(path, argv, os.Environ())</span>
}

func tailnetWarning(ctx context.Context, ip net.IP) string <span class="cov0" title="0">{
        if ip == nil || !ip.IsPrivate() </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if runtime.GOOS != "linux" </span><span class="cov0" title="0">{
                return fmt.Sprintf("Note: unable to verify tailnet route on %s; ensure the agent subnet route (%s by default) is enabled.", runtime.GOOS, defaultAgentSubnet)
        }</span>
        <span class="cov0" title="0">path, err := exec.LookPath("ip")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("Note: unable to verify tailnet route (missing ip command); ensure the agent subnet route (%s by default) is enabled.", defaultAgentSubnet)
        }</span>
        <span class="cov0" title="0">args := []string{"-4", "route", "get", ip.String()}
        if ip.To4() == nil </span><span class="cov0" title="0">{
                args[0] = "-6"
        }</span>
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, routeCheckTimeout)
        defer cancel()
        out, err := exec.CommandContext(ctx, path, args...).Output()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("Warning: no route to %s detected. If you're on a tailnet device, enable the agent subnet route (%s by default) in Tailscale.", ip.String(), defaultAgentSubnet)
        }</span>
        <span class="cov0" title="0">info := parseIPRouteGet(string(out))
        if info.Device == "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("Note: unable to determine route to %s; ensure the agent subnet route (%s by default) is enabled.", ip.String(), defaultAgentSubnet)
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(info.Device, tailscaleInterfaceID) </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if info.Via != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("Warning: route to %s goes via %s on %s, not Tailscale. If you're on a tailnet device, enable the agent subnet route (%s by default).", ip.String(), info.Via, info.Device, defaultAgentSubnet)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func parseIPRouteGet(output string) routeInfo <span class="cov0" title="0">{
        fields := strings.Fields(output)
        info := routeInfo{}
        for i := 0; i &lt; len(fields); i++ </span><span class="cov0" title="0">{
                switch fields[i] </span>{
                case "dev":<span class="cov0" title="0">
                        if i+1 &lt; len(fields) </span><span class="cov0" title="0">{
                                info.Device = fields[i+1]
                        }</span>
                case "via":<span class="cov0" title="0">
                        if i+1 &lt; len(fields) </span><span class="cov0" title="0">{
                                info.Via = fields[i+1]
                        }</span>
                }
        }
        <span class="cov0" title="0">return info</span>
}

func formatShellCommand(args []string) string <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">quoted := make([]string, len(args))
        for i, arg := range args </span><span class="cov0" title="0">{
                quoted[i] = shellQuote(arg)
        }</span>
        <span class="cov0" title="0">return strings.Join(quoted, " ")</span>
}

func shellQuote(value string) string <span class="cov0" title="0">{
        if value == "" </span><span class="cov0" title="0">{
                return "''"
        }</span>
        <span class="cov0" title="0">if strings.IndexFunc(value, isShellSpecial) == -1 </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return "'" + strings.ReplaceAll(value, "'", "'\\''") + "'"</span>
}

func isShellSpecial(r rune) bool <span class="cov0" title="0">{
        switch r </span>{
        case ' ', '\t', '\n', '\r', '\v', '\f', '\\', '\'', '"', '$', '`':<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func isInteractive() bool <span class="cov0" title="0">{
        return isatty.IsTerminal(os.Stdin.Fd()) &amp;&amp; isatty.IsTerminal(os.Stdout.Fd())
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "log"
        "os"
        "os/signal"
        "syscall"

        "github.com/agentlab/agentlab/internal/buildinfo"
        "github.com/agentlab/agentlab/internal/config"
        "github.com/agentlab/agentlab/internal/daemon"
)

func main() <span class="cov0" title="0">{
        var showVersion bool
        var configPath string

        flag.BoolVar(&amp;showVersion, "version", false, "print version and exit")
        flag.StringVar(&amp;configPath, "config", "", "path to config file")
        flag.Parse()

        if showVersion </span><span class="cov0" title="0">{
                fmt.Println(buildinfo.String())
                return
        }</span>

        <span class="cov0" title="0">cfg, err := config.Load(configPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("config error: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("agentlabd starting (%s)", buildinfo.String())
        ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
        defer stop()

        if err := daemon.Run(ctx, cfg); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("agentlabd error: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package buildinfo

import "fmt"

// These values are overridden at build time via -ldflags.
var (
        Version = "dev"
        Commit  = "none"
        Date    = "unknown"
)

func String() string <span class="cov0" title="0">{
        return fmt.Sprintf("version=%s commit=%s date=%s", Version, Commit, Date)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package config

import (
        "fmt"
        "net"
        "net/url"
        "os"
        "path/filepath"
        "strings"
        "time"

        "gopkg.in/yaml.v3"
)

// Config holds daemon configuration paths and listener settings.
type Config struct {
        ConfigPath              string
        ProfilesDir             string
        DataDir                 string
        LogDir                  string
        RunDir                  string
        SocketPath              string
        DBPath                  string
        BootstrapListen         string
        ArtifactListen          string
        MetricsListen           string
        AgentSubnet             string
        ControllerURL           string
        ArtifactUploadURL       string
        ArtifactDir             string
        ArtifactMaxBytes        int64
        ArtifactTokenTTLMinutes int
        SecretsDir              string
        SecretsBundle           string
        SecretsAgeKeyPath       string
        SecretsSopsPath         string
        SnippetsDir             string
        SnippetStorage          string
        SSHPublicKey            string
        SSHPublicKeyPath        string
        ProxmoxCommandTimeout   time.Duration
        ProvisioningTimeout     time.Duration
}

// FileConfig represents supported YAML config overrides.
type FileConfig struct {
        ProfilesDir             string `yaml:"profiles_dir"`
        DataDir                 string `yaml:"data_dir"`
        LogDir                  string `yaml:"log_dir"`
        RunDir                  string `yaml:"run_dir"`
        SocketPath              string `yaml:"socket_path"`
        DBPath                  string `yaml:"db_path"`
        BootstrapListen         string `yaml:"bootstrap_listen"`
        ArtifactListen          string `yaml:"artifact_listen"`
        MetricsListen           string `yaml:"metrics_listen"`
        AgentSubnet             string `yaml:"agent_subnet"`
        ControllerURL           string `yaml:"controller_url"`
        ArtifactUploadURL       string `yaml:"artifact_upload_url"`
        ArtifactDir             string `yaml:"artifact_dir"`
        ArtifactMaxBytes        int64  `yaml:"artifact_max_bytes"`
        ArtifactTokenTTLMinutes int    `yaml:"artifact_token_ttl_minutes"`
        SecretsDir              string `yaml:"secrets_dir"`
        SecretsBundle           string `yaml:"secrets_bundle"`
        SecretsAgeKeyPath       string `yaml:"secrets_age_key_path"`
        SecretsSopsPath         string `yaml:"secrets_sops_path"`
        SnippetsDir             string `yaml:"snippets_dir"`
        SnippetStorage          string `yaml:"snippet_storage"`
        SSHPublicKey            string `yaml:"ssh_public_key"`
        SSHPublicKeyPath        string `yaml:"ssh_public_key_path"`
        ProxmoxCommandTimeout   string `yaml:"proxmox_command_timeout"`
        ProvisioningTimeout     string `yaml:"provisioning_timeout"`
}

func DefaultConfig() Config <span class="cov9" title="53">{
        dataDir := "/var/lib/agentlab"
        runDir := "/run/agentlab"
        return Config{
                ConfigPath:              "/etc/agentlab/config.yaml",
                ProfilesDir:             "/etc/agentlab/profiles",
                DataDir:                 dataDir,
                LogDir:                  "/var/log/agentlab",
                RunDir:                  runDir,
                SocketPath:              filepath.Join(runDir, "agentlabd.sock"),
                DBPath:                  filepath.Join(dataDir, "agentlab.db"),
                BootstrapListen:         "10.77.0.1:8844",
                ArtifactListen:          "10.77.0.1:8846",
                MetricsListen:           "",
                ArtifactDir:             filepath.Join(dataDir, "artifacts"),
                ArtifactMaxBytes:        256 * 1024 * 1024,
                ArtifactTokenTTLMinutes: 1440,
                SecretsDir:              "/etc/agentlab/secrets",
                SecretsBundle:           "default",
                SecretsAgeKeyPath:       "/etc/agentlab/keys/age.key",
                SecretsSopsPath:         "sops",
                SnippetsDir:             "/var/lib/vz/snippets",
                SnippetStorage:          "local",
                ProxmoxCommandTimeout:   2 * time.Minute,
                ProvisioningTimeout:     10 * time.Minute,
        }
}</span>

// Load reads the YAML config file and applies overrides to defaults.
func Load(path string) (Config, error) <span class="cov0" title="0">{
        cfg := DefaultConfig()
        if path != "" </span><span class="cov0" title="0">{
                cfg.ConfigPath = path
        }</span>
        <span class="cov0" title="0">data, err := os.ReadFile(cfg.ConfigPath)
        if err != nil </span><span class="cov0" title="0">{
                return cfg, fmt.Errorf("read config %s: %w", cfg.ConfigPath, err)
        }</span>
        <span class="cov0" title="0">var fileCfg FileConfig
        if err := yaml.Unmarshal(data, &amp;fileCfg); err != nil </span><span class="cov0" title="0">{
                return cfg, fmt.Errorf("parse config %s: %w", cfg.ConfigPath, err)
        }</span>
        <span class="cov0" title="0">if err := applyFileConfig(&amp;cfg, fileCfg); err != nil </span><span class="cov0" title="0">{
                return cfg, err
        }</span>
        <span class="cov0" title="0">if fileCfg.DataDir != "" &amp;&amp; fileCfg.DBPath == "" </span><span class="cov0" title="0">{
                cfg.DBPath = filepath.Join(cfg.DataDir, "agentlab.db")
        }</span>
        <span class="cov0" title="0">if fileCfg.DataDir != "" &amp;&amp; fileCfg.ArtifactDir == "" </span><span class="cov0" title="0">{
                cfg.ArtifactDir = filepath.Join(cfg.DataDir, "artifacts")
        }</span>
        <span class="cov0" title="0">if fileCfg.RunDir != "" &amp;&amp; fileCfg.SocketPath == "" </span><span class="cov0" title="0">{
                cfg.SocketPath = filepath.Join(cfg.RunDir, "agentlabd.sock")
        }</span>
        <span class="cov0" title="0">if cfg.SSHPublicKey == "" &amp;&amp; cfg.SSHPublicKeyPath != "" </span><span class="cov0" title="0">{
                keyData, err := os.ReadFile(cfg.SSHPublicKeyPath)
                if err != nil </span><span class="cov0" title="0">{
                        return cfg, fmt.Errorf("read ssh public key %s: %w", cfg.SSHPublicKeyPath, err)
                }</span>
                <span class="cov0" title="0">cfg.SSHPublicKey = strings.TrimSpace(string(keyData))</span>
        }
        <span class="cov0" title="0">if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                return cfg, err
        }</span>
        <span class="cov0" title="0">return cfg, nil</span>
}

func applyFileConfig(cfg *Config, fileCfg FileConfig) error <span class="cov0" title="0">{
        if fileCfg.ProfilesDir != "" </span><span class="cov0" title="0">{
                cfg.ProfilesDir = fileCfg.ProfilesDir
        }</span>
        <span class="cov0" title="0">if fileCfg.DataDir != "" </span><span class="cov0" title="0">{
                cfg.DataDir = fileCfg.DataDir
        }</span>
        <span class="cov0" title="0">if fileCfg.LogDir != "" </span><span class="cov0" title="0">{
                cfg.LogDir = fileCfg.LogDir
        }</span>
        <span class="cov0" title="0">if fileCfg.RunDir != "" </span><span class="cov0" title="0">{
                cfg.RunDir = fileCfg.RunDir
        }</span>
        <span class="cov0" title="0">if fileCfg.SocketPath != "" </span><span class="cov0" title="0">{
                cfg.SocketPath = fileCfg.SocketPath
        }</span>
        <span class="cov0" title="0">if fileCfg.DBPath != "" </span><span class="cov0" title="0">{
                cfg.DBPath = fileCfg.DBPath
        }</span>
        <span class="cov0" title="0">if fileCfg.BootstrapListen != "" </span><span class="cov0" title="0">{
                cfg.BootstrapListen = fileCfg.BootstrapListen
        }</span>
        <span class="cov0" title="0">if fileCfg.ArtifactListen != "" </span><span class="cov0" title="0">{
                cfg.ArtifactListen = fileCfg.ArtifactListen
        }</span>
        <span class="cov0" title="0">if fileCfg.MetricsListen != "" </span><span class="cov0" title="0">{
                cfg.MetricsListen = fileCfg.MetricsListen
        }</span>
        <span class="cov0" title="0">if fileCfg.AgentSubnet != "" </span><span class="cov0" title="0">{
                cfg.AgentSubnet = fileCfg.AgentSubnet
        }</span>
        <span class="cov0" title="0">if fileCfg.ControllerURL != "" </span><span class="cov0" title="0">{
                cfg.ControllerURL = fileCfg.ControllerURL
        }</span>
        <span class="cov0" title="0">if fileCfg.ArtifactUploadURL != "" </span><span class="cov0" title="0">{
                cfg.ArtifactUploadURL = fileCfg.ArtifactUploadURL
        }</span>
        <span class="cov0" title="0">if fileCfg.ArtifactDir != "" </span><span class="cov0" title="0">{
                cfg.ArtifactDir = fileCfg.ArtifactDir
        }</span>
        <span class="cov0" title="0">if fileCfg.ArtifactMaxBytes &gt; 0 </span><span class="cov0" title="0">{
                cfg.ArtifactMaxBytes = fileCfg.ArtifactMaxBytes
        }</span>
        <span class="cov0" title="0">if fileCfg.ArtifactTokenTTLMinutes &gt; 0 </span><span class="cov0" title="0">{
                cfg.ArtifactTokenTTLMinutes = fileCfg.ArtifactTokenTTLMinutes
        }</span>
        <span class="cov0" title="0">if fileCfg.SecretsDir != "" </span><span class="cov0" title="0">{
                cfg.SecretsDir = fileCfg.SecretsDir
        }</span>
        <span class="cov0" title="0">if fileCfg.SecretsBundle != "" </span><span class="cov0" title="0">{
                cfg.SecretsBundle = fileCfg.SecretsBundle
        }</span>
        <span class="cov0" title="0">if fileCfg.SecretsAgeKeyPath != "" </span><span class="cov0" title="0">{
                cfg.SecretsAgeKeyPath = fileCfg.SecretsAgeKeyPath
        }</span>
        <span class="cov0" title="0">if fileCfg.SecretsSopsPath != "" </span><span class="cov0" title="0">{
                cfg.SecretsSopsPath = fileCfg.SecretsSopsPath
        }</span>
        <span class="cov0" title="0">if fileCfg.SnippetsDir != "" </span><span class="cov0" title="0">{
                cfg.SnippetsDir = fileCfg.SnippetsDir
        }</span>
        <span class="cov0" title="0">if fileCfg.SnippetStorage != "" </span><span class="cov0" title="0">{
                cfg.SnippetStorage = fileCfg.SnippetStorage
        }</span>
        <span class="cov0" title="0">if fileCfg.SSHPublicKey != "" </span><span class="cov0" title="0">{
                cfg.SSHPublicKey = fileCfg.SSHPublicKey
        }</span>
        <span class="cov0" title="0">if fileCfg.SSHPublicKeyPath != "" </span><span class="cov0" title="0">{
                cfg.SSHPublicKeyPath = fileCfg.SSHPublicKeyPath
        }</span>
        <span class="cov0" title="0">if fileCfg.ProxmoxCommandTimeout != "" </span><span class="cov0" title="0">{
                timeout, err := parseDurationField(fileCfg.ProxmoxCommandTimeout, "proxmox_command_timeout")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">cfg.ProxmoxCommandTimeout = timeout</span>
        }
        <span class="cov0" title="0">if fileCfg.ProvisioningTimeout != "" </span><span class="cov0" title="0">{
                timeout, err := parseDurationField(fileCfg.ProvisioningTimeout, "provisioning_timeout")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">cfg.ProvisioningTimeout = timeout</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Validate performs basic validation without exposing secrets.
func (c Config) Validate() error <span class="cov9" title="53">{
        if c.ConfigPath == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("config_path is required")
        }</span>
        <span class="cov8" title="52">if c.ProfilesDir == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("profiles_dir is required")
        }</span>
        <span class="cov8" title="51">if c.RunDir == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("run_dir is required")
        }</span>
        <span class="cov8" title="50">if c.SocketPath == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("socket_path is required")
        }</span>
        <span class="cov8" title="49">if c.BootstrapListen == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("bootstrap_listen is required")
        }</span>
        <span class="cov8" title="48">if c.ArtifactListen == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("artifact_listen is required")
        }</span>
        <span class="cov8" title="47">if c.ArtifactDir == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("artifact_dir is required")
        }</span>
        <span class="cov8" title="46">if c.ArtifactMaxBytes &lt;= 0 </span><span class="cov2" title="2">{
                return fmt.Errorf("artifact_max_bytes must be positive")
        }</span>
        <span class="cov8" title="44">if c.ArtifactTokenTTLMinutes &lt;= 0 </span><span class="cov2" title="2">{
                return fmt.Errorf("artifact_token_ttl_minutes must be positive")
        }</span>
        <span class="cov8" title="42">if c.SecretsDir == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("secrets_dir is required")
        }</span>
        <span class="cov8" title="41">bootstrapHost, _, err := net.SplitHostPort(c.BootstrapListen)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("bootstrap_listen must be host:port: %w", err)
        }</span>
        <span class="cov8" title="40">artifactHost, _, err := net.SplitHostPort(c.ArtifactListen)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("artifact_listen must be host:port: %w", err)
        }</span>
        <span class="cov8" title="39">agentSubnet := strings.TrimSpace(c.AgentSubnet)
        if agentSubnet != "" </span><span class="cov5" title="8">{
                if _, _, err := net.ParseCIDR(agentSubnet); err != nil </span><span class="cov2" title="2">{
                        return fmt.Errorf("agent_subnet must be CIDR: %w", err)
                }</span>
        }
        <span class="cov8" title="37">bootstrapWildcard := isWildcardHost(bootstrapHost)
        artifactWildcard := isWildcardHost(artifactHost)
        if (bootstrapWildcard || artifactWildcard) &amp;&amp; agentSubnet == "" </span><span class="cov2" title="2">{
                return fmt.Errorf("agent_subnet is required when bootstrap_listen or artifact_listen binds to wildcard")
        }</span>
        <span class="cov8" title="35">if bootstrapWildcard &amp;&amp; strings.TrimSpace(c.ControllerURL) == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("controller_url is required when bootstrap_listen binds to wildcard")
        }</span>
        <span class="cov8" title="34">if artifactWildcard &amp;&amp; strings.TrimSpace(c.ArtifactUploadURL) == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("artifact_upload_url is required when artifact_listen binds to wildcard")
        }</span>
        <span class="cov8" title="33">if strings.TrimSpace(c.ControllerURL) != "" </span><span class="cov4" title="7">{
                if err := validateURL(c.ControllerURL, "controller_url"); err != nil </span><span class="cov3" title="3">{
                        return err
                }</span>
        }
        <span class="cov7" title="30">if strings.TrimSpace(c.ArtifactUploadURL) != "" </span><span class="cov3" title="3">{
                if err := validateURL(c.ArtifactUploadURL, "artifact_upload_url"); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov7" title="30">if strings.TrimSpace(c.MetricsListen) != "" </span><span class="cov4" title="6">{
                host, _, err := net.SplitHostPort(c.MetricsListen)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("metrics_listen must be host:port: %w", err)
                }</span>
                <span class="cov4" title="6">if !isLoopbackHost(host) </span><span class="cov3" title="3">{
                        return fmt.Errorf("metrics_listen must be localhost-only (got %q)", host)
                }</span>
        }
        <span class="cov7" title="27">if c.SSHPublicKeyPath != "" &amp;&amp; c.SSHPublicKey == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("ssh_public_key_path is set but empty or unreadable")
        }</span>
        <span class="cov7" title="26">if c.ProxmoxCommandTimeout &lt; 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("proxmox_command_timeout must be non-negative")
        }</span>
        <span class="cov7" title="25">if c.ProvisioningTimeout &lt; 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("provisioning_timeout must be non-negative")
        }</span>
        <span class="cov7" title="24">return nil</span>
}

func isLoopbackHost(host string) bool <span class="cov6" title="16">{
        if strings.EqualFold(host, "localhost") </span><span class="cov2" title="2">{
                return true
        }</span>
        <span class="cov6" title="14">ip := net.ParseIP(host)
        if ip == nil </span><span class="cov3" title="3">{
                return false
        }</span>
        <span class="cov5" title="11">return ip.IsLoopback()</span>
}

func isWildcardHost(host string) bool <span class="cov10" title="86">{
        host = strings.TrimSpace(strings.Trim(host, "[]"))
        if host == "" </span><span class="cov1" title="1">{
                return true
        }</span>
        <span class="cov9" title="85">if i := strings.LastIndex(host, "%"); i != -1 </span><span class="cov1" title="1">{
                host = host[:i]
        }</span>
        <span class="cov9" title="85">ip := net.ParseIP(host)
        if ip == nil </span><span class="cov3" title="4">{
                return false
        }</span>
        <span class="cov9" title="81">return ip.IsUnspecified()</span>
}

func validateURL(value, field string) error <span class="cov5" title="10">{
        parsed, err := url.Parse(strings.TrimSpace(value))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s must be a valid URL: %w", field, err)
        }</span>
        <span class="cov5" title="10">if parsed.Scheme == "" || parsed.Host == "" </span><span class="cov2" title="2">{
                return fmt.Errorf("%s must include scheme and host", field)
        }</span>
        <span class="cov5" title="8">switch strings.ToLower(parsed.Scheme) </span>{
        case "http", "https":<span class="cov4" title="7">
                return nil</span>
        default:<span class="cov1" title="1">
                return fmt.Errorf("%s must use http or https", field)</span>
        }
}

func parseDurationField(value, field string) (time.Duration, error) <span class="cov0" title="0">{
        value = strings.TrimSpace(value)
        if value == "" </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        <span class="cov0" title="0">dur, err := time.ParseDuration(value)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("%s must be a valid duration: %w", field, err)
        }</span>
        <span class="cov0" title="0">if dur &lt; 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("%s must be non-negative", field)
        }</span>
        <span class="cov0" title="0">return dur, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package daemon

import (
        "crypto/rand"
        "database/sql"
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/agentlab/agentlab/internal/db"
        "github.com/agentlab/agentlab/internal/models"
)

const (
        maxJSONBytes             = 1 &lt;&lt; 20
        defaultSandboxVMIDStart  = 1000
        defaultJobRef            = "main"
        defaultJobMode           = "dangerous"
        maxCreateJobIDIterations = 5
        defaultEventsLimit       = 200
        defaultJobEventsTail     = 50
        maxEventsLimit           = 1000
)

// ControlAPI handles local control plane HTTP requests over the Unix socket.
type ControlAPI struct {
        store           *db.Store
        profiles        map[string]models.Profile
        sandboxManager  *SandboxManager
        workspaceMgr    *WorkspaceManager
        jobOrchestrator *JobOrchestrator
        artifactRoot    string
        now             func() time.Time
}

func NewControlAPI(store *db.Store, profiles map[string]models.Profile, manager *SandboxManager, workspaceMgr *WorkspaceManager, orchestrator *JobOrchestrator, artifactRoot string) *ControlAPI <span class="cov4" title="3">{
        return &amp;ControlAPI{
                store:           store,
                profiles:        profiles,
                sandboxManager:  manager,
                workspaceMgr:    workspaceMgr,
                jobOrchestrator: orchestrator,
                artifactRoot:    strings.TrimSpace(artifactRoot),
                now:             time.Now,
        }
}</span>

func (api *ControlAPI) Register(mux *http.ServeMux) <span class="cov1" title="1">{
        if mux == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov1" title="1">mux.HandleFunc("/v1/jobs", api.handleJobs)
        mux.HandleFunc("/v1/jobs/", api.handleJobByID)
        mux.HandleFunc("/v1/sandboxes", api.handleSandboxes)
        mux.HandleFunc("/v1/sandboxes/", api.handleSandboxByID)
        mux.HandleFunc("/v1/workspaces", api.handleWorkspaces)
        mux.HandleFunc("/v1/workspaces/", api.handleWorkspaceByID)</span>
}

func (api *ControlAPI) handleJobs(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        switch r.Method </span>{
        case http.MethodPost:<span class="cov0" title="0">
                api.handleJobCreate(w, r)</span>
        default:<span class="cov0" title="0">
                writeMethodNotAllowed(w, []string{http.MethodPost})</span>
        }
}

func (api *ControlAPI) handleJobByID(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tail := strings.TrimPrefix(r.URL.Path, "/v1/jobs/")
        parts := strings.Split(strings.Trim(tail, "/"), "/")
        if len(parts) == 0 || parts[0] == "" </span><span class="cov0" title="0">{
                writeError(w, http.StatusNotFound, "job not found")
                return
        }</span>
        <span class="cov0" title="0">jobID := parts[0]

        switch len(parts) </span>{
        case 1:<span class="cov0" title="0">
                if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                        writeMethodNotAllowed(w, []string{http.MethodGet})
                        return
                }</span>
                <span class="cov0" title="0">api.handleJobGet(w, r, jobID)
                return</span>
        case 2:<span class="cov0" title="0">
                if parts[1] == "artifacts" </span><span class="cov0" title="0">{
                        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                                writeMethodNotAllowed(w, []string{http.MethodGet})
                                return
                        }</span>
                        <span class="cov0" title="0">api.handleJobArtifactsList(w, r, jobID)
                        return</span>
                }
        case 3:<span class="cov0" title="0">
                if parts[1] == "artifacts" &amp;&amp; parts[2] == "download" </span><span class="cov0" title="0">{
                        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                                writeMethodNotAllowed(w, []string{http.MethodGet})
                                return
                        }</span>
                        <span class="cov0" title="0">api.handleJobArtifactDownload(w, r, jobID)
                        return</span>
                }
        }

        <span class="cov0" title="0">writeError(w, http.StatusNotFound, "job not found")</span>
}

func (api *ControlAPI) handleJobCreate(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        var req V1JobCreateRequest
        if err := decodeJSON(w, r, &amp;req); err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, err.Error())
                return
        }</span>
        <span class="cov1" title="1">req.RepoURL = strings.TrimSpace(req.RepoURL)
        req.Ref = strings.TrimSpace(req.Ref)
        req.Profile = strings.TrimSpace(req.Profile)
        req.Task = strings.TrimSpace(req.Task)
        req.Mode = strings.TrimSpace(req.Mode)

        if req.RepoURL == "" </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "repo_url is required")
                return
        }</span>
        <span class="cov1" title="1">if req.Profile == "" </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "profile is required")
                return
        }</span>
        <span class="cov1" title="1">if req.Task == "" </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "task is required")
                return
        }</span>
        <span class="cov1" title="1">if req.Ref == "" </span><span class="cov1" title="1">{
                req.Ref = defaultJobRef
        }</span>
        <span class="cov1" title="1">if req.Mode == "" </span><span class="cov1" title="1">{
                req.Mode = defaultJobMode
        }</span>
        <span class="cov1" title="1">if req.TTLMinutes != nil &amp;&amp; *req.TTLMinutes &lt;= 0 </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "ttl_minutes must be positive")
                return
        }</span>
        <span class="cov1" title="1">if !api.profileExists(req.Profile) </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "unknown profile")
                return
        }</span>
        <span class="cov1" title="1">var (
                ttlMinutes int
                keepalive  bool
        )
        if req.Keepalive != nil </span><span class="cov0" title="0">{
                keepalive = *req.Keepalive
        }</span>
        <span class="cov1" title="1">if profile, ok := api.profile(req.Profile); ok </span><span class="cov1" title="1">{
                if err := validateProfileForProvisioning(profile); err != nil </span><span class="cov0" title="0">{
                        writeError(w, http.StatusBadRequest, err.Error())
                        return
                }</span>
                <span class="cov1" title="1">appliedTTL, appliedKeepalive, err := applyProfileBehaviorDefaults(profile, req.TTLMinutes, req.Keepalive)
                if err != nil </span><span class="cov0" title="0">{
                        writeError(w, http.StatusBadRequest, "invalid profile behavior defaults")
                        return
                }</span>
                <span class="cov1" title="1">ttlMinutes = appliedTTL
                keepalive = appliedKeepalive</span>
        } else<span class="cov0" title="0"> {
                ttlMinutes = derefInt(req.TTLMinutes)
        }</span>

        <span class="cov1" title="1">ctx := r.Context()
        var job models.Job
        var createErr error
        for i := 0; i &lt; maxCreateJobIDIterations; i++ </span><span class="cov1" title="1">{
                jobID, err := newJobID()
                if err != nil </span><span class="cov0" title="0">{
                        writeError(w, http.StatusInternalServerError, "failed to create job id")
                        return
                }</span>
                <span class="cov1" title="1">now := api.now().UTC()
                job = models.Job{
                        ID:         jobID,
                        RepoURL:    req.RepoURL,
                        Ref:        req.Ref,
                        Profile:    req.Profile,
                        Task:       req.Task,
                        Mode:       req.Mode,
                        TTLMinutes: ttlMinutes,
                        Keepalive:  keepalive,
                        Status:     models.JobQueued,
                        CreatedAt:  now,
                        UpdatedAt:  now,
                }
                createErr = api.store.CreateJob(ctx, job)
                if createErr == nil </span><span class="cov1" title="1">{
                        break</span>
                }
                <span class="cov0" title="0">if !isUniqueConstraint(createErr) </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov1" title="1">if createErr != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "failed to create job")
                return
        }</span>
        <span class="cov1" title="1">if api.jobOrchestrator == nil </span><span class="cov0" title="0">{
                _ = api.store.UpdateJobStatus(ctx, job.ID, models.JobFailed)
                writeError(w, http.StatusInternalServerError, "job orchestration unavailable")
                return
        }</span>
        <span class="cov1" title="1">api.jobOrchestrator.Start(job.ID)
        writeJSON(w, http.StatusCreated, jobToV1(job))</span>
}

func (api *ControlAPI) handleJobGet(w http.ResponseWriter, r *http.Request, jobID string) <span class="cov0" title="0">{
        jobID = strings.TrimSpace(jobID)
        if jobID == "" </span><span class="cov0" title="0">{
                writeError(w, http.StatusNotFound, "job not found")
                return
        }</span>
        <span class="cov0" title="0">job, err := api.store.GetJob(r.Context(), jobID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        writeError(w, http.StatusNotFound, "job not found")
                        return
                }</span>
                <span class="cov0" title="0">writeError(w, http.StatusInternalServerError, "failed to load job")
                return</span>
        }
        <span class="cov0" title="0">query := r.URL.Query()
        eventsTail := defaultJobEventsTail
        if raw := query.Get("events_tail"); strings.TrimSpace(raw) != "" </span><span class="cov0" title="0">{
                parsed, err := parseQueryInt(raw)
                if err != nil || parsed &lt; 0 </span><span class="cov0" title="0">{
                        writeError(w, http.StatusBadRequest, "invalid events_tail")
                        return
                }</span>
                <span class="cov0" title="0">eventsTail = parsed</span>
        }
        <span class="cov0" title="0">if eventsTail &gt; maxEventsLimit </span><span class="cov0" title="0">{
                eventsTail = maxEventsLimit
        }</span>
        <span class="cov0" title="0">resp := jobToV1(job)
        if eventsTail &gt; 0 </span><span class="cov0" title="0">{
                events, err := api.store.ListEventsByJobTail(r.Context(), job.ID, eventsTail)
                if err != nil </span><span class="cov0" title="0">{
                        writeError(w, http.StatusInternalServerError, "failed to load job events")
                        return
                }</span>
                <span class="cov0" title="0">resp.Events = make([]V1Event, 0, len(events))
                for _, ev := range events </span><span class="cov0" title="0">{
                        resp.Events = append(resp.Events, eventToV1(ev))
                }</span>
        }
        <span class="cov0" title="0">writeJSON(w, http.StatusOK, resp)</span>
}

func (api *ControlAPI) handleJobArtifactsList(w http.ResponseWriter, r *http.Request, jobID string) <span class="cov0" title="0">{
        jobID = strings.TrimSpace(jobID)
        if jobID == "" </span><span class="cov0" title="0">{
                writeError(w, http.StatusNotFound, "job not found")
                return
        }</span>
        <span class="cov0" title="0">if _, err := api.store.GetJob(r.Context(), jobID); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        writeError(w, http.StatusNotFound, "job not found")
                        return
                }</span>
                <span class="cov0" title="0">writeError(w, http.StatusInternalServerError, "failed to load job")
                return</span>
        }
        <span class="cov0" title="0">artifacts, err := api.store.ListArtifactsByJob(r.Context(), jobID)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "failed to list artifacts")
                return
        }</span>
        <span class="cov0" title="0">resp := V1ArtifactsResponse{
                JobID:     jobID,
                Artifacts: make([]V1Artifact, 0, len(artifacts)),
        }
        for _, artifact := range artifacts </span><span class="cov0" title="0">{
                resp.Artifacts = append(resp.Artifacts, artifactToV1(artifact))
        }</span>
        <span class="cov0" title="0">writeJSON(w, http.StatusOK, resp)</span>
}

func (api *ControlAPI) handleJobArtifactDownload(w http.ResponseWriter, r *http.Request, jobID string) <span class="cov0" title="0">{
        jobID = strings.TrimSpace(jobID)
        if jobID == "" </span><span class="cov0" title="0">{
                writeError(w, http.StatusNotFound, "job not found")
                return
        }</span>
        <span class="cov0" title="0">if _, err := api.store.GetJob(r.Context(), jobID); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        writeError(w, http.StatusNotFound, "job not found")
                        return
                }</span>
                <span class="cov0" title="0">writeError(w, http.StatusInternalServerError, "failed to load job")
                return</span>
        }
        <span class="cov0" title="0">root := strings.TrimSpace(api.artifactRoot)
        if root == "" </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "artifact root is not configured")
                return
        }</span>
        <span class="cov0" title="0">artifacts, err := api.store.ListArtifactsByJob(r.Context(), jobID)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "failed to list artifacts")
                return
        }</span>
        <span class="cov0" title="0">if len(artifacts) == 0 </span><span class="cov0" title="0">{
                writeError(w, http.StatusNotFound, "no artifacts found")
                return
        }</span>

        <span class="cov0" title="0">query := r.URL.Query()
        pathParam := strings.TrimSpace(query.Get("path"))
        nameParam := strings.TrimSpace(query.Get("name"))
        if pathParam != "" &amp;&amp; nameParam != "" </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "path and name are mutually exclusive")
                return
        }</span>
        <span class="cov0" title="0">var selected *db.Artifact
        if pathParam != "" </span><span class="cov0" title="0">{
                cleaned, err := sanitizeArtifactPath(pathParam)
                if err != nil </span><span class="cov0" title="0">{
                        writeError(w, http.StatusBadRequest, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">for i := range artifacts </span><span class="cov0" title="0">{
                        if artifacts[i].Path == cleaned </span><span class="cov0" title="0">{
                                selected = &amp;artifacts[i]
                                break</span>
                        }
                }
        } else<span class="cov0" title="0"> if nameParam != "" </span><span class="cov0" title="0">{
                if err := validateArtifactName(nameParam); err != nil </span><span class="cov0" title="0">{
                        writeError(w, http.StatusBadRequest, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">for i := range artifacts </span><span class="cov0" title="0">{
                        if artifacts[i].Name == nameParam </span><span class="cov0" title="0">{
                                selected = &amp;artifacts[i]
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                selected = &amp;artifacts[len(artifacts)-1]
        }</span>

        <span class="cov0" title="0">if selected == nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusNotFound, "artifact not found")
                return
        }</span>
        <span class="cov0" title="0">jobDir := filepath.Join(root, jobID)
        targetPath, err := safeJoin(jobDir, selected.Path)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "artifact path is invalid")
                return
        }</span>
        <span class="cov0" title="0">file, err := os.Open(targetPath)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                        writeError(w, http.StatusNotFound, "artifact file missing")
                        return
                }</span>
                <span class="cov0" title="0">writeError(w, http.StatusInternalServerError, "failed to open artifact")
                return</span>
        }
        <span class="cov0" title="0">defer file.Close()

        stat, err := file.Stat()
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "failed to stat artifact")
                return
        }</span>
        <span class="cov0" title="0">contentType := strings.TrimSpace(selected.MIME)
        if contentType == "" </span><span class="cov0" title="0">{
                contentType = "application/octet-stream"
        }</span>
        <span class="cov0" title="0">filename := filepath.Base(selected.Name)
        if filename == "." || filename == string(filepath.Separator) || filename == "" </span><span class="cov0" title="0">{
                filename = filepath.Base(selected.Path)
        }</span>
        <span class="cov0" title="0">w.Header().Set("Content-Type", contentType)
        w.Header().Set("Content-Length", strconv.FormatInt(stat.Size(), 10))
        w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=%q", filename))
        w.WriteHeader(http.StatusOK)
        _, _ = io.Copy(w, file)</span>
}

func (api *ControlAPI) handleSandboxes(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        switch r.Method </span>{
        case http.MethodPost:<span class="cov0" title="0">
                api.handleSandboxCreate(w, r)</span>
        case http.MethodGet:<span class="cov0" title="0">
                api.handleSandboxList(w, r)</span>
        default:<span class="cov0" title="0">
                writeMethodNotAllowed(w, []string{http.MethodGet, http.MethodPost})</span>
        }
}

func (api *ControlAPI) handleSandboxByID(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tail := strings.TrimPrefix(r.URL.Path, "/v1/sandboxes/")
        parts := strings.Split(strings.Trim(tail, "/"), "/")
        if len(parts) == 0 || parts[0] == "" </span><span class="cov0" title="0">{
                writeError(w, http.StatusNotFound, "sandbox not found")
                return
        }</span>
        <span class="cov0" title="0">vmid, err := strconv.Atoi(parts[0])
        if err != nil || vmid &lt;= 0 </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "invalid vmid")
                return
        }</span>

        <span class="cov0" title="0">switch len(parts) </span>{
        case 1:<span class="cov0" title="0">
                if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                        writeMethodNotAllowed(w, []string{http.MethodGet})
                        return
                }</span>
                <span class="cov0" title="0">api.handleSandboxGet(w, r, vmid)
                return</span>
        case 2:<span class="cov0" title="0">
                if parts[1] == "destroy" </span><span class="cov0" title="0">{
                        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                                writeMethodNotAllowed(w, []string{http.MethodPost})
                                return
                        }</span>
                        <span class="cov0" title="0">api.handleSandboxDestroy(w, r, vmid)
                        return</span>
                }
                <span class="cov0" title="0">if parts[1] == "events" </span><span class="cov0" title="0">{
                        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                                writeMethodNotAllowed(w, []string{http.MethodGet})
                                return
                        }</span>
                        <span class="cov0" title="0">api.handleSandboxEvents(w, r, vmid)
                        return</span>
                }
        case 3:<span class="cov0" title="0">
                if parts[1] == "lease" &amp;&amp; parts[2] == "renew" </span><span class="cov0" title="0">{
                        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                                writeMethodNotAllowed(w, []string{http.MethodPost})
                                return
                        }</span>
                        <span class="cov0" title="0">api.handleSandboxLeaseRenew(w, r, vmid)
                        return</span>
                }
        }

        <span class="cov0" title="0">writeError(w, http.StatusNotFound, "sandbox not found")</span>
}

func (api *ControlAPI) handleWorkspaces(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        switch r.Method </span>{
        case http.MethodPost:<span class="cov0" title="0">
                api.handleWorkspaceCreate(w, r)</span>
        case http.MethodGet:<span class="cov0" title="0">
                api.handleWorkspaceList(w, r)</span>
        default:<span class="cov0" title="0">
                writeMethodNotAllowed(w, []string{http.MethodGet, http.MethodPost})</span>
        }
}

func (api *ControlAPI) handleWorkspaceByID(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tail := strings.TrimPrefix(r.URL.Path, "/v1/workspaces/")
        parts := strings.Split(strings.Trim(tail, "/"), "/")
        if len(parts) == 0 || parts[0] == "" </span><span class="cov0" title="0">{
                writeError(w, http.StatusNotFound, "workspace not found")
                return
        }</span>
        <span class="cov0" title="0">id := parts[0]
        switch len(parts) </span>{
        case 1:<span class="cov0" title="0">
                if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                        writeMethodNotAllowed(w, []string{http.MethodGet})
                        return
                }</span>
                <span class="cov0" title="0">api.handleWorkspaceGet(w, r, id)
                return</span>
        case 2:<span class="cov0" title="0">
                switch parts[1] </span>{
                case "attach":<span class="cov0" title="0">
                        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                                writeMethodNotAllowed(w, []string{http.MethodPost})
                                return
                        }</span>
                        <span class="cov0" title="0">api.handleWorkspaceAttach(w, r, id)
                        return</span>
                case "detach":<span class="cov0" title="0">
                        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                                writeMethodNotAllowed(w, []string{http.MethodPost})
                                return
                        }</span>
                        <span class="cov0" title="0">api.handleWorkspaceDetach(w, r, id)
                        return</span>
                case "rebind":<span class="cov0" title="0">
                        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                                writeMethodNotAllowed(w, []string{http.MethodPost})
                                return
                        }</span>
                        <span class="cov0" title="0">api.handleWorkspaceRebind(w, r, id)
                        return</span>
                }
        }
        <span class="cov0" title="0">writeError(w, http.StatusNotFound, "workspace not found")</span>
}

func (api *ControlAPI) handleSandboxList(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        sandboxes, err := api.store.ListSandboxes(r.Context())
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "failed to list sandboxes")
                return
        }</span>
        <span class="cov0" title="0">resp := V1SandboxesResponse{Sandboxes: make([]V1SandboxResponse, 0, len(sandboxes))}
        for _, sb := range sandboxes </span><span class="cov0" title="0">{
                resp.Sandboxes = append(resp.Sandboxes, sandboxToV1(sb))
        }</span>
        <span class="cov0" title="0">writeJSON(w, http.StatusOK, resp)</span>
}

func (api *ControlAPI) handleSandboxGet(w http.ResponseWriter, r *http.Request, vmid int) <span class="cov0" title="0">{
        sandbox, err := api.store.GetSandbox(r.Context(), vmid)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        writeError(w, http.StatusNotFound, "sandbox not found")
                        return
                }</span>
                <span class="cov0" title="0">writeError(w, http.StatusInternalServerError, "failed to load sandbox")
                return</span>
        }
        <span class="cov0" title="0">writeJSON(w, http.StatusOK, sandboxToV1(sandbox))</span>
}

func (api *ControlAPI) handleSandboxCreate(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        var req V1SandboxCreateRequest
        if err := decodeJSON(w, r, &amp;req); err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, err.Error())
                return
        }</span>
        <span class="cov1" title="1">req.Name = strings.TrimSpace(req.Name)
        req.Profile = strings.TrimSpace(req.Profile)
        req.JobID = strings.TrimSpace(req.JobID)
        provisionSandbox := req.JobID == ""
        if req.Profile == "" </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "profile is required")
                return
        }</span>
        <span class="cov1" title="1">if !api.profileExists(req.Profile) </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "unknown profile")
                return
        }</span>
        <span class="cov1" title="1">var (
                ttlMinutes int
                keepalive  bool
        )
        if req.Keepalive != nil </span><span class="cov0" title="0">{
                keepalive = *req.Keepalive
        }</span>
        <span class="cov1" title="1">if profile, ok := api.profile(req.Profile); ok </span><span class="cov1" title="1">{
                if err := validateProfileForProvisioning(profile); err != nil </span><span class="cov0" title="0">{
                        writeError(w, http.StatusBadRequest, err.Error())
                        return
                }</span>
                <span class="cov1" title="1">appliedTTL, appliedKeepalive, err := applyProfileBehaviorDefaults(profile, req.TTLMinutes, req.Keepalive)
                if err != nil </span><span class="cov0" title="0">{
                        writeError(w, http.StatusBadRequest, "invalid profile behavior defaults")
                        return
                }</span>
                <span class="cov1" title="1">ttlMinutes = appliedTTL
                keepalive = appliedKeepalive</span>
        } else<span class="cov0" title="0"> {
                ttlMinutes = derefInt(req.TTLMinutes)
        }</span>
        <span class="cov1" title="1">if req.TTLMinutes != nil &amp;&amp; *req.TTLMinutes &lt;= 0 </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "ttl_minutes must be positive")
                return
        }</span>
        <span class="cov1" title="1">if req.VMID != nil &amp;&amp; *req.VMID &lt;= 0 </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "vmid must be positive")
                return
        }</span>
        <span class="cov1" title="1">if provisionSandbox &amp;&amp; api.jobOrchestrator == nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusServiceUnavailable, "sandbox provisioning unavailable")
                return
        }</span>

        <span class="cov1" title="1">ctx := r.Context()
        if req.Workspace != nil &amp;&amp; strings.TrimSpace(*req.Workspace) != "" </span><span class="cov0" title="0">{
                if api.workspaceMgr == nil </span><span class="cov0" title="0">{
                        writeError(w, http.StatusInternalServerError, "workspace manager unavailable")
                        return
                }</span>
                <span class="cov0" title="0">workspace, err := api.workspaceMgr.Resolve(ctx, *req.Workspace)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, ErrWorkspaceNotFound) </span><span class="cov0" title="0">{
                                writeError(w, http.StatusNotFound, "workspace not found")
                                return
                        }</span>
                        <span class="cov0" title="0">writeError(w, http.StatusInternalServerError, "failed to load workspace")
                        return</span>
                }
                <span class="cov0" title="0">if workspace.AttachedVM != nil </span><span class="cov0" title="0">{
                        if req.VMID == nil || *req.VMID != *workspace.AttachedVM </span><span class="cov0" title="0">{
                                writeError(w, http.StatusConflict, "workspace already attached")
                                return
                        }</span>
                }
                <span class="cov0" title="0">workspaceID := workspace.ID
                req.Workspace = &amp;workspaceID</span>
        }
        <span class="cov1" title="1">if req.JobID != "" </span><span class="cov0" title="0">{
                if _, err := api.store.GetJob(ctx, req.JobID); err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                                writeError(w, http.StatusNotFound, "job not found")
                                return
                        }</span>
                        <span class="cov0" title="0">writeError(w, http.StatusInternalServerError, "failed to load job")
                        return</span>
                }
        }

        <span class="cov1" title="1">vmid := 0
        if req.VMID != nil </span><span class="cov0" title="0">{
                vmid = *req.VMID
        }</span>
        <span class="cov1" title="1">if vmid == 0 </span><span class="cov1" title="1">{
                next, err := nextSandboxVMID(ctx, api.store)
                if err != nil </span><span class="cov0" title="0">{
                        writeError(w, http.StatusInternalServerError, "failed to allocate vmid")
                        return
                }</span>
                <span class="cov1" title="1">vmid = next</span>
        }
        <span class="cov1" title="1">if req.Name == "" </span><span class="cov1" title="1">{
                req.Name = fmt.Sprintf("sandbox-%d", vmid)
        }</span>

        <span class="cov1" title="1">now := api.now().UTC()
        var leaseExpires time.Time
        if ttlMinutes &gt; 0 </span><span class="cov1" title="1">{
                leaseExpires = now.Add(time.Duration(ttlMinutes) * time.Minute)
        }</span>

        <span class="cov1" title="1">sandbox := models.Sandbox{
                VMID:          vmid,
                Name:          req.Name,
                Profile:       req.Profile,
                State:         models.SandboxRequested,
                Keepalive:     keepalive,
                LeaseExpires:  leaseExpires,
                CreatedAt:     now,
                LastUpdatedAt: now,
        }
        if req.Workspace != nil &amp;&amp; *req.Workspace != "" </span><span class="cov0" title="0">{
                workspace := *req.Workspace
                sandbox.WorkspaceID = &amp;workspace
        }</span>

        <span class="cov1" title="1">createdSandbox, err := createSandboxWithRetry(ctx, api.store, sandbox)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "failed to create sandbox")
                return
        }</span>

        <span class="cov1" title="1">if req.JobID != "" </span><span class="cov0" title="0">{
                updated, err := api.store.UpdateJobSandbox(ctx, req.JobID, createdSandbox.VMID)
                if err != nil </span><span class="cov0" title="0">{
                        writeError(w, http.StatusInternalServerError, "failed to attach job")
                        return
                }</span>
                <span class="cov0" title="0">if !updated </span><span class="cov0" title="0">{
                        writeError(w, http.StatusNotFound, "job not found")
                        return
                }</span>
        }

        <span class="cov1" title="1">if provisionSandbox </span><span class="cov1" title="1">{
                updated, err := api.jobOrchestrator.ProvisionSandbox(ctx, createdSandbox.VMID)
                if err != nil </span><span class="cov0" title="0">{
                        writeError(w, http.StatusInternalServerError, "failed to provision sandbox")
                        return
                }</span>
                <span class="cov1" title="1">writeJSON(w, http.StatusCreated, sandboxToV1(updated))
                return</span>
        }

        <span class="cov0" title="0">writeJSON(w, http.StatusCreated, sandboxToV1(createdSandbox))</span>
}

func (api *ControlAPI) handleWorkspaceCreate(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if api.workspaceMgr == nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "workspace manager unavailable")
                return
        }</span>
        <span class="cov0" title="0">var req V1WorkspaceCreateRequest
        if err := decodeJSON(w, r, &amp;req); err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, err.Error())
                return
        }</span>
        <span class="cov0" title="0">req.Name = strings.TrimSpace(req.Name)
        req.Storage = strings.TrimSpace(req.Storage)
        if req.Name == "" </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "name is required")
                return
        }</span>
        <span class="cov0" title="0">if req.SizeGB &lt;= 0 </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "size_gb must be positive")
                return
        }</span>
        <span class="cov0" title="0">workspace, err := api.workspaceMgr.Create(r.Context(), req.Name, req.Storage, req.SizeGB)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, ErrWorkspaceExists):<span class="cov0" title="0">
                        writeError(w, http.StatusConflict, "workspace already exists")</span>
                default:<span class="cov0" title="0">
                        writeError(w, http.StatusInternalServerError, "failed to create workspace")</span>
                }
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">writeJSON(w, http.StatusCreated, workspaceToV1(workspace))</span>
}

func (api *ControlAPI) handleWorkspaceList(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if api.workspaceMgr == nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "workspace manager unavailable")
                return
        }</span>
        <span class="cov0" title="0">workspaces, err := api.workspaceMgr.List(r.Context())
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "failed to list workspaces")
                return
        }</span>
        <span class="cov0" title="0">resp := V1WorkspacesResponse{Workspaces: make([]V1WorkspaceResponse, 0, len(workspaces))}
        for _, ws := range workspaces </span><span class="cov0" title="0">{
                resp.Workspaces = append(resp.Workspaces, workspaceToV1(ws))
        }</span>
        <span class="cov0" title="0">writeJSON(w, http.StatusOK, resp)</span>
}

func (api *ControlAPI) handleWorkspaceGet(w http.ResponseWriter, r *http.Request, id string) <span class="cov0" title="0">{
        if api.workspaceMgr == nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "workspace manager unavailable")
                return
        }</span>
        <span class="cov0" title="0">workspace, err := api.workspaceMgr.Resolve(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, ErrWorkspaceNotFound) </span><span class="cov0" title="0">{
                        writeError(w, http.StatusNotFound, "workspace not found")
                        return
                }</span>
                <span class="cov0" title="0">writeError(w, http.StatusInternalServerError, "failed to load workspace")
                return</span>
        }
        <span class="cov0" title="0">writeJSON(w, http.StatusOK, workspaceToV1(workspace))</span>
}

func (api *ControlAPI) handleWorkspaceAttach(w http.ResponseWriter, r *http.Request, id string) <span class="cov0" title="0">{
        if api.workspaceMgr == nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "workspace manager unavailable")
                return
        }</span>
        <span class="cov0" title="0">var req V1WorkspaceAttachRequest
        if err := decodeJSON(w, r, &amp;req); err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, err.Error())
                return
        }</span>
        <span class="cov0" title="0">if req.VMID &lt;= 0 </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "vmid must be positive")
                return
        }</span>
        <span class="cov0" title="0">workspace, err := api.workspaceMgr.Attach(r.Context(), id, req.VMID)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, ErrWorkspaceNotFound):<span class="cov0" title="0">
                        writeError(w, http.StatusNotFound, "workspace not found")</span>
                case errors.Is(err, ErrWorkspaceAttached), errors.Is(err, ErrWorkspaceVMInUse):<span class="cov0" title="0">
                        writeError(w, http.StatusConflict, err.Error())</span>
                case errors.Is(err, ErrSandboxNotFound):<span class="cov0" title="0">
                        writeError(w, http.StatusNotFound, "sandbox not found")</span>
                default:<span class="cov0" title="0">
                        writeError(w, http.StatusInternalServerError, "failed to attach workspace")</span>
                }
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">writeJSON(w, http.StatusOK, workspaceToV1(workspace))</span>
}

func (api *ControlAPI) handleWorkspaceDetach(w http.ResponseWriter, r *http.Request, id string) <span class="cov0" title="0">{
        if api.workspaceMgr == nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "workspace manager unavailable")
                return
        }</span>
        <span class="cov0" title="0">workspace, err := api.workspaceMgr.Detach(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, ErrWorkspaceNotFound):<span class="cov0" title="0">
                        writeError(w, http.StatusNotFound, "workspace not found")</span>
                case errors.Is(err, ErrWorkspaceNotAttached):<span class="cov0" title="0">
                        writeError(w, http.StatusConflict, err.Error())</span>
                default:<span class="cov0" title="0">
                        writeError(w, http.StatusInternalServerError, "failed to detach workspace")</span>
                }
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">writeJSON(w, http.StatusOK, workspaceToV1(workspace))</span>
}

func (api *ControlAPI) handleWorkspaceRebind(w http.ResponseWriter, r *http.Request, id string) <span class="cov0" title="0">{
        if api.jobOrchestrator == nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusServiceUnavailable, "workspace rebind unavailable")
                return
        }</span>
        <span class="cov0" title="0">var req V1WorkspaceRebindRequest
        if err := decodeJSON(w, r, &amp;req); err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, err.Error())
                return
        }</span>
        <span class="cov0" title="0">req.Profile = strings.TrimSpace(req.Profile)
        if req.Profile == "" </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "profile is required")
                return
        }</span>
        <span class="cov0" title="0">if req.TTLMinutes != nil &amp;&amp; *req.TTLMinutes &lt;= 0 </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "ttl_minutes must be positive")
                return
        }</span>
        <span class="cov0" title="0">if !api.profileExists(req.Profile) </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "unknown profile")
                return
        }</span>
        <span class="cov0" title="0">if profile, ok := api.profile(req.Profile); ok </span><span class="cov0" title="0">{
                if err := validateProfileForProvisioning(profile); err != nil </span><span class="cov0" title="0">{
                        writeError(w, http.StatusBadRequest, err.Error())
                        return
                }</span>
        }
        <span class="cov0" title="0">result, err := api.jobOrchestrator.RebindWorkspace(r.Context(), id, req.Profile, req.TTLMinutes, req.KeepOld)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, ErrWorkspaceNotFound):<span class="cov0" title="0">
                        writeError(w, http.StatusNotFound, "workspace not found")</span>
                case errors.Is(err, ErrWorkspaceAttached), errors.Is(err, ErrWorkspaceVMInUse):<span class="cov0" title="0">
                        writeError(w, http.StatusConflict, err.Error())</span>
                case errors.Is(err, ErrSandboxNotFound):<span class="cov0" title="0">
                        writeError(w, http.StatusNotFound, "sandbox not found")</span>
                case errors.Is(err, ErrInvalidTransition):<span class="cov0" title="0">
                        writeError(w, http.StatusConflict, "invalid sandbox state")</span>
                default:<span class="cov0" title="0">
                        writeError(w, http.StatusInternalServerError, "failed to rebind workspace")</span>
                }
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">resp := V1WorkspaceRebindResponse{
                Workspace: workspaceToV1(result.Workspace),
                Sandbox:   sandboxToV1(result.Sandbox),
                OldVMID:   result.OldVMID,
        }
        writeJSON(w, http.StatusOK, resp)</span>
}

func (api *ControlAPI) handleSandboxDestroy(w http.ResponseWriter, r *http.Request, vmid int) <span class="cov0" title="0">{
        if api.sandboxManager == nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "sandbox manager unavailable")
                return
        }</span>
        <span class="cov0" title="0">if err := api.sandboxManager.Destroy(r.Context(), vmid); err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, ErrSandboxNotFound):<span class="cov0" title="0">
                        writeError(w, http.StatusNotFound, "sandbox not found")</span>
                case errors.Is(err, ErrInvalidTransition):<span class="cov0" title="0">
                        writeError(w, http.StatusConflict, "invalid sandbox state")</span>
                default:<span class="cov0" title="0">
                        writeError(w, http.StatusInternalServerError, "failed to destroy sandbox")</span>
                }
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">sandbox, err := api.store.GetSandbox(r.Context(), vmid)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "failed to load sandbox")
                return
        }</span>
        <span class="cov0" title="0">writeJSON(w, http.StatusOK, sandboxToV1(sandbox))</span>
}

func (api *ControlAPI) handleSandboxLeaseRenew(w http.ResponseWriter, r *http.Request, vmid int) <span class="cov0" title="0">{
        if api.sandboxManager == nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "sandbox manager unavailable")
                return
        }</span>
        <span class="cov0" title="0">var req V1LeaseRenewRequest
        if err := decodeJSON(w, r, &amp;req); err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, err.Error())
                return
        }</span>
        <span class="cov0" title="0">if req.TTLMinutes &lt;= 0 </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "ttl_minutes must be positive")
                return
        }</span>
        <span class="cov0" title="0">lease, err := api.sandboxManager.RenewLease(r.Context(), vmid, time.Duration(req.TTLMinutes)*time.Minute)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, ErrSandboxNotFound):<span class="cov0" title="0">
                        writeError(w, http.StatusNotFound, "sandbox not found")</span>
                case errors.Is(err, ErrLeaseNotRenewable):<span class="cov0" title="0">
                        writeError(w, http.StatusConflict, "sandbox lease not renewable")</span>
                default:<span class="cov0" title="0">
                        writeError(w, http.StatusInternalServerError, "failed to renew lease")</span>
                }
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">writeJSON(w, http.StatusOK, V1LeaseRenewResponse{
                VMID:         vmid,
                LeaseExpires: lease.UTC().Format(time.RFC3339Nano),
        })</span>
}

func (api *ControlAPI) handleSandboxEvents(w http.ResponseWriter, r *http.Request, vmid int) <span class="cov0" title="0">{
        if api.store == nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "event store unavailable")
                return
        }</span>
        <span class="cov0" title="0">query := r.URL.Query()
        after, err := parseQueryInt64(query.Get("after"))
        if err != nil || after &lt; 0 </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "invalid after")
                return
        }</span>
        <span class="cov0" title="0">tail, err := parseQueryInt(query.Get("tail"))
        if err != nil || tail &lt; 0 </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "invalid tail")
                return
        }</span>
        <span class="cov0" title="0">limit, err := parseQueryInt(query.Get("limit"))
        if err != nil || limit &lt; 0 </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "invalid limit")
                return
        }</span>
        <span class="cov0" title="0">if tail &gt; 0 &amp;&amp; after &gt; 0 </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "tail and after are mutually exclusive")
                return
        }</span>
        <span class="cov0" title="0">if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = defaultEventsLimit
        }</span>
        <span class="cov0" title="0">if limit &gt; maxEventsLimit </span><span class="cov0" title="0">{
                limit = maxEventsLimit
        }</span>
        <span class="cov0" title="0">var events []db.Event
        if tail &gt; 0 </span><span class="cov0" title="0">{
                if tail &gt; maxEventsLimit </span><span class="cov0" title="0">{
                        tail = maxEventsLimit
                }</span>
                <span class="cov0" title="0">events, err = api.store.ListEventsBySandboxTail(r.Context(), vmid, tail)</span>
        } else<span class="cov0" title="0"> {
                events, err = api.store.ListEventsBySandbox(r.Context(), vmid, after, limit)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "failed to load events")
                return
        }</span>
        <span class="cov0" title="0">resp := V1EventsResponse{Events: make([]V1Event, 0, len(events))}
        var lastID int64
        for _, ev := range events </span><span class="cov0" title="0">{
                if ev.ID &gt; lastID </span><span class="cov0" title="0">{
                        lastID = ev.ID
                }</span>
                <span class="cov0" title="0">resp.Events = append(resp.Events, eventToV1(ev))</span>
        }
        <span class="cov0" title="0">if lastID &gt; 0 </span><span class="cov0" title="0">{
                resp.LastID = lastID
        }</span>
        <span class="cov0" title="0">writeJSON(w, http.StatusOK, resp)</span>
}

func (api *ControlAPI) profileExists(name string) bool <span class="cov3" title="2">{
        if name == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov3" title="2">if api.profiles == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov3" title="2">_, ok := api.profiles[name]
        return ok</span>
}

func (api *ControlAPI) profile(name string) (models.Profile, bool) <span class="cov3" title="2">{
        if name == "" </span><span class="cov0" title="0">{
                return models.Profile{}, false
        }</span>
        <span class="cov3" title="2">if api.profiles == nil </span><span class="cov0" title="0">{
                return models.Profile{}, false
        }</span>
        <span class="cov3" title="2">profile, ok := api.profiles[name]
        return profile, ok</span>
}

func jobToV1(job models.Job) V1JobResponse <span class="cov1" title="1">{
        resp := V1JobResponse{
                ID:        job.ID,
                RepoURL:   job.RepoURL,
                Ref:       job.Ref,
                Profile:   job.Profile,
                Task:      job.Task,
                Mode:      job.Mode,
                Keepalive: job.Keepalive,
                Status:    string(job.Status),
                CreatedAt: job.CreatedAt.UTC().Format(time.RFC3339Nano),
                UpdatedAt: job.UpdatedAt.UTC().Format(time.RFC3339Nano),
        }
        if job.TTLMinutes &gt; 0 </span><span class="cov1" title="1">{
                value := job.TTLMinutes
                resp.TTLMinutes = &amp;value
        }</span>
        <span class="cov1" title="1">if job.SandboxVMID != nil &amp;&amp; *job.SandboxVMID &gt; 0 </span><span class="cov0" title="0">{
                resp.SandboxVMID = job.SandboxVMID
        }</span>
        <span class="cov1" title="1">if job.ResultJSON != "" </span><span class="cov0" title="0">{
                resp.Result = json.RawMessage(job.ResultJSON)
        }</span>
        <span class="cov1" title="1">return resp</span>
}

func sandboxToV1(sb models.Sandbox) V1SandboxResponse <span class="cov1" title="1">{
        resp := V1SandboxResponse{
                VMID:          sb.VMID,
                Name:          sb.Name,
                Profile:       sb.Profile,
                State:         string(sb.State),
                IP:            sb.IP,
                WorkspaceID:   sb.WorkspaceID,
                Keepalive:     sb.Keepalive,
                CreatedAt:     sb.CreatedAt.UTC().Format(time.RFC3339Nano),
                LastUpdatedAt: sb.LastUpdatedAt.UTC().Format(time.RFC3339Nano),
        }
        if !sb.LeaseExpires.IsZero() </span><span class="cov1" title="1">{
                value := sb.LeaseExpires.UTC().Format(time.RFC3339Nano)
                resp.LeaseExpires = &amp;value
        }</span>
        <span class="cov1" title="1">return resp</span>
}

func workspaceToV1(ws models.Workspace) V1WorkspaceResponse <span class="cov0" title="0">{
        resp := V1WorkspaceResponse{
                ID:        ws.ID,
                Name:      ws.Name,
                Storage:   ws.Storage,
                VolumeID:  ws.VolumeID,
                SizeGB:    ws.SizeGB,
                CreatedAt: ws.CreatedAt.UTC().Format(time.RFC3339Nano),
                UpdatedAt: ws.LastUpdated.UTC().Format(time.RFC3339Nano),
        }
        if ws.AttachedVM != nil &amp;&amp; *ws.AttachedVM &gt; 0 </span><span class="cov0" title="0">{
                value := *ws.AttachedVM
                resp.AttachedVMID = &amp;value
        }</span>
        <span class="cov0" title="0">return resp</span>
}

func decodeJSON(w http.ResponseWriter, r *http.Request, dest any) error <span class="cov7" title="6">{
        if r.Body == nil </span><span class="cov0" title="0">{
                return errors.New("request body is required")
        }</span>
        <span class="cov7" title="6">defer r.Body.Close()
        r.Body = http.MaxBytesReader(w, r.Body, maxJSONBytes)
        dec := json.NewDecoder(r.Body)
        dec.DisallowUnknownFields()
        if err := dec.Decode(dest); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov7" title="6">if err := dec.Decode(&amp;struct{}{}); err != io.EOF </span><span class="cov0" title="0">{
                return errors.New("unexpected trailing data")
        }</span>
        <span class="cov7" title="6">return nil</span>
}

func writeJSON(w http.ResponseWriter, status int, payload any) <span class="cov10" title="12">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        _ = json.NewEncoder(w).Encode(payload)
}</span>

func writeError(w http.ResponseWriter, status int, msg string) <span class="cov8" title="7">{
        writeJSON(w, status, V1ErrorResponse{Error: msg})
}</span>

func writeMethodNotAllowed(w http.ResponseWriter, methods []string) <span class="cov0" title="0">{
        w.Header().Set("Allow", strings.Join(methods, ", "))
        writeError(w, http.StatusMethodNotAllowed, "method not allowed")
}</span>

func newJobID() (string, error) <span class="cov1" title="1">{
        buf := make([]byte, 8)
        if _, err := rand.Read(buf); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">return "job_" + hex.EncodeToString(buf), nil</span>
}

func derefInt(value *int) int <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return *value</span>
}

func isUniqueConstraint(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return strings.Contains(err.Error(), "UNIQUE constraint failed")</span>
}

func parseQueryInt(value string) (int, error) <span class="cov0" title="0">{
        if strings.TrimSpace(value) == "" </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        <span class="cov0" title="0">parsed, err := strconv.Atoi(value)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return parsed, nil</span>
}

func parseQueryInt64(value string) (int64, error) <span class="cov0" title="0">{
        if strings.TrimSpace(value) == "" </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        <span class="cov0" title="0">parsed, err := strconv.ParseInt(value, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return parsed, nil</span>
}

func eventToV1(ev db.Event) V1Event <span class="cov0" title="0">{
        resp := V1Event{
                ID:        ev.ID,
                Kind:      ev.Kind,
                Timestamp: ev.Timestamp.UTC().Format(time.RFC3339Nano),
                Message:   strings.TrimSpace(ev.Message),
        }
        if ev.SandboxVMID != nil </span><span class="cov0" title="0">{
                resp.SandboxVMID = ev.SandboxVMID
        }</span>
        <span class="cov0" title="0">if ev.JobID != nil </span><span class="cov0" title="0">{
                resp.JobID = *ev.JobID
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(ev.JSON) != "" </span><span class="cov0" title="0">{
                payload := []byte(ev.JSON)
                if !json.Valid(payload) </span><span class="cov0" title="0">{
                        payload, _ = json.Marshal(ev.JSON)
                }</span>
                <span class="cov0" title="0">resp.Payload = json.RawMessage(payload)</span>
        }
        <span class="cov0" title="0">if resp.Message == "" </span><span class="cov0" title="0">{
                resp.Message = ""
        }</span>
        <span class="cov0" title="0">return resp</span>
}

func artifactToV1(artifact db.Artifact) V1Artifact <span class="cov0" title="0">{
        resp := V1Artifact{
                Name:      artifact.Name,
                Path:      artifact.Path,
                SizeBytes: artifact.SizeBytes,
                Sha256:    artifact.Sha256,
                MIME:      artifact.MIME,
        }
        if !artifact.CreatedAt.IsZero() </span><span class="cov0" title="0">{
                resp.CreatedAt = artifact.CreatedAt.UTC().Format(time.RFC3339Nano)
        }</span>
        <span class="cov0" title="0">return resp</span>
}

func validateArtifactName(name string) error <span class="cov0" title="0">{
        name = strings.TrimSpace(name)
        if name == "" </span><span class="cov0" title="0">{
                return errors.New("artifact name is required")
        }</span>
        <span class="cov0" title="0">if strings.ContainsAny(name, "/\\") </span><span class="cov0" title="0">{
                return errors.New("artifact name must not contain path separators")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package daemon

import (
        "crypto/rand"
        "crypto/sha256"
        "database/sql"
        "encoding/hex"
        "errors"
        "fmt"
        "io"
        "net"
        "net/http"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/agentlab/agentlab/internal/db"
)

const (
        defaultArtifactName = "agentlab-artifacts.tar.gz"
)

// ArtifactAPI handles artifact uploads from guest runners.
type ArtifactAPI struct {
        store       *db.Store
        rootDir     string
        maxBytes    int64
        now         func() time.Time
        agentSubnet *net.IPNet
}

func NewArtifactAPI(store *db.Store, rootDir string, maxBytes int64, agentSubnet *net.IPNet) *ArtifactAPI <span class="cov10" title="4">{
        api := &amp;ArtifactAPI{
                store:       store,
                rootDir:     strings.TrimSpace(rootDir),
                maxBytes:    maxBytes,
                now:         time.Now,
                agentSubnet: agentSubnet,
        }
        return api
}</span>

func (api *ArtifactAPI) Register(mux *http.ServeMux) <span class="cov1" title="1">{
        if mux == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov1" title="1">mux.HandleFunc("/upload", api.handleUpload)</span>
}

func (api *ArtifactAPI) handleUpload(w http.ResponseWriter, r *http.Request) <span class="cov8" title="3">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                writeMethodNotAllowed(w, []string{http.MethodPost})
                return
        }</span>
        <span class="cov8" title="3">if api.store == nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusServiceUnavailable, "artifact service unavailable")
                return
        }</span>
        <span class="cov8" title="3">if !api.remoteAllowed(r.RemoteAddr) </span><span class="cov0" title="0">{
                writeError(w, http.StatusForbidden, "artifact access restricted to agent subnet")
                return
        }</span>
        <span class="cov8" title="3">token := bearerToken(r.Header.Get("Authorization"))
        if token == "" </span><span class="cov0" title="0">{
                writeError(w, http.StatusUnauthorized, "missing bearer token")
                return
        }</span>
        <span class="cov8" title="3">tokenHash, err := db.HashArtifactToken(token)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "invalid token")
                return
        }</span>
        <span class="cov8" title="3">record, err := api.store.GetArtifactToken(r.Context(), tokenHash)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        writeError(w, http.StatusForbidden, "invalid artifact token")
                        return
                }</span>
                <span class="cov0" title="0">writeError(w, http.StatusInternalServerError, "failed to validate artifact token")
                return</span>
        }
        <span class="cov8" title="3">now := api.now().UTC()
        if !record.ExpiresAt.IsZero() &amp;&amp; !record.ExpiresAt.After(now) </span><span class="cov0" title="0">{
                writeError(w, http.StatusForbidden, "artifact token expired")
                return
        }</span>
        <span class="cov8" title="3">jobID := strings.TrimSpace(record.JobID)
        if jobID == "" </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "artifact token missing job")
                return
        }</span>

        <span class="cov8" title="3">rawPath := strings.TrimSpace(r.URL.Query().Get("path"))
        if rawPath == "" </span><span class="cov5" title="2">{
                rawPath = defaultArtifactName
        }</span>
        <span class="cov8" title="3">relPath, err := sanitizeArtifactPath(rawPath)
        if err != nil </span><span class="cov1" title="1">{
                writeError(w, http.StatusBadRequest, err.Error())
                return
        }</span>
        <span class="cov5" title="2">jobDir, err := api.jobDir(jobID)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, err.Error())
                return
        }</span>
        <span class="cov5" title="2">targetPath, err := safeJoin(jobDir, relPath)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, err.Error())
                return
        }</span>
        <span class="cov5" title="2">if err := os.MkdirAll(filepath.Dir(targetPath), artifactDirPerms); err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "failed to create artifact directory")
                return
        }</span>

        <span class="cov5" title="2">maxBytes := api.maxBytes
        if maxBytes &lt;= 0 </span><span class="cov0" title="0">{
                maxBytes = 256 * 1024 * 1024
        }</span>
        <span class="cov5" title="2">if r.Body == nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "request body is required")
                return
        }</span>
        <span class="cov5" title="2">r.Body = http.MaxBytesReader(w, r.Body, maxBytes)
        defer r.Body.Close()

        tmpPath := targetPath + ".tmp-" + randomSuffix()
        file, err := os.OpenFile(tmpPath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0o640)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "failed to create artifact file")
                return
        }</span>
        <span class="cov5" title="2">defer func() </span><span class="cov5" title="2">{
                _ = file.Close()
        }</span>()

        <span class="cov5" title="2">hash := sha256.New()
        writer := io.MultiWriter(file, hash)

        var sniff [512]byte
        n, readErr := r.Body.Read(sniff[:])
        if readErr != nil &amp;&amp; !errors.Is(readErr, io.EOF) </span><span class="cov1" title="1">{
                handleUploadReadError(w, readErr)
                _ = os.Remove(tmpPath)
                return
        }</span>
        <span class="cov1" title="1">var size int64
        if n &gt; 0 </span><span class="cov1" title="1">{
                if _, err := writer.Write(sniff[:n]); err != nil </span><span class="cov0" title="0">{
                        writeError(w, http.StatusInternalServerError, "failed to write artifact")
                        _ = os.Remove(tmpPath)
                        return
                }</span>
                <span class="cov1" title="1">size += int64(n)</span>
        }

        <span class="cov1" title="1">copied, err := io.Copy(writer, r.Body)
        size += copied
        if err != nil </span><span class="cov0" title="0">{
                handleUploadReadError(w, err)
                _ = os.Remove(tmpPath)
                return
        }</span>
        <span class="cov1" title="1">if size == 0 </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "artifact body is empty")
                _ = os.Remove(tmpPath)
                return
        }</span>
        <span class="cov1" title="1">if err := file.Sync(); err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "failed to persist artifact")
                _ = os.Remove(tmpPath)
                return
        }</span>
        <span class="cov1" title="1">if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "failed to close artifact")
                _ = os.Remove(tmpPath)
                return
        }</span>
        <span class="cov1" title="1">if err := os.Rename(tmpPath, targetPath); err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "failed to finalize artifact")
                _ = os.Remove(tmpPath)
                return
        }</span>

        <span class="cov1" title="1">sha := hex.EncodeToString(hash.Sum(nil))
        mime := cleanContentType(r.Header.Get("Content-Type"))
        if mime == "" </span><span class="cov0" title="0">{
                mime = http.DetectContentType(sniff[:n])
        }</span>
        <span class="cov1" title="1">artifact := db.Artifact{
                JobID:     jobID,
                VMID:      record.VMID,
                Name:      filepath.Base(relPath),
                Path:      relPath,
                SizeBytes: size,
                Sha256:    sha,
                MIME:      mime,
                CreatedAt: now,
        }
        id, err := api.store.CreateArtifact(r.Context(), artifact)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "failed to record artifact")
                return
        }</span>
        <span class="cov1" title="1">artifact.ID = id

        if record.VMID != nil </span><span class="cov1" title="1">{
                _ = api.store.RecordEvent(r.Context(), "artifact.upload", record.VMID, &amp;jobID, fmt.Sprintf("artifact uploaded: %s", relPath), "")
        }</span>
        <span class="cov1" title="1">_ = api.store.TouchArtifactToken(r.Context(), record.TokenHash, now)

        resp := V1ArtifactUploadResponse{
                JobID: jobID,
                Artifact: V1ArtifactMetadata{
                        Name:      artifact.Name,
                        Path:      artifact.Path,
                        SizeBytes: artifact.SizeBytes,
                        Sha256:    artifact.Sha256,
                        MIME:      artifact.MIME,
                },
        }
        writeJSON(w, http.StatusCreated, resp)</span>
}

func (api *ArtifactAPI) jobDir(jobID string) (string, error) <span class="cov5" title="2">{
        jobID = strings.TrimSpace(jobID)
        if jobID == "" </span><span class="cov0" title="0">{
                return "", errors.New("job id is required")
        }</span>
        <span class="cov5" title="2">if strings.Contains(jobID, "/") || strings.Contains(jobID, string(filepath.Separator)) </span><span class="cov0" title="0">{
                return "", errors.New("job id contains invalid path characters")
        }</span>
        <span class="cov5" title="2">root := strings.TrimSpace(api.rootDir)
        if root == "" </span><span class="cov0" title="0">{
                return "", errors.New("artifact root is not configured")
        }</span>
        <span class="cov5" title="2">return filepath.Join(root, jobID), nil</span>
}

func (api *ArtifactAPI) remoteAllowed(addr string) bool <span class="cov8" title="3">{
        if api.agentSubnet == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="3">host, _, err := net.SplitHostPort(addr)
        if err != nil </span><span class="cov0" title="0">{
                host = addr
        }</span>
        <span class="cov8" title="3">host = strings.Trim(host, "[]")
        ip := net.ParseIP(host)
        if ip == nil || ip.IsUnspecified() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="3">return api.agentSubnet.Contains(ip)</span>
}

func sanitizeArtifactPath(raw string) (string, error) <span class="cov10" title="4">{
        raw = strings.TrimSpace(raw)
        if raw == "" </span><span class="cov0" title="0">{
                return "", errors.New("artifact path is required")
        }</span>
        <span class="cov10" title="4">if strings.ContainsRune(raw, 0) </span><span class="cov0" title="0">{
                return "", errors.New("artifact path contains invalid characters")
        }</span>
        <span class="cov10" title="4">raw = strings.ReplaceAll(raw, "\\", "/")
        cleaned := filepath.Clean(raw)
        if cleaned == "." || cleaned == "" </span><span class="cov0" title="0">{
                return "", errors.New("artifact path is required")
        }</span>
        <span class="cov10" title="4">if filepath.IsAbs(cleaned) </span><span class="cov0" title="0">{
                return "", errors.New("artifact path must be relative")
        }</span>
        <span class="cov10" title="4">if cleaned == ".." || strings.HasPrefix(cleaned, ".."+string(filepath.Separator)) || strings.HasPrefix(cleaned, "..") </span><span class="cov1" title="1">{
                return "", errors.New("artifact path must not traverse")
        }</span>
        <span class="cov8" title="3">return cleaned, nil</span>
}

func safeJoin(root, rel string) (string, error) <span class="cov8" title="3">{
        root = filepath.Clean(root)
        target := filepath.Join(root, rel)
        relPath, err := filepath.Rel(root, target)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.New("artifact path is invalid")
        }</span>
        <span class="cov8" title="3">if relPath == "." || strings.HasPrefix(relPath, "..") </span><span class="cov0" title="0">{
                return "", errors.New("artifact path must remain within job directory")
        }</span>
        <span class="cov8" title="3">return target, nil</span>
}

func bearerToken(header string) string <span class="cov8" title="3">{
        header = strings.TrimSpace(header)
        if header == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="3">lower := strings.ToLower(header)
        if !strings.HasPrefix(lower, "bearer ") </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="3">return strings.TrimSpace(header[len("bearer "):])</span>
}

func cleanContentType(value string) string <span class="cov1" title="1">{
        value = strings.TrimSpace(value)
        if value == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov1" title="1">if idx := strings.Index(value, ";"); idx &gt;= 0 </span><span class="cov0" title="0">{
                value = value[:idx]
        }</span>
        <span class="cov1" title="1">return strings.TrimSpace(value)</span>
}

func randomSuffix() string <span class="cov5" title="2">{
        buf := make([]byte, 6)
        if _, err := rand.Read(buf); err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d", time.Now().UnixNano())
        }</span>
        <span class="cov5" title="2">return hex.EncodeToString(buf)</span>
}

func handleUploadReadError(w http.ResponseWriter, err error) <span class="cov1" title="1">{
        var maxErr *http.MaxBytesError
        switch </span>{
        case errors.As(err, &amp;maxErr):<span class="cov1" title="1">
                writeError(w, http.StatusRequestEntityTooLarge, "artifact exceeds size limit")</span>
        case errors.Is(err, io.EOF):<span class="cov0" title="0">
                writeError(w, http.StatusBadRequest, "artifact body is empty")</span>
        default:<span class="cov0" title="0">
                writeError(w, http.StatusInternalServerError, "failed to read artifact")</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package daemon

import (
        "context"
        "errors"
        "fmt"
        "log"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/agentlab/agentlab/internal/db"
        "github.com/agentlab/agentlab/internal/models"
        "gopkg.in/yaml.v3"
)

const defaultArtifactGCInterval = 10 * time.Minute

type artifactRetentionResult struct {
        duration   time.Duration
        configured bool
        err        error
}

// ArtifactGC removes expired artifacts based on profile retention settings.
type ArtifactGC struct {
        store      *db.Store
        profiles   map[string]models.Profile
        rootDir    string
        logger     *log.Logger
        redactor   *Redactor
        now        func() time.Time
        gcInterval time.Duration
}

// NewArtifactGC constructs an artifact GC worker with defaults.
func NewArtifactGC(store *db.Store, profiles map[string]models.Profile, rootDir string, logger *log.Logger, redactor *Redactor) *ArtifactGC <span class="cov5" title="2">{
        if logger == nil </span><span class="cov0" title="0">{
                logger = log.Default()
        }</span>
        <span class="cov5" title="2">if redactor == nil </span><span class="cov0" title="0">{
                redactor = NewRedactor(nil)
        }</span>
        <span class="cov5" title="2">return &amp;ArtifactGC{
                store:      store,
                profiles:   profiles,
                rootDir:    strings.TrimSpace(rootDir),
                logger:     logger,
                redactor:   redactor,
                now:        time.Now,
                gcInterval: defaultArtifactGCInterval,
        }</span>
}

// Start runs the artifact GC immediately and on an interval until ctx is done.
func (g *ArtifactGC) Start(ctx context.Context) <span class="cov0" title="0">{
        if g == nil || g.store == nil || g.gcInterval &lt;= 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">g.run(ctx)
        ticker := time.NewTicker(g.gcInterval)
        go func() </span><span class="cov0" title="0">{
                defer ticker.Stop()
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                g.run(ctx)</span>
                        }
                }
        }()
}

func (g *ArtifactGC) run(ctx context.Context) <span class="cov1" title="1">{
        candidates, err := g.store.ListArtifactRetentionCandidates(ctx)
        if err != nil </span><span class="cov0" title="0">{
                g.logf("artifact GC list error: %v", err)
                return
        }</span>
        <span class="cov1" title="1">if len(candidates) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov1" title="1">retentionCache := make(map[string]artifactRetentionResult)
        now := g.now().UTC()
        deleted := 0
        for _, record := range candidates </span><span class="cov1" title="1">{
                retention, ok := g.retentionForProfile(record.JobProfile, retentionCache)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov1" title="1">if !isTerminalJobStatus(record.JobStatus) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov1" title="1">if record.SandboxState != "" &amp;&amp; record.SandboxState != models.SandboxDestroyed </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov1" title="1">base := record.JobUpdatedAt
                if base.IsZero() </span><span class="cov0" title="0">{
                        base = record.Artifact.CreatedAt
                }</span>
                <span class="cov1" title="1">if base.IsZero() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov1" title="1">if base.Add(retention).After(now) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov1" title="1">if err := g.deleteArtifact(ctx, record); err != nil </span><span class="cov0" title="0">{
                        g.logf("artifact GC delete job=%s artifact=%d: %v", record.Artifact.JobID, record.Artifact.ID, err)
                        continue</span>
                }
                <span class="cov1" title="1">deleted++</span>
        }
        <span class="cov1" title="1">if deleted &gt; 0 </span><span class="cov1" title="1">{
                g.logf("artifact GC removed %d artifacts", deleted)
        }</span>
}

func (g *ArtifactGC) retentionForProfile(profileName string, cache map[string]artifactRetentionResult) (time.Duration, bool) <span class="cov1" title="1">{
        profileName = strings.TrimSpace(profileName)
        if profileName == "" </span><span class="cov0" title="0">{
                return 0, false
        }</span>
        <span class="cov1" title="1">if cached, ok := cache[profileName]; ok </span><span class="cov0" title="0">{
                if cached.err != nil </span><span class="cov0" title="0">{
                        g.logf("artifact GC profile %s retention error: %v", profileName, cached.err)
                }</span>
                <span class="cov0" title="0">return cached.duration, cached.configured &amp;&amp; cached.duration &gt; 0</span>
        }
        <span class="cov1" title="1">result := artifactRetentionResult{}
        profile, ok := g.profiles[profileName]
        if !ok </span><span class="cov0" title="0">{
                result.err = fmt.Errorf("unknown profile %q", profileName)
                cache[profileName] = result
                g.logf("artifact GC profile %s retention error: %v", profileName, result.err)
                return 0, false
        }</span>
        <span class="cov1" title="1">duration, configured, err := parseArtifactRetention(profile.RawYAML)
        result.duration = duration
        result.configured = configured
        result.err = err
        cache[profileName] = result
        if err != nil </span><span class="cov0" title="0">{
                g.logf("artifact GC profile %s retention error: %v", profileName, err)
                return 0, false
        }</span>
        <span class="cov1" title="1">if !configured || duration &lt;= 0 </span><span class="cov0" title="0">{
                return 0, false
        }</span>
        <span class="cov1" title="1">return duration, true</span>
}

func (g *ArtifactGC) deleteArtifact(ctx context.Context, record db.ArtifactRetentionRecord) error <span class="cov1" title="1">{
        root := strings.TrimSpace(g.rootDir)
        if root == "" </span><span class="cov0" title="0">{
                return errors.New("artifact root is not configured")
        }</span>
        <span class="cov1" title="1">relPath, err := sanitizeArtifactPath(record.Artifact.Path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">jobDir := filepath.Join(root, record.Artifact.JobID)
        targetPath, err := safeJoin(jobDir, relPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if err := os.Remove(targetPath); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("remove artifact file: %w", err)
        }</span>
        <span class="cov1" title="1">if err := g.store.DeleteArtifact(ctx, record.Artifact.ID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">g.recordDeletionEvent(ctx, record)
        _ = os.Remove(jobDir)
        return nil</span>
}

func (g *ArtifactGC) recordDeletionEvent(ctx context.Context, record db.ArtifactRetentionRecord) <span class="cov1" title="1">{
        if g.store == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov1" title="1">name := strings.TrimSpace(record.Artifact.Name)
        if name == "" </span><span class="cov0" title="0">{
                name = filepath.Base(record.Artifact.Path)
        }</span>
        <span class="cov1" title="1">message := "artifact GC removed"
        if name != "" </span><span class="cov1" title="1">{
                message = fmt.Sprintf("artifact GC removed %s", name)
        }</span>
        <span class="cov1" title="1">jobID := strings.TrimSpace(record.Artifact.JobID)
        var jobIDPtr *string
        if jobID != "" </span><span class="cov1" title="1">{
                jobIDPtr = &amp;jobID
        }</span>
        <span class="cov1" title="1">_ = g.store.RecordEvent(ctx, "artifact.gc", record.SandboxVMID, jobIDPtr, message, "")</span>
}

func (g *ArtifactGC) logf(format string, args ...any) <span class="cov1" title="1">{
        if g == nil || g.logger == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov1" title="1">msg := fmt.Sprintf(format, args...)
        if g.redactor != nil </span><span class="cov1" title="1">{
                msg = g.redactor.Redact(msg)
        }</span>
        <span class="cov1" title="1">g.logger.Print(msg)</span>
}

type profileArtifactRetentionSpec struct {
        Artifacts profileArtifactRetentionConfig `yaml:"artifacts"`
}

type profileArtifactRetentionConfig struct {
        TTLMinutes       *int `yaml:"ttl_minutes"`
        RetentionMinutes *int `yaml:"retention_minutes"`
        RetentionHours   *int `yaml:"retention_hours"`
        RetentionDays    *int `yaml:"retention_days"`
}

func parseArtifactRetention(raw string) (time.Duration, bool, error) <span class="cov10" title="4">{
        raw = strings.TrimSpace(raw)
        if raw == "" </span><span class="cov1" title="1">{
                return 0, false, nil
        }</span>
        <span class="cov8" title="3">var spec profileArtifactRetentionSpec
        if err := yaml.Unmarshal([]byte(raw), &amp;spec); err != nil </span><span class="cov0" title="0">{
                return 0, false, err
        }</span>
        <span class="cov8" title="3">if spec.Artifacts.TTLMinutes != nil </span><span class="cov5" title="2">{
                return durationFromMinutes(*spec.Artifacts.TTLMinutes, "artifacts.ttl_minutes")
        }</span>
        <span class="cov1" title="1">if spec.Artifacts.RetentionMinutes != nil </span><span class="cov0" title="0">{
                return durationFromMinutes(*spec.Artifacts.RetentionMinutes, "artifacts.retention_minutes")
        }</span>
        <span class="cov1" title="1">if spec.Artifacts.RetentionHours != nil </span><span class="cov0" title="0">{
                return durationFromHours(*spec.Artifacts.RetentionHours, "artifacts.retention_hours")
        }</span>
        <span class="cov1" title="1">if spec.Artifacts.RetentionDays != nil </span><span class="cov1" title="1">{
                return durationFromDays(*spec.Artifacts.RetentionDays, "artifacts.retention_days")
        }</span>
        <span class="cov0" title="0">return 0, false, nil</span>
}

func durationFromMinutes(value int, field string) (time.Duration, bool, error) <span class="cov5" title="2">{
        if value &lt; 0 </span><span class="cov0" title="0">{
                return 0, true, fmt.Errorf("%s must be non-negative", field)
        }</span>
        <span class="cov5" title="2">if value == 0 </span><span class="cov0" title="0">{
                return 0, true, nil
        }</span>
        <span class="cov5" title="2">return time.Duration(value) * time.Minute, true, nil</span>
}

func durationFromHours(value int, field string) (time.Duration, bool, error) <span class="cov0" title="0">{
        if value &lt; 0 </span><span class="cov0" title="0">{
                return 0, true, fmt.Errorf("%s must be non-negative", field)
        }</span>
        <span class="cov0" title="0">if value == 0 </span><span class="cov0" title="0">{
                return 0, true, nil
        }</span>
        <span class="cov0" title="0">return time.Duration(value) * time.Hour, true, nil</span>
}

func durationFromDays(value int, field string) (time.Duration, bool, error) <span class="cov1" title="1">{
        if value &lt; 0 </span><span class="cov0" title="0">{
                return 0, true, fmt.Errorf("%s must be non-negative", field)
        }</span>
        <span class="cov1" title="1">if value == 0 </span><span class="cov0" title="0">{
                return 0, true, nil
        }</span>
        <span class="cov1" title="1">return time.Duration(value) * 24 * time.Hour, true, nil</span>
}

func isTerminalJobStatus(status models.JobStatus) bool <span class="cov1" title="1">{
        switch status </span>{
        case models.JobCompleted, models.JobFailed, models.JobTimeout:<span class="cov1" title="1">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package daemon

import (
        "context"
        "crypto/rand"
        "database/sql"
        "encoding/hex"
        "errors"
        "io"
        "net"
        "net/http"
        "strings"
        "time"

        "github.com/agentlab/agentlab/internal/db"
        "github.com/agentlab/agentlab/internal/models"
        "github.com/agentlab/agentlab/internal/secrets"
)

const (
        defaultAgentIPv4Mask     = 16
        defaultAgentIPv6Mask     = 64
        defaultArtifactTokenTTL  = 6 * time.Hour
        artifactTokenBytes       = 16
        maxArtifactTokenAttempts = 5
)

// BootstrapAPI serves guest bootstrap payloads on the agent subnet.
type BootstrapAPI struct {
        store            *db.Store
        profiles         map[string]models.Profile
        secretsStore     secrets.Store
        secretsBundle    string
        artifactEndpoint string
        artifactTokenTTL time.Duration
        now              func() time.Time
        rand             io.Reader
        agentSubnet      *net.IPNet
        redactor         *Redactor
}

func NewBootstrapAPI(store *db.Store, profiles map[string]models.Profile, secretsStore secrets.Store, secretsBundle string, agentSubnet *net.IPNet, artifactEndpoint string, artifactTokenTTL time.Duration, redactor *Redactor) *BootstrapAPI <span class="cov9" title="5">{
        bundle := strings.TrimSpace(secretsBundle)
        if bundle == "" </span><span class="cov0" title="0">{
                bundle = "default"
        }</span>
        <span class="cov9" title="5">if artifactTokenTTL &lt;= 0 </span><span class="cov0" title="0">{
                artifactTokenTTL = defaultArtifactTokenTTL
        }</span>
        <span class="cov9" title="5">if redactor == nil </span><span class="cov7" title="4">{
                redactor = NewRedactor(nil)
        }</span>
        <span class="cov9" title="5">api := &amp;BootstrapAPI{
                store:            store,
                profiles:         profiles,
                secretsStore:     secretsStore,
                secretsBundle:    bundle,
                artifactEndpoint: strings.TrimSpace(artifactEndpoint),
                artifactTokenTTL: artifactTokenTTL,
                now:              time.Now,
                rand:             rand.Reader,
                redactor:         redactor,
                agentSubnet:      agentSubnet,
        }
        return api</span>
}

func (api *BootstrapAPI) Register(mux *http.ServeMux) <span class="cov1" title="1">{
        if mux == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov1" title="1">mux.HandleFunc("/v1/bootstrap/fetch", api.handleBootstrapFetch)</span>
}

func (api *BootstrapAPI) handleBootstrapFetch(w http.ResponseWriter, r *http.Request) <span class="cov10" title="6">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                writeMethodNotAllowed(w, []string{http.MethodPost})
                return
        }</span>
        <span class="cov10" title="6">if !api.remoteAllowed(r.RemoteAddr) </span><span class="cov4" title="2">{
                writeError(w, http.StatusForbidden, "bootstrap access restricted to agent subnet")
                return
        }</span>
        <span class="cov7" title="4">var req V1BootstrapFetchRequest
        if err := decodeJSON(w, r, &amp;req); err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, err.Error())
                return
        }</span>
        <span class="cov7" title="4">req.Token = strings.TrimSpace(req.Token)
        if req.Token == "" </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "token is required")
                return
        }</span>
        <span class="cov7" title="4">if req.VMID &lt;= 0 </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "vmid must be positive")
                return
        }</span>
        <span class="cov7" title="4">if api.store == nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusServiceUnavailable, "bootstrap service unavailable")
                return
        }</span>
        <span class="cov7" title="4">job, err := api.store.GetJobBySandboxVMID(r.Context(), req.VMID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        writeError(w, http.StatusNotFound, "job not found")
                        return
                }</span>
                <span class="cov0" title="0">writeError(w, http.StatusInternalServerError, "failed to load job")
                return</span>
        }
        <span class="cov7" title="4">tokenHash, err := db.HashBootstrapToken(req.Token)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "invalid token")
                return
        }</span>
        <span class="cov7" title="4">valid, err := api.store.ValidateBootstrapToken(r.Context(), tokenHash, req.VMID, api.now().UTC())
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "failed to validate token")
                return
        }</span>
        <span class="cov7" title="4">if !valid </span><span class="cov1" title="1">{
                writeError(w, http.StatusForbidden, "invalid or expired bootstrap token")
                return
        }</span>
        <span class="cov6" title="3">bundle, err := api.secretsStore.Load(r.Context(), api.secretsBundle)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "failed to load secrets bundle")
                return
        }</span>
        <span class="cov6" title="3">if api.redactor != nil </span><span class="cov6" title="3">{
                api.redactor.AddKeys(envKeys(bundle.Env)...)
        }</span>
        <span class="cov6" title="3">claudeSettings, err := bundle.ClaudeSettingsJSON()
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "failed to encode claude settings")
                return
        }</span>

        <span class="cov6" title="3">resp := V1BootstrapFetchResponse{
                Job: bootstrapJobFromModel(job),
        }
        if git := bootstrapGitFromBundle(bundle); git != nil </span><span class="cov1" title="1">{
                resp.Git = git
        }</span>
        <span class="cov6" title="3">if len(bundle.Env) &gt; 0 </span><span class="cov6" title="3">{
                resp.Env = bundle.Env
        }</span>
        <span class="cov6" title="3">if claudeSettings != "" </span><span class="cov1" title="1">{
                resp.ClaudeSettingsJSON = claudeSettings
        }</span>
        <span class="cov6" title="3">if api.artifactEndpoint != "" </span><span class="cov6" title="3">{
                token, err := api.issueArtifactToken(r.Context(), job.ID, req.VMID)
                if err != nil </span><span class="cov1" title="1">{
                        writeError(w, http.StatusInternalServerError, "failed to issue artifact token")
                        return
                }</span>
                <span class="cov4" title="2">resp.Artifact = &amp;V1BootstrapArtifact{
                        Endpoint: api.artifactEndpoint,
                        Token:    token,
                }</span>
        } else<span class="cov0" title="0"> if artifact := bootstrapArtifactFromBundle(bundle); artifact != nil </span><span class="cov0" title="0">{
                resp.Artifact = artifact
        }</span>
        <span class="cov4" title="2">var profile *models.Profile
        if api.profiles != nil </span><span class="cov1" title="1">{
                if stored, ok := api.profiles[job.Profile]; ok </span><span class="cov1" title="1">{
                        profile = &amp;stored
                }</span>
        }
        <span class="cov4" title="2">policy, err := bootstrapPolicyFromJobAndProfile(job, profile)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "invalid profile behavior policy")
                return
        }</span>
        <span class="cov4" title="2">if policy != nil </span><span class="cov4" title="2">{
                resp.Policy = policy
        }</span>

        <span class="cov4" title="2">consumed, err := api.store.ConsumeBootstrapToken(r.Context(), tokenHash, req.VMID, api.now().UTC())
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "failed to consume token")
                return
        }</span>
        <span class="cov4" title="2">if !consumed </span><span class="cov0" title="0">{
                writeError(w, http.StatusForbidden, "invalid or expired bootstrap token")
                return
        }</span>

        <span class="cov4" title="2">writeJSON(w, http.StatusOK, resp)</span>
}

func (api *BootstrapAPI) remoteAllowed(addr string) bool <span class="cov10" title="6">{
        if api.agentSubnet == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov10" title="6">host, _, err := net.SplitHostPort(addr)
        if err != nil </span><span class="cov0" title="0">{
                host = addr
        }</span>
        <span class="cov10" title="6">host = strings.Trim(host, "[]")
        ip := net.ParseIP(host)
        if ip == nil || ip.IsUnspecified() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov10" title="6">return api.agentSubnet.Contains(ip)</span>
}

func deriveAgentSubnet(listen string) *net.IPNet <span class="cov0" title="0">{
        listen = strings.TrimSpace(listen)
        if listen == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">host, _, err := net.SplitHostPort(listen)
        if err != nil </span><span class="cov0" title="0">{
                host = listen
        }</span>
        <span class="cov0" title="0">host = strings.Trim(host, "[]")
        ip := net.ParseIP(host)
        if ip == nil || ip.IsUnspecified() </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if ip4 := ip.To4(); ip4 != nil </span><span class="cov0" title="0">{
                mask := net.CIDRMask(defaultAgentIPv4Mask, 32)
                base := ip4.Mask(mask)
                return &amp;net.IPNet{IP: base, Mask: mask}
        }</span>
        <span class="cov0" title="0">mask := net.CIDRMask(defaultAgentIPv6Mask, 128)
        base := ip.Mask(mask)
        return &amp;net.IPNet{IP: base, Mask: mask}</span>
}

func bootstrapJobFromModel(job models.Job) V1BootstrapJob <span class="cov6" title="3">{
        mode := strings.TrimSpace(job.Mode)
        if mode == "" </span><span class="cov0" title="0">{
                mode = defaultJobMode
        }</span>
        <span class="cov6" title="3">resp := V1BootstrapJob{
                ID:        job.ID,
                RepoURL:   job.RepoURL,
                Ref:       job.Ref,
                Task:      job.Task,
                Mode:      mode,
                Profile:   job.Profile,
                Keepalive: job.Keepalive,
        }
        if job.TTLMinutes &gt; 0 </span><span class="cov0" title="0">{
                value := job.TTLMinutes
                resp.TTLMinutes = &amp;value
        }</span>
        <span class="cov6" title="3">return resp</span>
}

func bootstrapPolicyFromJobAndProfile(job models.Job, profile *models.Profile) (*V1BootstrapPolicy, error) <span class="cov4" title="2">{
        mode := strings.TrimSpace(job.Mode)
        if mode == "" </span><span class="cov0" title="0">{
                mode = defaultJobMode
        }</span>
        <span class="cov4" title="2">var policy V1BootstrapPolicy
        hasPolicy := false
        if mode != "" </span><span class="cov4" title="2">{
                policy.Mode = mode
                hasPolicy = true
        }</span>
        <span class="cov4" title="2">if profile != nil </span><span class="cov1" title="1">{
                cfg, err := parseProfileInnerSandbox(profile.RawYAML)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">if cfg.Name != "" </span><span class="cov1" title="1">{
                        policy.InnerSandbox = cfg.Name
                        if len(cfg.Args) &gt; 0 </span><span class="cov1" title="1">{
                                policy.InnerSandboxArgs = cfg.Args
                        }</span>
                        <span class="cov1" title="1">hasPolicy = true</span>
                }
        }
        <span class="cov4" title="2">if !hasPolicy </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov4" title="2">return &amp;policy, nil</span>
}

func bootstrapGitFromBundle(bundle secrets.Bundle) *V1BootstrapGit <span class="cov6" title="3">{
        git := bundle.Git
        if strings.TrimSpace(git.Token) == "" &amp;&amp;
                strings.TrimSpace(git.Username) == "" &amp;&amp;
                strings.TrimSpace(git.SSHPrivateKey) == "" &amp;&amp;
                strings.TrimSpace(git.SSHPublicKey) == "" &amp;&amp;
                strings.TrimSpace(git.KnownHosts) == "" </span><span class="cov4" title="2">{
                return nil
        }</span>
        <span class="cov1" title="1">return &amp;V1BootstrapGit{
                Token:         git.Token,
                Username:      git.Username,
                SSHPrivateKey: git.SSHPrivateKey,
                SSHPublicKey:  git.SSHPublicKey,
                KnownHosts:    git.KnownHosts,
        }</span>
}

func bootstrapArtifactFromBundle(bundle secrets.Bundle) *V1BootstrapArtifact <span class="cov0" title="0">{
        artifact := bundle.Artifact
        if strings.TrimSpace(artifact.Endpoint) == "" &amp;&amp; strings.TrimSpace(artifact.Token) == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;V1BootstrapArtifact{
                Endpoint: artifact.Endpoint,
                Token:    artifact.Token,
        }</span>
}

func (api *BootstrapAPI) issueArtifactToken(ctx context.Context, jobID string, vmid int) (string, error) <span class="cov6" title="3">{
        if api == nil || api.store == nil </span><span class="cov0" title="0">{
                return "", errors.New("artifact token store unavailable")
        }</span>
        <span class="cov6" title="3">jobID = strings.TrimSpace(jobID)
        if jobID == "" </span><span class="cov0" title="0">{
                return "", errors.New("job id is required")
        }</span>
        <span class="cov6" title="3">if vmid &lt;= 0 </span><span class="cov0" title="0">{
                return "", errors.New("vmid must be positive")
        }</span>
        <span class="cov6" title="3">for i := 0; i &lt; maxArtifactTokenAttempts; i++ </span><span class="cov6" title="3">{
                token, hash, expires, err := api.newArtifactToken()
                if err != nil </span><span class="cov1" title="1">{
                        return "", err
                }</span>
                <span class="cov4" title="2">if err := api.store.CreateArtifactToken(ctx, hash, jobID, vmid, expires); err != nil </span><span class="cov0" title="0">{
                        if isUniqueConstraint(err) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">return "", err</span>
                }
                <span class="cov4" title="2">if api.redactor != nil </span><span class="cov4" title="2">{
                        api.redactor.AddValues(token)
                }</span>
                <span class="cov4" title="2">return token, nil</span>
        }
        <span class="cov0" title="0">return "", errors.New("failed to allocate artifact token")</span>
}

func (api *BootstrapAPI) newArtifactToken() (string, string, time.Time, error) <span class="cov6" title="3">{
        buf := make([]byte, artifactTokenBytes)
        if _, err := io.ReadFull(api.randReader(), buf); err != nil </span><span class="cov1" title="1">{
                return "", "", time.Time{}, err
        }</span>
        <span class="cov4" title="2">token := hex.EncodeToString(buf)
        hash, err := db.HashArtifactToken(token)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", time.Time{}, err
        }</span>
        <span class="cov4" title="2">expires := api.now().UTC().Add(api.artifactTokenTTL)
        return token, hash, expires, nil</span>
}

func (api *BootstrapAPI) randReader() io.Reader <span class="cov6" title="3">{
        if api != nil &amp;&amp; api.rand != nil </span><span class="cov6" title="3">{
                return api.rand
        }</span>
        <span class="cov0" title="0">return rand.Reader</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package daemon

import (
        "context"
        "errors"
        "fmt"
        "log"
        "net"
        "net/http"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/agentlab/agentlab/internal/config"
        "github.com/agentlab/agentlab/internal/db"
        "github.com/agentlab/agentlab/internal/models"
        "github.com/agentlab/agentlab/internal/proxmox"
        "github.com/agentlab/agentlab/internal/secrets"
)

const (
        shutdownTimeout  = 5 * time.Second
        socketPerms      = 0o660
        runDirPerms      = 0o750
        artifactDirPerms = 0o750
)

// Service wires listeners for the local control socket and guest bootstrap.
type Service struct {
        cfg               config.Config
        profiles          map[string]models.Profile
        store             *db.Store
        unixListener      net.Listener
        bootstrapListener net.Listener
        artifactListener  net.Listener
        metricsListener   net.Listener
        unixServer        *http.Server
        bootstrapServer   *http.Server
        artifactServer    *http.Server
        metricsServer     *http.Server
        sandboxManager    *SandboxManager
        workspaceManager  *WorkspaceManager
        artifactGC        *ArtifactGC
        metrics           *Metrics
}

// Run loads profiles, binds listeners, and serves until ctx is canceled.
func Run(ctx context.Context, cfg config.Config) error <span class="cov0" title="0">{
        if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">profiles, err := LoadProfiles(cfg.ProfilesDir)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">store, err := db.Open(cfg.DBPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">service, err := NewService(cfg, profiles, store)
        if err != nil </span><span class="cov0" title="0">{
                _ = store.Close()
                return err
        }</span>
        <span class="cov0" title="0">log.Printf("agentlabd: loaded %d profiles from %s", len(profiles), cfg.ProfilesDir)
        return service.Serve(ctx)</span>
}

// NewService constructs a service with bound listeners.
func NewService(cfg config.Config, profiles map[string]models.Profile, store *db.Store) (*Service, error) <span class="cov1" title="1">{
        if err := ensureDir(cfg.RunDir, runDirPerms); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">if err := ensureDir(cfg.ArtifactDir, artifactDirPerms); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">agentSubnet, err := resolveAgentSubnet(cfg.AgentSubnet, cfg.BootstrapListen)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">agentCIDR := ""
        if agentSubnet != nil </span><span class="cov1" title="1">{
                agentCIDR = agentSubnet.String()
        }</span>
        <span class="cov1" title="1">var metrics *Metrics
        if strings.TrimSpace(cfg.MetricsListen) != "" </span><span class="cov0" title="0">{
                metrics = NewMetrics()
        }</span>
        <span class="cov1" title="1">unixListener, err := listenUnix(cfg.SocketPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">bootstrapListener, err := net.Listen("tcp", cfg.BootstrapListen)
        if err != nil </span><span class="cov0" title="0">{
                _ = unixListener.Close()
                return nil, fmt.Errorf("listen bootstrap %s: %w", cfg.BootstrapListen, err)
        }</span>
        <span class="cov1" title="1">artifactListener, err := net.Listen("tcp", cfg.ArtifactListen)
        if err != nil </span><span class="cov0" title="0">{
                _ = bootstrapListener.Close()
                _ = unixListener.Close()
                return nil, fmt.Errorf("listen artifact %s: %w", cfg.ArtifactListen, err)
        }</span>
        <span class="cov1" title="1">var metricsListener net.Listener
        if metrics != nil </span><span class="cov0" title="0">{
                metricsListener, err = net.Listen("tcp", cfg.MetricsListen)
                if err != nil </span><span class="cov0" title="0">{
                        _ = artifactListener.Close()
                        _ = bootstrapListener.Close()
                        _ = unixListener.Close()
                        return nil, fmt.Errorf("listen metrics %s: %w", cfg.MetricsListen, err)
                }</span>
        }

        <span class="cov1" title="1">backend := &amp;proxmox.ShellBackend{
                CommandTimeout: cfg.ProxmoxCommandTimeout,
                AgentCIDR:      agentCIDR,
        }
        workspaceManager := NewWorkspaceManager(store, backend, log.Default())
        sandboxManager := NewSandboxManager(store, backend, log.Default()).WithWorkspaceManager(workspaceManager).WithMetrics(metrics)
        redactor := NewRedactor(nil)
        snippetStore := proxmox.SnippetStore{
                Storage: cfg.SnippetStorage,
                Dir:     cfg.SnippetsDir,
        }
        controllerURL := strings.TrimSpace(cfg.ControllerURL)
        if controllerURL == "" </span><span class="cov1" title="1">{
                controllerURL = buildControllerURL(cfg.BootstrapListen)
        }</span>
        <span class="cov1" title="1">var jobOrchestrator *JobOrchestrator
        if strings.TrimSpace(cfg.SSHPublicKey) != "" </span><span class="cov0" title="0">{
                jobOrchestrator = NewJobOrchestrator(store, profiles, backend, sandboxManager, workspaceManager, snippetStore, cfg.SSHPublicKey, controllerURL, log.Default(), redactor, metrics).
                        WithProvisionTimeout(cfg.ProvisioningTimeout)
        }</span> else<span class="cov1" title="1"> {
                log.Printf("agentlabd: ssh public key missing; job orchestration disabled")
        }</span>
        <span class="cov1" title="1">if jobOrchestrator != nil </span><span class="cov0" title="0">{
                sandboxManager.WithSnippetCleaner(jobOrchestrator.CleanupSnippet)
        }</span>

        <span class="cov1" title="1">localMux := http.NewServeMux()
        localMux.HandleFunc("/healthz", healthHandler)
        NewControlAPI(store, profiles, sandboxManager, workspaceManager, jobOrchestrator, cfg.ArtifactDir).Register(localMux)

        bootstrapMux := http.NewServeMux()
        bootstrapMux.HandleFunc("/healthz", healthHandler)
        secretsStore := secrets.Store{
                Dir:        cfg.SecretsDir,
                AgeKeyPath: cfg.SecretsAgeKeyPath,
                SopsPath:   cfg.SecretsSopsPath,
        }
        artifactEndpoint := strings.TrimSpace(cfg.ArtifactUploadURL)
        if artifactEndpoint == "" </span><span class="cov1" title="1">{
                artifactEndpoint = buildArtifactUploadURL(cfg.ArtifactListen)
        }</span>
        <span class="cov1" title="1">NewBootstrapAPI(store, profiles, secretsStore, cfg.SecretsBundle, agentSubnet, artifactEndpoint, time.Duration(cfg.ArtifactTokenTTLMinutes)*time.Minute, redactor).Register(bootstrapMux)
        NewRunnerAPI(jobOrchestrator, agentSubnet).Register(bootstrapMux)

        artifactMux := http.NewServeMux()
        artifactMux.HandleFunc("/healthz", healthHandler)
        NewArtifactAPI(store, cfg.ArtifactDir, cfg.ArtifactMaxBytes, agentSubnet).Register(artifactMux)

        artifactGC := NewArtifactGC(store, profiles, cfg.ArtifactDir, log.Default(), redactor)

        unixServer := &amp;http.Server{
                Handler:           localMux,
                ReadHeaderTimeout: 5 * time.Second,
                IdleTimeout:       2 * time.Minute,
        }
        bootstrapServer := &amp;http.Server{
                Handler:           bootstrapMux,
                ReadHeaderTimeout: 5 * time.Second,
                IdleTimeout:       2 * time.Minute,
        }
        artifactServer := &amp;http.Server{
                Handler:           artifactMux,
                ReadHeaderTimeout: 5 * time.Second,
                IdleTimeout:       2 * time.Minute,
        }
        var metricsServer *http.Server
        if metrics != nil </span><span class="cov0" title="0">{
                metricsMux := http.NewServeMux()
                metricsMux.Handle("/metrics", metrics.Handler())
                metricsMux.HandleFunc("/healthz", healthHandler)
                metricsServer = &amp;http.Server{
                        Handler:           metricsMux,
                        ReadHeaderTimeout: 5 * time.Second,
                        IdleTimeout:       2 * time.Minute,
                }
        }</span>

        <span class="cov1" title="1">return &amp;Service{
                cfg:               cfg,
                profiles:          profiles,
                store:             store,
                unixListener:      unixListener,
                bootstrapListener: bootstrapListener,
                artifactListener:  artifactListener,
                metricsListener:   metricsListener,
                unixServer:        unixServer,
                bootstrapServer:   bootstrapServer,
                artifactServer:    artifactServer,
                metricsServer:     metricsServer,
                sandboxManager:    sandboxManager,
                workspaceManager:  workspaceManager,
                artifactGC:        artifactGC,
                metrics:           metrics,
        }, nil</span>
}

// Serve blocks until shutdown or a listener error occurs.
func (s *Service) Serve(ctx context.Context) error <span class="cov0" title="0">{
        serverCount := 3
        if s.metricsServer != nil </span><span class="cov0" title="0">{
                serverCount++
        }</span>
        <span class="cov0" title="0">log.Printf("agentlabd: listening on unix=%s", s.cfg.SocketPath)
        log.Printf("agentlabd: listening on bootstrap=%s", s.cfg.BootstrapListen)
        log.Printf("agentlabd: listening on artifacts=%s", s.cfg.ArtifactListen)
        if s.metricsServer != nil </span><span class="cov0" title="0">{
                log.Printf("agentlabd: listening on metrics=%s", s.cfg.MetricsListen)
        }</span>
        <span class="cov0" title="0">if s.sandboxManager != nil </span><span class="cov0" title="0">{
                s.sandboxManager.StartLeaseGC(ctx)
        }</span>
        <span class="cov0" title="0">if s.artifactGC != nil </span><span class="cov0" title="0">{
                s.artifactGC.Start(ctx)
        }</span>

        <span class="cov0" title="0">errCh := make(chan error, serverCount)
        go func() </span><span class="cov0" title="0">{ errCh &lt;- s.unixServer.Serve(s.unixListener) }</span>()
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{ errCh &lt;- s.bootstrapServer.Serve(s.bootstrapListener) }</span>()
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{ errCh &lt;- s.artifactServer.Serve(s.artifactListener) }</span>()
        <span class="cov0" title="0">if s.metricsServer != nil </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{ errCh &lt;- s.metricsServer.Serve(s.metricsListener) }</span>()
        }

        <span class="cov0" title="0">remaining := serverCount
        var serveErr error

        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                // graceful shutdown
        case err := &lt;-errCh:<span class="cov0" title="0">
                remaining = serverCount - 1
                if err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        serveErr = err
                }</span>
        }

        <span class="cov0" title="0">s.shutdown()
        for i := 0; i &lt; remaining; i++ </span><span class="cov0" title="0">{
                err := &lt;-errCh
                if err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) &amp;&amp; serveErr == nil </span><span class="cov0" title="0">{
                        serveErr = err
                }</span>
        }

        <span class="cov0" title="0">_ = os.Remove(s.cfg.SocketPath)
        return serveErr</span>
}

func (s *Service) shutdown() <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), shutdownTimeout)
        defer cancel()
        _ = s.unixServer.Shutdown(ctx)
        _ = s.bootstrapServer.Shutdown(ctx)
        _ = s.artifactServer.Shutdown(ctx)
        if s.metricsServer != nil </span><span class="cov0" title="0">{
                _ = s.metricsServer.Shutdown(ctx)
        }</span>
        <span class="cov0" title="0">if s.store != nil </span><span class="cov0" title="0">{
                _ = s.store.Close()
        }</span>
}

func ensureDir(path string, perms os.FileMode) error <span class="cov10" title="2">{
        if path == "" </span><span class="cov0" title="0">{
                return errors.New("run_dir is required")
        }</span>
        <span class="cov10" title="2">if err := os.MkdirAll(path, perms); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create dir %s: %w", path, err)
        }</span>
        <span class="cov10" title="2">return nil</span>
}

func listenUnix(socketPath string) (net.Listener, error) <span class="cov1" title="1">{
        if socketPath == "" </span><span class="cov0" title="0">{
                return nil, errors.New("socket_path is required")
        }</span>
        <span class="cov1" title="1">if err := os.MkdirAll(filepath.Dir(socketPath), runDirPerms); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create socket dir %s: %w", filepath.Dir(socketPath), err)
        }</span>
        <span class="cov1" title="1">if err := os.Remove(socketPath); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("remove stale socket %s: %w", socketPath, err)
        }</span>
        <span class="cov1" title="1">listener, err := net.Listen("unix", socketPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("listen unix %s: %w", socketPath, err)
        }</span>
        <span class="cov1" title="1">if err := os.Chmod(socketPath, socketPerms); err != nil </span><span class="cov0" title="0">{
                _ = listener.Close()
                return nil, fmt.Errorf("chmod socket %s: %w", socketPath, err)
        }</span>
        <span class="cov1" title="1">return listener, nil</span>
}

func healthHandler(w http.ResponseWriter, _ *http.Request) <span class="cov0" title="0">{
        w.WriteHeader(http.StatusOK)
        _, _ = w.Write([]byte("ok"))
}</span>

func buildControllerURL(listen string) string <span class="cov1" title="1">{
        host, port, err := net.SplitHostPort(listen)
        if err != nil </span><span class="cov0" title="0">{
                return "http://" + listen
        }</span>
        <span class="cov1" title="1">if strings.Contains(host, ":") </span><span class="cov0" title="0">{
                host = "[" + host + "]"
        }</span>
        <span class="cov1" title="1">return "http://" + host + ":" + port</span>
}

func buildArtifactUploadURL(listen string) string <span class="cov1" title="1">{
        listen = strings.TrimSpace(listen)
        if listen == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov1" title="1">host, port, err := net.SplitHostPort(listen)
        if err != nil </span><span class="cov0" title="0">{
                return "http://" + listen + "/upload"
        }</span>
        <span class="cov1" title="1">if strings.Contains(host, ":") </span><span class="cov0" title="0">{
                host = "[" + host + "]"
        }</span>
        <span class="cov1" title="1">return "http://" + host + ":" + port + "/upload"</span>
}

func resolveAgentSubnet(agentSubnet, listen string) (*net.IPNet, error) <span class="cov1" title="1">{
        agentSubnet = strings.TrimSpace(agentSubnet)
        if agentSubnet == "" </span><span class="cov0" title="0">{
                return deriveAgentSubnet(listen), nil
        }</span>
        <span class="cov1" title="1">_, subnet, err := net.ParseCIDR(agentSubnet)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("agent_subnet must be CIDR: %w", err)
        }</span>
        <span class="cov1" title="1">return subnet, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package daemon

import (
        "context"
        "crypto/rand"
        "database/sql"
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "log"
        "strings"
        "sync"
        "time"

        "github.com/agentlab/agentlab/internal/db"
        "github.com/agentlab/agentlab/internal/models"
        "github.com/agentlab/agentlab/internal/proxmox"
)

const (
        defaultBootstrapTTL     = 10 * time.Minute
        bootstrapTokenBytes     = 16
        defaultProvisionTimeout = 10 * time.Minute
        defaultFailureTimeout   = 30 * time.Second
)

var (
        ErrJobNotFound        = errors.New("job not found")
        ErrJobSandboxMismatch = errors.New("job sandbox mismatch")
        ErrJobFinalized       = errors.New("job already finalized")
)

type JobReport struct {
        JobID     string
        VMID      int
        Status    models.JobStatus
        Message   string
        Artifacts []V1ArtifactMetadata
        Result    json.RawMessage
}

type JobOrchestrator struct {
        store            *db.Store
        profiles         map[string]models.Profile
        backend          proxmox.Backend
        sandboxManager   *SandboxManager
        workspaceMgr     *WorkspaceManager
        snippetStore     proxmox.SnippetStore
        sshPublicKey     string
        controllerURL    string
        logger           *log.Logger
        redactor         *Redactor
        metrics          *Metrics
        now              func() time.Time
        rand             io.Reader
        bootstrapTTL     time.Duration
        provisionTimeout time.Duration
        failureTimeout   time.Duration
        snippetsMu       sync.Mutex
        snippets         map[int]proxmox.CloudInitSnippet
}

func NewJobOrchestrator(store *db.Store, profiles map[string]models.Profile, backend proxmox.Backend, manager *SandboxManager, workspaceMgr *WorkspaceManager, snippetStore proxmox.SnippetStore, sshPublicKey, controllerURL string, logger *log.Logger, redactor *Redactor, metrics *Metrics) *JobOrchestrator <span class="cov10" title="9">{
        if logger == nil </span><span class="cov0" title="0">{
                logger = log.Default()
        }</span>
        <span class="cov10" title="9">if redactor == nil </span><span class="cov10" title="9">{
                redactor = NewRedactor(nil)
        }</span>
        <span class="cov10" title="9">return &amp;JobOrchestrator{
                store:            store,
                profiles:         profiles,
                backend:          backend,
                sandboxManager:   manager,
                workspaceMgr:     workspaceMgr,
                snippetStore:     snippetStore,
                sshPublicKey:     strings.TrimSpace(sshPublicKey),
                controllerURL:    strings.TrimSpace(controllerURL),
                logger:           logger,
                redactor:         redactor,
                metrics:          metrics,
                now:              time.Now,
                rand:             rand.Reader,
                bootstrapTTL:     defaultBootstrapTTL,
                provisionTimeout: defaultProvisionTimeout,
                failureTimeout:   defaultFailureTimeout,
                snippets:         make(map[int]proxmox.CloudInitSnippet),
        }</span>
}

func (o *JobOrchestrator) Start(jobID string) <span class="cov1" title="1">{
        if o == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov1" title="1">go func() </span><span class="cov1" title="1">{
                if err := o.Run(context.Background(), jobID); err != nil &amp;&amp; o.logger != nil </span><span class="cov0" title="0">{
                        msg := err.Error()
                        if o.redactor != nil </span><span class="cov0" title="0">{
                                msg = o.redactor.Redact(msg)
                        }</span>
                        <span class="cov0" title="0">o.logger.Printf("job orchestration %s: %s", jobID, msg)</span>
                }
        }()
}

func (o *JobOrchestrator) Run(ctx context.Context, jobID string) error <span class="cov6" title="4">{
        if o == nil || o.store == nil </span><span class="cov1" title="1">{
                return errors.New("job orchestrator unavailable")
        }</span>
        <span class="cov5" title="3">ctx, cancel := o.withProvisionTimeout(ctx)
        defer cancel()
        if jobID == "" </span><span class="cov0" title="0">{
                return errors.New("job id is required")
        }</span>
        <span class="cov5" title="3">job, err := o.store.GetJob(ctx, jobID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return ErrJobNotFound
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov5" title="3">if job.Status != models.JobQueued </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov5" title="3">profile, ok := o.profile(job.Profile)
        if !ok </span><span class="cov0" title="0">{
                return o.failJob(job, 0, fmt.Errorf("unknown profile %q", job.Profile))
        }</span>
        <span class="cov5" title="3">if err := validateProfileForProvisioning(profile); err != nil </span><span class="cov1" title="1">{
                return o.failJob(job, 0, err)
        }</span>
        <span class="cov3" title="2">if o.sandboxManager == nil </span><span class="cov0" title="0">{
                return o.failJob(job, 0, errors.New("sandbox manager unavailable"))
        }</span>
        <span class="cov3" title="2">if o.backend == nil </span><span class="cov0" title="0">{
                return o.failJob(job, 0, errors.New("proxmox backend unavailable"))
        }</span>
        <span class="cov3" title="2">if o.sshPublicKey == "" </span><span class="cov0" title="0">{
                return o.failJob(job, 0, errors.New("ssh public key unavailable"))
        }</span>
        <span class="cov3" title="2">if o.controllerURL == "" </span><span class="cov0" title="0">{
                return o.failJob(job, 0, errors.New("controller URL unavailable"))
        }</span>

        <span class="cov3" title="2">sandbox, created, err := o.ensureSandbox(ctx, job)
        if err != nil </span><span class="cov0" title="0">{
                return o.failJob(job, 0, err)
        }</span>
        <span class="cov3" title="2">if created </span><span class="cov3" title="2">{
                if _, err := o.store.UpdateJobSandbox(ctx, job.ID, sandbox.VMID); err != nil </span><span class="cov0" title="0">{
                        return o.failJob(job, sandbox.VMID, err)
                }</span>
        }

        <span class="cov3" title="2">if err := o.sandboxManager.Transition(ctx, sandbox.VMID, models.SandboxProvisioning); err != nil </span><span class="cov0" title="0">{
                return o.failJob(job, sandbox.VMID, err)
        }</span>

        <span class="cov3" title="2">if err := o.backend.Clone(ctx, proxmox.VMID(profile.TemplateVM), proxmox.VMID(sandbox.VMID), sandbox.Name); err != nil </span><span class="cov0" title="0">{
                return o.failJob(job, sandbox.VMID, err)
        }</span>

        <span class="cov3" title="2">token, tokenHash, expiresAt, err := o.bootstrapToken()
        if err != nil </span><span class="cov0" title="0">{
                return o.failJob(job, sandbox.VMID, err)
        }</span>
        <span class="cov3" title="2">if err := o.store.CreateBootstrapToken(ctx, tokenHash, sandbox.VMID, expiresAt); err != nil </span><span class="cov0" title="0">{
                return o.failJob(job, sandbox.VMID, err)
        }</span>

        <span class="cov3" title="2">snippet, err := o.snippetStore.Create(proxmox.SnippetInput{
                VMID:           proxmox.VMID(sandbox.VMID),
                Hostname:       sandbox.Name,
                SSHPublicKey:   o.sshPublicKey,
                BootstrapToken: token,
                ControllerURL:  o.controllerURL,
        })
        if err != nil </span><span class="cov0" title="0">{
                return o.failJob(job, sandbox.VMID, err)
        }</span>
        <span class="cov3" title="2">o.rememberSnippet(snippet)

        cfg := proxmox.VMConfig{
                Name:      sandbox.Name,
                CloudInit: snippet.StoragePath,
        }
        cfg, err = applyProfileVMConfig(profile, cfg)
        if err != nil </span><span class="cov0" title="0">{
                o.cleanupSnippet(sandbox.VMID)
                return o.failJob(job, sandbox.VMID, err)
        }</span>
        <span class="cov3" title="2">if err := o.backend.Configure(ctx, proxmox.VMID(sandbox.VMID), cfg); err != nil </span><span class="cov1" title="1">{
                o.cleanupSnippet(sandbox.VMID)
                return o.failJob(job, sandbox.VMID, err)
        }</span>

        <span class="cov1" title="1">if sandbox.WorkspaceID != nil &amp;&amp; strings.TrimSpace(*sandbox.WorkspaceID) != "" </span><span class="cov0" title="0">{
                if o.workspaceMgr == nil </span><span class="cov0" title="0">{
                        o.cleanupSnippet(sandbox.VMID)
                        return o.failJob(job, sandbox.VMID, errors.New("workspace manager unavailable"))
                }</span>
                <span class="cov0" title="0">if _, err := o.workspaceMgr.Attach(ctx, *sandbox.WorkspaceID, sandbox.VMID); err != nil </span><span class="cov0" title="0">{
                        o.cleanupSnippet(sandbox.VMID)
                        return o.failJob(job, sandbox.VMID, err)
                }</span>
        }

        <span class="cov1" title="1">if err := o.sandboxManager.Transition(ctx, sandbox.VMID, models.SandboxBooting); err != nil </span><span class="cov0" title="0">{
                return o.failJob(job, sandbox.VMID, err)
        }</span>
        <span class="cov1" title="1">if err := o.backend.Start(ctx, proxmox.VMID(sandbox.VMID)); err != nil </span><span class="cov0" title="0">{
                return o.failJob(job, sandbox.VMID, err)
        }</span>

        <span class="cov1" title="1">ip, err := o.backend.GuestIP(ctx, proxmox.VMID(sandbox.VMID))
        if err != nil </span><span class="cov0" title="0">{
                return o.failJob(job, sandbox.VMID, err)
        }</span>
        <span class="cov1" title="1">if ip != "" </span><span class="cov1" title="1">{
                if err := o.store.UpdateSandboxIP(ctx, sandbox.VMID, ip); err != nil </span><span class="cov0" title="0">{
                        return o.failJob(job, sandbox.VMID, err)
                }</span>
        }

        <span class="cov1" title="1">if err := o.sandboxManager.Transition(ctx, sandbox.VMID, models.SandboxReady); err != nil </span><span class="cov0" title="0">{
                return o.failJob(job, sandbox.VMID, err)
        }</span>
        <span class="cov1" title="1">if err := o.sandboxManager.Transition(ctx, sandbox.VMID, models.SandboxRunning); err != nil </span><span class="cov0" title="0">{
                return o.failJob(job, sandbox.VMID, err)
        }</span>
        <span class="cov1" title="1">if err := o.store.UpdateJobStatus(ctx, job.ID, models.JobRunning); err != nil </span><span class="cov0" title="0">{
                return o.failJob(job, sandbox.VMID, err)
        }</span>
        <span class="cov1" title="1">if o.metrics != nil </span><span class="cov0" title="0">{
                o.metrics.IncJobStatus(models.JobRunning)
        }</span>
        <span class="cov1" title="1">_ = o.store.RecordEvent(ctx, "job.running", &amp;sandbox.VMID, &amp;job.ID, "sandbox running", "")
        return nil</span>
}

// ProvisionSandbox provisions a non-job sandbox end-to-end and returns the updated record.
func (o *JobOrchestrator) ProvisionSandbox(ctx context.Context, vmid int) (models.Sandbox, error) <span class="cov5" title="3">{
        if o == nil || o.store == nil </span><span class="cov0" title="0">{
                return models.Sandbox{}, errors.New("sandbox provisioner unavailable")
        }</span>
        <span class="cov5" title="3">ctx, cancel := o.withProvisionTimeout(ctx)
        defer cancel()
        if vmid &lt;= 0 </span><span class="cov0" title="0">{
                return models.Sandbox{}, errors.New("vmid must be positive")
        }</span>
        <span class="cov5" title="3">sandbox, err := o.store.GetSandbox(ctx, vmid)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return models.Sandbox{}, ErrSandboxNotFound
                }</span>
                <span class="cov0" title="0">return models.Sandbox{}, err</span>
        }
        <span class="cov5" title="3">if sandbox.State == models.SandboxRunning </span><span class="cov0" title="0">{
                return sandbox, nil
        }</span>
        <span class="cov5" title="3">if sandbox.State != models.SandboxRequested </span><span class="cov0" title="0">{
                return models.Sandbox{}, fmt.Errorf("sandbox %d in state %s cannot be provisioned", sandbox.VMID, sandbox.State)
        }</span>

        <span class="cov5" title="3">profile, ok := o.profile(sandbox.Profile)
        if !ok </span><span class="cov0" title="0">{
                return models.Sandbox{}, fmt.Errorf("unknown profile %q", sandbox.Profile)
        }</span>
        <span class="cov5" title="3">if err := validateProfileForProvisioning(profile); err != nil </span><span class="cov0" title="0">{
                return models.Sandbox{}, err
        }</span>
        <span class="cov5" title="3">if o.sandboxManager == nil </span><span class="cov0" title="0">{
                return models.Sandbox{}, errors.New("sandbox manager unavailable")
        }</span>
        <span class="cov5" title="3">if o.backend == nil </span><span class="cov0" title="0">{
                return models.Sandbox{}, errors.New("proxmox backend unavailable")
        }</span>
        <span class="cov5" title="3">if o.sshPublicKey == "" </span><span class="cov0" title="0">{
                return models.Sandbox{}, errors.New("ssh public key unavailable")
        }</span>
        <span class="cov5" title="3">if o.controllerURL == "" </span><span class="cov0" title="0">{
                return models.Sandbox{}, errors.New("controller URL unavailable")
        }</span>

        <span class="cov5" title="3">var provisionErr error
        defer func() </span><span class="cov5" title="3">{
                if provisionErr == nil </span><span class="cov3" title="2">{
                        return
                }</span>
                <span class="cov1" title="1">cleanupCtx, cancel := o.withFailureTimeout()
                defer cancel()
                _ = o.sandboxManager.Destroy(cleanupCtx, vmid)</span>
        }()

        <span class="cov5" title="3">fail := func(err error) (models.Sandbox, error) </span><span class="cov1" title="1">{
                provisionErr = err
                return models.Sandbox{}, err
        }</span>

        <span class="cov5" title="3">if err := o.sandboxManager.Transition(ctx, sandbox.VMID, models.SandboxProvisioning); err != nil </span><span class="cov0" title="0">{
                return fail(err)
        }</span>
        <span class="cov5" title="3">if err := o.backend.Clone(ctx, proxmox.VMID(profile.TemplateVM), proxmox.VMID(sandbox.VMID), sandbox.Name); err != nil </span><span class="cov0" title="0">{
                return fail(err)
        }</span>

        <span class="cov5" title="3">token, tokenHash, expiresAt, err := o.bootstrapToken()
        if err != nil </span><span class="cov0" title="0">{
                return fail(err)
        }</span>
        <span class="cov5" title="3">if err := o.store.CreateBootstrapToken(ctx, tokenHash, sandbox.VMID, expiresAt); err != nil </span><span class="cov0" title="0">{
                return fail(err)
        }</span>

        <span class="cov5" title="3">snippet, err := o.snippetStore.Create(proxmox.SnippetInput{
                VMID:           proxmox.VMID(sandbox.VMID),
                Hostname:       sandbox.Name,
                SSHPublicKey:   o.sshPublicKey,
                BootstrapToken: token,
                ControllerURL:  o.controllerURL,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fail(err)
        }</span>
        <span class="cov5" title="3">o.rememberSnippet(snippet)

        cfg := proxmox.VMConfig{
                Name:      sandbox.Name,
                CloudInit: snippet.StoragePath,
        }
        cfg, err = applyProfileVMConfig(profile, cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fail(err)
        }</span>
        <span class="cov5" title="3">if err := o.backend.Configure(ctx, proxmox.VMID(sandbox.VMID), cfg); err != nil </span><span class="cov1" title="1">{
                return fail(err)
        }</span>

        <span class="cov3" title="2">if sandbox.WorkspaceID != nil &amp;&amp; strings.TrimSpace(*sandbox.WorkspaceID) != "" </span><span class="cov0" title="0">{
                if o.workspaceMgr == nil </span><span class="cov0" title="0">{
                        return fail(errors.New("workspace manager unavailable"))
                }</span>
                <span class="cov0" title="0">if _, err := o.workspaceMgr.Attach(ctx, *sandbox.WorkspaceID, sandbox.VMID); err != nil </span><span class="cov0" title="0">{
                        return fail(err)
                }</span>
        }

        <span class="cov3" title="2">if err := o.sandboxManager.Transition(ctx, sandbox.VMID, models.SandboxBooting); err != nil </span><span class="cov0" title="0">{
                return fail(err)
        }</span>
        <span class="cov3" title="2">if err := o.backend.Start(ctx, proxmox.VMID(sandbox.VMID)); err != nil </span><span class="cov0" title="0">{
                return fail(err)
        }</span>

        <span class="cov3" title="2">ip, err := o.backend.GuestIP(ctx, proxmox.VMID(sandbox.VMID))
        if err != nil </span><span class="cov0" title="0">{
                return fail(err)
        }</span>
        <span class="cov3" title="2">if ip != "" </span><span class="cov3" title="2">{
                if err := o.store.UpdateSandboxIP(ctx, sandbox.VMID, ip); err != nil </span><span class="cov0" title="0">{
                        return fail(err)
                }</span>
        }

        <span class="cov3" title="2">if err := o.sandboxManager.Transition(ctx, sandbox.VMID, models.SandboxReady); err != nil </span><span class="cov0" title="0">{
                return fail(err)
        }</span>
        <span class="cov3" title="2">if err := o.sandboxManager.Transition(ctx, sandbox.VMID, models.SandboxRunning); err != nil </span><span class="cov0" title="0">{
                return fail(err)
        }</span>

        <span class="cov3" title="2">updated, loadErr := o.store.GetSandbox(ctx, sandbox.VMID)
        if loadErr != nil </span><span class="cov0" title="0">{
                updated = sandbox
                updated.State = models.SandboxRunning
                if ip != "" </span><span class="cov0" title="0">{
                        updated.IP = ip
                }</span>
        }
        <span class="cov3" title="2">return updated, nil</span>
}

func (o *JobOrchestrator) HandleReport(ctx context.Context, report JobReport) error <span class="cov1" title="1">{
        if o == nil || o.store == nil </span><span class="cov0" title="0">{
                return errors.New("job orchestrator unavailable")
        }</span>
        <span class="cov1" title="1">if report.JobID == "" </span><span class="cov0" title="0">{
                return errors.New("job id is required")
        }</span>
        <span class="cov1" title="1">if report.VMID &lt;= 0 </span><span class="cov0" title="0">{
                return errors.New("vmid must be positive")
        }</span>
        <span class="cov1" title="1">if report.Status == "" </span><span class="cov0" title="0">{
                return errors.New("status is required")
        }</span>
        <span class="cov1" title="1">if o.redactor != nil </span><span class="cov1" title="1">{
                report.Message = o.redactor.Redact(strings.TrimSpace(report.Message))
        }</span> else<span class="cov0" title="0"> {
                report.Message = strings.TrimSpace(report.Message)
        }</span>

        <span class="cov1" title="1">job, err := o.store.GetJob(ctx, report.JobID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return ErrJobNotFound
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov1" title="1">if job.Status == models.JobCompleted || job.Status == models.JobFailed || job.Status == models.JobTimeout </span><span class="cov0" title="0">{
                return ErrJobFinalized
        }</span>
        <span class="cov1" title="1">if job.SandboxVMID == nil || *job.SandboxVMID != report.VMID </span><span class="cov0" title="0">{
                return ErrJobSandboxMismatch
        }</span>

        <span class="cov1" title="1">if o.metrics != nil &amp;&amp; job.Status != report.Status </span><span class="cov0" title="0">{
                o.metrics.IncJobStatus(report.Status)
                if report.Status == models.JobCompleted || report.Status == models.JobFailed || report.Status == models.JobTimeout </span><span class="cov0" title="0">{
                        if !job.CreatedAt.IsZero() </span><span class="cov0" title="0">{
                                o.metrics.ObserveJobDuration(report.Status, o.now().UTC().Sub(job.CreatedAt))
                        }</span>
                }
        }

        <span class="cov1" title="1">resultJSON, err := buildJobResult(report.Status, report.Message, report.Artifacts, report.Result, o.now().UTC())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if err := o.store.UpdateJobResult(ctx, job.ID, report.Status, resultJSON); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">_ = o.store.RecordEvent(ctx, "job.report", &amp;report.VMID, &amp;job.ID, report.Message, "")

        if report.Status == models.JobRunning </span><span class="cov0" title="0">{
                _ = o.ensureSandboxRunning(ctx, report.VMID)
                return nil
        }</span>

        <span class="cov1" title="1">if report.Status == models.JobCompleted || report.Status == models.JobFailed || report.Status == models.JobTimeout </span><span class="cov1" title="1">{
                _ = o.ensureSandboxRunning(ctx, report.VMID)
                if o.sandboxManager != nil </span><span class="cov1" title="1">{
                        target := sandboxStateForJobStatus(report.Status)
                        if target != "" </span><span class="cov1" title="1">{
                                _ = o.sandboxManager.Transition(ctx, report.VMID, target)
                        }</span>
                }
                <span class="cov1" title="1">if !job.Keepalive &amp;&amp; o.sandboxManager != nil </span><span class="cov1" title="1">{
                        _ = o.sandboxManager.Destroy(ctx, report.VMID)
                        o.cleanupSnippet(report.VMID)
                }</span>
                <span class="cov1" title="1">return nil</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (o *JobOrchestrator) ensureSandboxRunning(ctx context.Context, vmid int) error <span class="cov1" title="1">{
        if o.sandboxManager == nil </span><span class="cov0" title="0">{
                return errors.New("sandbox manager unavailable")
        }</span>
        <span class="cov1" title="1">for </span><span class="cov1" title="1">{
                sandbox, err := o.store.GetSandbox(ctx, vmid)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="1">if sandbox.State == models.SandboxRunning </span><span class="cov1" title="1">{
                        return nil
                }</span>
                <span class="cov0" title="0">next, ok := nextSandboxStateTowardRunning(sandbox.State)
                if !ok </span><span class="cov0" title="0">{
                        return ErrInvalidTransition
                }</span>
                <span class="cov0" title="0">if err := o.sandboxManager.Transition(ctx, vmid, next); err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, ErrInvalidTransition) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">return err</span>
                }
        }
}

func (o *JobOrchestrator) ensureSandbox(ctx context.Context, job models.Job) (models.Sandbox, bool, error) <span class="cov3" title="2">{
        if job.SandboxVMID != nil &amp;&amp; *job.SandboxVMID &gt; 0 </span><span class="cov0" title="0">{
                sandbox, err := o.store.GetSandbox(ctx, *job.SandboxVMID)
                if err == nil </span><span class="cov0" title="0">{
                        return sandbox, false, nil
                }</span>
                <span class="cov0" title="0">if !errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return models.Sandbox{}, false, err
                }</span>
        }

        <span class="cov3" title="2">vmid, err := nextSandboxVMID(ctx, o.store)
        if err != nil </span><span class="cov0" title="0">{
                return models.Sandbox{}, false, err
        }</span>
        <span class="cov3" title="2">now := o.now().UTC()
        var leaseExpires time.Time
        if job.TTLMinutes &gt; 0 </span><span class="cov0" title="0">{
                leaseExpires = now.Add(time.Duration(job.TTLMinutes) * time.Minute)
        }</span>
        <span class="cov3" title="2">sandbox := models.Sandbox{
                VMID:          vmid,
                Name:          fmt.Sprintf("sandbox-%d", vmid),
                Profile:       job.Profile,
                State:         models.SandboxRequested,
                Keepalive:     job.Keepalive,
                LeaseExpires:  leaseExpires,
                CreatedAt:     now,
                LastUpdatedAt: now,
        }
        created, err := createSandboxWithRetry(ctx, o.store, sandbox)
        if err != nil </span><span class="cov0" title="0">{
                return models.Sandbox{}, false, err
        }</span>
        <span class="cov3" title="2">return created, true, nil</span>
}

func (o *JobOrchestrator) failJob(job models.Job, vmid int, cause error) error <span class="cov3" title="2">{
        if cause == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov3" title="2">message := cause.Error()
        if o.redactor != nil </span><span class="cov3" title="2">{
                message = o.redactor.Redact(message)
        }</span>
        <span class="cov3" title="2">if o.metrics != nil </span><span class="cov0" title="0">{
                o.metrics.IncJobStatus(models.JobFailed)
                if !job.CreatedAt.IsZero() </span><span class="cov0" title="0">{
                        o.metrics.ObserveJobDuration(models.JobFailed, o.now().UTC().Sub(job.CreatedAt))
                }</span>
        }
        <span class="cov3" title="2">resultJSON, _ := buildJobResult(models.JobFailed, message, nil, nil, o.now().UTC())
        failureCtx, cancel := o.withFailureTimeout()
        defer cancel()
        _ = o.store.UpdateJobResult(failureCtx, job.ID, models.JobFailed, resultJSON)
        _ = o.store.RecordEvent(failureCtx, "job.failed", nullableVMID(vmid), &amp;job.ID, message, "")
        if vmid &gt; 0 &amp;&amp; !job.Keepalive &amp;&amp; o.sandboxManager != nil </span><span class="cov1" title="1">{
                _ = o.sandboxManager.Destroy(failureCtx, vmid)
                o.cleanupSnippet(vmid)
        }</span>
        <span class="cov3" title="2">return cause</span>
}

func (o *JobOrchestrator) profile(name string) (models.Profile, bool) <span class="cov9" title="8">{
        if name == "" </span><span class="cov0" title="0">{
                return models.Profile{}, false
        }</span>
        <span class="cov9" title="8">if o.profiles == nil </span><span class="cov0" title="0">{
                return models.Profile{}, false
        }</span>
        <span class="cov9" title="8">profile, ok := o.profiles[name]
        return profile, ok</span>
}

func (o *JobOrchestrator) bootstrapToken() (string, string, time.Time, error) <span class="cov8" title="7">{
        buf := make([]byte, bootstrapTokenBytes)
        if _, err := io.ReadFull(o.randReader(), buf); err != nil </span><span class="cov0" title="0">{
                return "", "", time.Time{}, err
        }</span>
        <span class="cov8" title="7">token := hex.EncodeToString(buf)
        if o.redactor != nil </span><span class="cov8" title="7">{
                o.redactor.AddValues(token)
        }</span>
        <span class="cov8" title="7">hash, err := db.HashBootstrapToken(token)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", time.Time{}, err
        }</span>
        <span class="cov8" title="7">expires := o.now().UTC().Add(o.bootstrapTTL)
        return token, hash, expires, nil</span>
}

func (o *JobOrchestrator) rememberSnippet(snippet proxmox.CloudInitSnippet) <span class="cov8" title="7">{
        if snippet.VMID &lt;= 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="7">o.snippetsMu.Lock()
        defer o.snippetsMu.Unlock()
        o.snippets[int(snippet.VMID)] = snippet</span>
}

func (o *JobOrchestrator) cleanupSnippet(vmid int) <span class="cov6" title="4">{
        if vmid &lt;= 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov6" title="4">o.snippetsMu.Lock()
        snippet, ok := o.snippets[vmid]
        if ok </span><span class="cov3" title="2">{
                delete(o.snippets, vmid)
        }</span>
        <span class="cov6" title="4">o.snippetsMu.Unlock()
        if ok </span><span class="cov3" title="2">{
                _ = o.snippetStore.Delete(snippet)
        }</span>
}

// CleanupSnippet removes a remembered cloud-init snippet for a VMID.
func (o *JobOrchestrator) CleanupSnippet(vmid int) <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">o.cleanupSnippet(vmid)</span>
}

func (o *JobOrchestrator) randReader() io.Reader <span class="cov8" title="7">{
        if o.rand != nil </span><span class="cov8" title="7">{
                return o.rand
        }</span>
        <span class="cov0" title="0">return rand.Reader</span>
}

// WithProvisionTimeout overrides the default provisioning timeout.
func (o *JobOrchestrator) WithProvisionTimeout(timeout time.Duration) *JobOrchestrator <span class="cov5" title="3">{
        if o == nil </span><span class="cov0" title="0">{
                return o
        }</span>
        <span class="cov5" title="3">o.provisionTimeout = timeout
        return o</span>
}

func (o *JobOrchestrator) withProvisionTimeout(ctx context.Context) (context.Context, context.CancelFunc) <span class="cov9" title="8">{
        if o == nil || o.provisionTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return ctx, func() </span>{<span class="cov0" title="0">}</span>
        }
        <span class="cov9" title="8">return context.WithTimeout(ctx, o.provisionTimeout)</span>
}

func (o *JobOrchestrator) withFailureTimeout() (context.Context, context.CancelFunc) <span class="cov6" title="4">{
        if o == nil || o.failureTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return context.Background(), func() </span>{<span class="cov0" title="0">}</span>
        }
        <span class="cov6" title="4">return context.WithTimeout(context.Background(), o.failureTimeout)</span>
}

func buildJobResult(status models.JobStatus, message string, artifacts []V1ArtifactMetadata, result json.RawMessage, now time.Time) (string, error) <span class="cov5" title="3">{
        payload := struct {
                Status     string               `json:"status"`
                Message    string               `json:"message,omitempty"`
                Artifacts  []V1ArtifactMetadata `json:"artifacts,omitempty"`
                Result     json.RawMessage      `json:"result,omitempty"`
                ReportedAt string               `json:"reported_at"`
        }{
                Status:     string(status),
                Message:    strings.TrimSpace(message),
                Artifacts:  artifacts,
                Result:     result,
                ReportedAt: now.UTC().Format(time.RFC3339Nano),
        }
        out, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov5" title="3">return string(out), nil</span>
}

func nextSandboxStateTowardRunning(current models.SandboxState) (models.SandboxState, bool) <span class="cov0" title="0">{
        switch current </span>{
        case models.SandboxRequested:<span class="cov0" title="0">
                return models.SandboxProvisioning, true</span>
        case models.SandboxProvisioning:<span class="cov0" title="0">
                return models.SandboxBooting, true</span>
        case models.SandboxBooting:<span class="cov0" title="0">
                return models.SandboxReady, true</span>
        case models.SandboxReady:<span class="cov0" title="0">
                return models.SandboxRunning, true</span>
        case models.SandboxRunning:<span class="cov0" title="0">
                return models.SandboxRunning, true</span>
        default:<span class="cov0" title="0">
                return "", false</span>
        }
}

func sandboxStateForJobStatus(status models.JobStatus) models.SandboxState <span class="cov1" title="1">{
        switch status </span>{
        case models.JobCompleted:<span class="cov1" title="1">
                return models.SandboxCompleted</span>
        case models.JobFailed:<span class="cov0" title="0">
                return models.SandboxFailed</span>
        case models.JobTimeout:<span class="cov0" title="0">
                return models.SandboxTimeout</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

func nullableVMID(vmid int) *int <span class="cov3" title="2">{
        if vmid &lt;= 0 </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov1" title="1">value := vmid
        return &amp;value</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package daemon

import (
        "net/http"
        "time"

        "github.com/agentlab/agentlab/internal/models"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

// Metrics collects Prometheus counters and histograms for agentlabd.
type Metrics struct {
        registry                *prometheus.Registry
        sandboxTransitionsTotal *prometheus.CounterVec
        sandboxProvisionSeconds prometheus.Histogram
        jobStatusTotal          *prometheus.CounterVec
        jobDurationSeconds      *prometheus.HistogramVec
}

// NewMetrics constructs a metrics registry and registers all collectors.
func NewMetrics() *Metrics <span class="cov0" title="0">{
        registry := prometheus.NewRegistry()

        sandboxTransitionsTotal := prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Namespace: "agentlab",
                        Subsystem: "sandbox",
                        Name:      "transitions_total",
                        Help:      "Total number of sandbox state transitions.",
                },
                []string{"from", "to"},
        )
        sandboxProvisionSeconds := prometheus.NewHistogram(
                prometheus.HistogramOpts{
                        Namespace: "agentlab",
                        Subsystem: "sandbox",
                        Name:      "provision_duration_seconds",
                        Help:      "Time from sandbox creation to RUNNING.",
                        Buckets:   []float64{1, 2, 5, 10, 20, 30, 60, 120, 300, 600, 1200},
                },
        )
        jobStatusTotal := prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Namespace: "agentlab",
                        Subsystem: "job",
                        Name:      "status_total",
                        Help:      "Total job status transitions.",
                },
                []string{"status"},
        )
        jobDurationSeconds := prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Namespace: "agentlab",
                        Subsystem: "job",
                        Name:      "duration_seconds",
                        Help:      "Job runtime from creation to final status.",
                        Buckets:   []float64{5, 10, 30, 60, 120, 300, 600, 1200, 1800, 3600, 7200},
                },
                []string{"status"},
        )

        registry.MustRegister(
                sandboxTransitionsTotal,
                sandboxProvisionSeconds,
                jobStatusTotal,
                jobDurationSeconds,
        )

        return &amp;Metrics{
                registry:                registry,
                sandboxTransitionsTotal: sandboxTransitionsTotal,
                sandboxProvisionSeconds: sandboxProvisionSeconds,
                jobStatusTotal:          jobStatusTotal,
                jobDurationSeconds:      jobDurationSeconds,
        }
}</span>

// Handler returns an HTTP handler that serves the metrics registry.
func (m *Metrics) Handler() http.Handler <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return http.NotFoundHandler()
        }</span>
        <span class="cov0" title="0">return promhttp.HandlerFor(m.registry, promhttp.HandlerOpts{})</span>
}

func (m *Metrics) IncSandboxTransition(from, to models.SandboxState) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">m.sandboxTransitionsTotal.WithLabelValues(string(from), string(to)).Inc()</span>
}

func (m *Metrics) ObserveSandboxProvision(duration time.Duration) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">seconds := duration.Seconds()
        if seconds &lt; 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">m.sandboxProvisionSeconds.Observe(seconds)</span>
}

func (m *Metrics) IncJobStatus(status models.JobStatus) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">m.jobStatusTotal.WithLabelValues(string(status)).Inc()</span>
}

func (m *Metrics) ObserveJobDuration(status models.JobStatus, duration time.Duration) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">seconds := duration.Seconds()
        if seconds &lt; 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">m.jobDurationSeconds.WithLabelValues(string(status)).Observe(seconds)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package daemon

import (
        "strings"

        "github.com/agentlab/agentlab/internal/models"
        "gopkg.in/yaml.v3"
)

type profileBehaviorSpec struct {
        Behavior profileBehaviorDefaults `yaml:"behavior"`
}

type profileBehaviorDefaults struct {
        KeepaliveDefault  *bool `yaml:"keepalive_default"`
        TTLMinutesDefault *int  `yaml:"ttl_minutes_default"`
}

type behaviorDefaults struct {
        Keepalive  *bool
        TTLMinutes *int
}

func parseProfileBehaviorDefaults(raw string) (behaviorDefaults, error) <span class="cov10" title="4">{
        raw = strings.TrimSpace(raw)
        if raw == "" </span><span class="cov1" title="1">{
                return behaviorDefaults{}, nil
        }</span>
        <span class="cov8" title="3">var spec profileBehaviorSpec
        if err := yaml.Unmarshal([]byte(raw), &amp;spec); err != nil </span><span class="cov0" title="0">{
                return behaviorDefaults{}, err
        }</span>
        <span class="cov8" title="3">defaults := behaviorDefaults{
                Keepalive:  spec.Behavior.KeepaliveDefault,
                TTLMinutes: spec.Behavior.TTLMinutesDefault,
        }
        if defaults.TTLMinutes != nil &amp;&amp; *defaults.TTLMinutes &lt;= 0 </span><span class="cov0" title="0">{
                defaults.TTLMinutes = nil
        }</span>
        <span class="cov8" title="3">return defaults, nil</span>
}

func applyProfileBehaviorDefaults(profile models.Profile, ttlMinutes *int, keepalive *bool) (int, bool, error) <span class="cov10" title="4">{
        defaults, err := parseProfileBehaviorDefaults(profile.RawYAML)
        if err != nil </span><span class="cov0" title="0">{
                return 0, false, err
        }</span>
        <span class="cov10" title="4">effectiveTTL := 0
        if ttlMinutes != nil </span><span class="cov0" title="0">{
                effectiveTTL = *ttlMinutes
        }</span> else<span class="cov10" title="4"> if defaults.TTLMinutes != nil </span><span class="cov8" title="3">{
                effectiveTTL = *defaults.TTLMinutes
        }</span>
        <span class="cov10" title="4">effectiveKeepalive := false
        if keepalive != nil </span><span class="cov0" title="0">{
                effectiveKeepalive = *keepalive
        }</span> else<span class="cov10" title="4"> if defaults.Keepalive != nil </span><span class="cov8" title="3">{
                effectiveKeepalive = *defaults.Keepalive
        }</span>
        <span class="cov10" title="4">return effectiveTTL, effectiveKeepalive, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package daemon

import (
        "strings"

        "gopkg.in/yaml.v3"
)

type profileInnerSandboxSpec struct {
        Behavior profileInnerSandboxBehavior `yaml:"behavior"`
}

type profileInnerSandboxBehavior struct {
        InnerSandbox     string   `yaml:"inner_sandbox"`
        InnerSandboxArgs []string `yaml:"inner_sandbox_args"`
}

type innerSandboxConfig struct {
        Name string
        Args []string
}

func parseProfileInnerSandbox(raw string) (innerSandboxConfig, error) <span class="cov10" title="10">{
        raw = strings.TrimSpace(raw)
        if raw == "" </span><span class="cov6" title="4">{
                return innerSandboxConfig{}, nil
        }</span>
        <span class="cov8" title="6">var spec profileInnerSandboxSpec
        if err := yaml.Unmarshal([]byte(raw), &amp;spec); err != nil </span><span class="cov0" title="0">{
                return innerSandboxConfig{}, err
        }</span>

        <span class="cov8" title="6">value := strings.TrimSpace(spec.Behavior.InnerSandbox)
        if value == "" </span><span class="cov7" title="5">{
                return innerSandboxConfig{}, nil
        }</span>
        <span class="cov1" title="1">value = strings.ToLower(value)
        switch value </span>{
        case "none", "off", "false", "0", "disabled":<span class="cov0" title="0">
                return innerSandboxConfig{}, nil</span>
        case "true", "yes", "1":<span class="cov0" title="0">
                value = "bubblewrap"</span>
        case "bwrap":<span class="cov0" title="0">
                value = "bubblewrap"</span>
        }

        <span class="cov1" title="1">args := make([]string, 0, len(spec.Behavior.InnerSandboxArgs))
        for _, arg := range spec.Behavior.InnerSandboxArgs </span><span class="cov5" title="3">{
                trimmed := strings.TrimSpace(arg)
                if trimmed == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov5" title="3">args = append(args, trimmed)</span>
        }

        <span class="cov1" title="1">return innerSandboxConfig{Name: value, Args: args}, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package daemon

import (
        "strings"

        "github.com/agentlab/agentlab/internal/models"
        "github.com/agentlab/agentlab/internal/proxmox"
        "gopkg.in/yaml.v3"
)

type profileProvisionSpec struct {
        Network   profileNetworkSpec   `yaml:"network"`
        Resources profileResourceSpec  `yaml:"resources"`
}

type profileNetworkSpec struct {
        Bridge string `yaml:"bridge"`
        Model  string `yaml:"model"`
}

type profileResourceSpec struct {
        Cores      int    `yaml:"cores"`
        MemoryMB   int    `yaml:"memory_mb"`
        CPUPinning string `yaml:"cpulist"`
}

func applyProfileVMConfig(profile models.Profile, cfg proxmox.VMConfig) (proxmox.VMConfig, error) <span class="cov10" title="7">{
        raw := strings.TrimSpace(profile.RawYAML)
        if raw == "" </span><span class="cov7" title="4">{
                return cfg, nil
        }</span>
        <span class="cov6" title="3">var spec profileProvisionSpec
        if err := yaml.Unmarshal([]byte(raw), &amp;spec); err != nil </span><span class="cov0" title="0">{
                return cfg, err
        }</span>
        <span class="cov6" title="3">if spec.Resources.Cores &gt; 0 </span><span class="cov1" title="1">{
                cfg.Cores = spec.Resources.Cores
        }</span>
        <span class="cov6" title="3">if spec.Resources.MemoryMB &gt; 0 </span><span class="cov1" title="1">{
                cfg.MemoryMB = spec.Resources.MemoryMB
        }</span>
        <span class="cov6" title="3">if strings.TrimSpace(spec.Resources.CPUPinning) != "" </span><span class="cov1" title="1">{
                cfg.CPUPinning = strings.TrimSpace(spec.Resources.CPUPinning)
        }</span>
        <span class="cov6" title="3">if strings.TrimSpace(spec.Network.Bridge) != "" </span><span class="cov1" title="1">{
                cfg.Bridge = strings.TrimSpace(spec.Network.Bridge)
        }</span>
        <span class="cov6" title="3">if strings.TrimSpace(spec.Network.Model) != "" </span><span class="cov1" title="1">{
                cfg.NetModel = strings.TrimSpace(spec.Network.Model)
        }</span>
        <span class="cov6" title="3">return cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package daemon

import (
        "fmt"
        "sort"
        "strings"

        "github.com/agentlab/agentlab/internal/models"
        "gopkg.in/yaml.v3"
)

func validateProfileForProvisioning(profile models.Profile) error <span class="cov6" title="11">{
        paths, err := profileHostMountPaths(profile.RawYAML)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("parse profile %q: %w", profile.Name, err)
        }</span>
        <span class="cov6" title="11">if len(paths) &gt; 0 </span><span class="cov2" title="2">{
                return fmt.Errorf("profile %q requests host mounts at %s; host bind mounts are not allowed (use workspace disks instead)", profile.Name, strings.Join(paths, ", "))
        }</span>
        <span class="cov5" title="9">if err := validateProfileInnerSandbox(profile); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="9">return nil</span>
}

func validateProfileInnerSandbox(profile models.Profile) error <span class="cov5" title="9">{
        cfg, err := parseProfileInnerSandbox(profile.RawYAML)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("parse profile %q: %w", profile.Name, err)
        }</span>
        <span class="cov5" title="9">if cfg.Name == "" </span><span class="cov5" title="9">{
                return nil
        }</span>
        <span class="cov0" title="0">if cfg.Name != "bubblewrap" </span><span class="cov0" title="0">{
                return fmt.Errorf("profile %q has unsupported behavior.inner_sandbox %q", profile.Name, cfg.Name)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func profileHostMountPaths(raw string) ([]string, error) <span class="cov6" title="14">{
        raw = strings.TrimSpace(raw)
        if raw == "" </span><span class="cov3" title="4">{
                return nil, nil
        }</span>
        <span class="cov5" title="10">var node yaml.Node
        if err := yaml.Unmarshal([]byte(raw), &amp;node); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="10">matches := make(map[string]struct{})
        walkProfileNode(&amp;node, nil, matches)
        if len(matches) == 0 </span><span class="cov4" title="6">{
                return nil, nil
        }</span>
        <span class="cov3" title="4">paths := make([]string, 0, len(matches))
        for path := range matches </span><span class="cov4" title="5">{
                paths = append(paths, path)
        }</span>
        <span class="cov3" title="4">sort.Strings(paths)
        return paths, nil</span>
}

func walkProfileNode(node *yaml.Node, path []string, matches map[string]struct{}) <span class="cov10" title="70">{
        if node == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov10" title="70">switch node.Kind </span>{
        case yaml.DocumentNode:<span class="cov5" title="10">
                for _, child := range node.Content </span><span class="cov5" title="10">{
                        walkProfileNode(child, path, matches)
                }</span>
        case yaml.MappingNode:<span class="cov7" title="18">
                for i := 0; i+1 &lt; len(node.Content); i += 2 </span><span class="cov9" title="47">{
                        keyNode := node.Content[i]
                        valueNode := node.Content[i+1]
                        key := strings.TrimSpace(keyNode.Value)
                        if isHostMountKey(key) </span><span class="cov4" title="5">{
                                matches[joinProfilePath(path, key)] = struct{}{}
                        }</span>
                        <span class="cov9" title="47">nextPath := append(append([]string{}, path...), key)
                        walkProfileNode(valueNode, nextPath, matches)</span>
                }
        case yaml.SequenceNode:<span class="cov3" title="3">
                for idx, child := range node.Content </span><span class="cov3" title="3">{
                        nextPath := append(append([]string{}, path...), fmt.Sprintf("[%d]", idx))
                        walkProfileNode(child, nextPath, matches)
                }</span>
        }
}

func isHostMountKey(key string) bool <span class="cov9" title="47">{
        normalized := strings.ToLower(strings.TrimSpace(key))
        switch normalized </span>{
        case "host_mount", "host_mounts", "host_path", "host_paths", "bind_mount", "bind_mounts", "binds", "mounts", "mount_points", "mountpoints", "virtiofs", "virtio_fs":<span class="cov4" title="5">
                return true</span>
        }
        <span class="cov8" title="42">if strings.Contains(normalized, "host") &amp;&amp; (strings.Contains(normalized, "mount") || strings.Contains(normalized, "path") || strings.Contains(normalized, "bind")) </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="42">if strings.Contains(normalized, "bind") &amp;&amp; strings.Contains(normalized, "mount") </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="42">return false</span>
}

func joinProfilePath(path []string, key string) string <span class="cov4" title="5">{
        segments := append(append([]string{}, path...), key)
        var b strings.Builder
        for _, seg := range segments </span><span class="cov5" title="7">{
                if seg == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov5" title="7">if strings.HasPrefix(seg, "[") </span><span class="cov1" title="1">{
                        b.WriteString(seg)
                        continue</span>
                }
                <span class="cov4" title="6">if b.Len() &gt; 0 </span><span class="cov1" title="1">{
                        b.WriteByte('.')
                }</span>
                <span class="cov4" title="6">b.WriteString(seg)</span>
        }
        <span class="cov4" title="5">return b.String()</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package daemon

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/agentlab/agentlab/internal/models"
        "gopkg.in/yaml.v3"
)

type profileSpec struct {
        Name       string `yaml:"name"`
        TemplateVM int    `yaml:"template_vmid"`
}

// LoadProfiles reads profile YAML files from dir.
func LoadProfiles(dir string) (map[string]models.Profile, error) <span class="cov0" title="0">{
        entries, err := os.ReadDir(dir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read profiles dir %s: %w", dir, err)
        }</span>
        <span class="cov0" title="0">profiles := make(map[string]models.Profile)
        for _, entry := range entries </span><span class="cov0" title="0">{
                if entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">name := entry.Name()
                if !isYAML(name) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">path := filepath.Join(dir, name)
                data, err := os.ReadFile(path)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("read profile %s: %w", path, err)
                }</span>
                <span class="cov0" title="0">var spec profileSpec
                if err := yaml.Unmarshal(data, &amp;spec); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("parse profile %s: %w", path, err)
                }</span>
                <span class="cov0" title="0">if spec.Name == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("profile %s missing name", path)
                }</span>
                <span class="cov0" title="0">if spec.TemplateVM &lt;= 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("profile %s missing template_vmid", path)
                }</span>
                <span class="cov0" title="0">if _, exists := profiles[spec.Name]; exists </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("duplicate profile name %q", spec.Name)
                }</span>
                <span class="cov0" title="0">modTime := time.Now().UTC()
                if info, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                        modTime = info.ModTime().UTC()
                }</span>
                <span class="cov0" title="0">profiles[spec.Name] = models.Profile{
                        Name:       spec.Name,
                        TemplateVM: spec.TemplateVM,
                        UpdatedAt:  modTime,
                        RawYAML:    string(data),
                }</span>
        }
        <span class="cov0" title="0">return profiles, nil</span>
}

func isYAML(name string) bool <span class="cov0" title="0">{
        lower := strings.ToLower(name)
        return strings.HasSuffix(lower, ".yaml") || strings.HasSuffix(lower, ".yml")
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package daemon

import (
        "regexp"
        "strings"
        "sync"
)

const redactedValue = "[REDACTED]"

var defaultRedactionKeys = []string{
        "token",
        "access_token",
        "refresh_token",
        "bootstrap_token",
        "artifact_token",
        "openai_api_key",
        "anthropic_api_key",
        "claude_api_key",
        "github_token",
        "gitlab_token",
        "bitbucket_token",
        "gitea_token",
        "git_token",
        "ssh_private_key",
        "private_key",
}

type redactPattern struct {
        re   *regexp.Regexp
        repl string
}

// Redactor scrubs sensitive values and key/value pairs from log lines.
type Redactor struct {
        mu       sync.RWMutex
        keySet   map[string]struct{}
        keys     []string
        valSet   map[string]struct{}
        values   []string
        patterns []redactPattern
}

// NewRedactor builds a redactor with defaults and optional extra keys.
func NewRedactor(extraKeys []string) *Redactor <span class="cov3" title="33">{
        r := &amp;Redactor{
                keySet: make(map[string]struct{}),
                valSet: make(map[string]struct{}),
        }
        r.AddKeys(defaultRedactionKeys...)
        r.AddKeys(extraKeys...)
        return r
}</span>

// AddKeys registers additional sensitive keys for redaction.
func (r *Redactor) AddKeys(keys ...string) <span class="cov6" title="1075">{
        if r == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov6" title="1075">r.mu.Lock()
        defer r.mu.Unlock()
        changed := false
        for _, key := range keys </span><span class="cov6" title="1509">{
                normalized := strings.ToLower(strings.TrimSpace(key))
                if normalized == "" </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov6" title="1508">if _, ok := r.keySet[normalized]; ok </span><span class="cov6" title="995">{
                        continue</span>
                }
                <span class="cov5" title="513">r.keySet[normalized] = struct{}{}
                r.keys = append(r.keys, normalized)
                changed = true</span>
        }
        <span class="cov6" title="1075">if changed </span><span class="cov3" title="50">{
                r.patterns = buildKeyPatterns(r.keys)
        }</span>
}

// AddValues registers literal sensitive values for redaction.
func (r *Redactor) AddValues(values ...string) <span class="cov3" title="19">{
        if r == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov3" title="19">r.mu.Lock()
        defer r.mu.Unlock()
        for _, value := range values </span><span class="cov3" title="20">{
                trimmed := strings.TrimSpace(value)
                if trimmed == "" || len(trimmed) &lt; 6 </span><span class="cov1" title="3">{
                        continue</span>
                }
                <span class="cov3" title="17">if _, ok := r.valSet[trimmed]; ok </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov3" title="16">r.valSet[trimmed] = struct{}{}
                r.values = append(r.values, trimmed)</span>
        }
}

// Redact returns a scrubbed copy of input.
func (r *Redactor) Redact(input string) string <span class="cov6" title="1039">{
        if r == nil || input == "" </span><span class="cov1" title="2">{
                return input
        }</span>
        <span class="cov6" title="1037">r.mu.RLock()
        values := append([]string(nil), r.values...)
        patterns := append([]redactPattern(nil), r.patterns...)
        r.mu.RUnlock()

        output := input
        for _, value := range values </span><span class="cov6" title="1006">{
                output = strings.ReplaceAll(output, value, redactedValue)
        }</span>
        <span class="cov6" title="1037">for _, pattern := range patterns </span><span class="cov10" title="129905">{
                output = pattern.re.ReplaceAllString(output, pattern.repl)
        }</span>
        <span class="cov6" title="1037">return output</span>
}

func buildKeyPatterns(keys []string) []redactPattern <span class="cov3" title="50">{
        var patterns []redactPattern
        for _, key := range keys </span><span class="cov6" title="823">{
                escaped := regexp.QuoteMeta(key)
                patterns = append(patterns,
                        redactPattern{
                                re:   regexp.MustCompile(`(?i)("` + escaped + `"\s*:\s*")([^"]*)(")`),
                                repl: `$1` + redactedValue + `$3`,
                        },
                        redactPattern{
                                re:   regexp.MustCompile(`(?i)(\b` + escaped + `\b\s*=\s*")([^"]*)(")`),
                                repl: `$1` + redactedValue + `$3`,
                        },
                        redactPattern{
                                re:   regexp.MustCompile(`(?i)(\b` + escaped + `\b\s*=\s*')([^']*)(')`),
                                repl: `$1` + redactedValue + `$3`,
                        },
                        redactPattern{
                                re:   regexp.MustCompile(`(?i)(\b` + escaped + `\b\s*=\s*)([^\s"']+)`),
                                repl: `$1` + redactedValue,
                        },
                        redactPattern{
                                re:   regexp.MustCompile(`(?i)(\b` + escaped + `\b\s*:\s*)([^\s"']+)`),
                                repl: `$1` + redactedValue,
                        },
                )
        }</span>
        <span class="cov3" title="50">return patterns</span>
}

func envKeys(env map[string]string) []string <span class="cov1" title="3">{
        if len(env) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov1" title="3">keys := make([]string, 0, len(env))
        for key := range env </span><span class="cov1" title="3">{
                trimmed := strings.TrimSpace(key)
                if trimmed == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov1" title="3">keys = append(keys, trimmed)</span>
        }
        <span class="cov1" title="3">return keys</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package daemon

import (
        "errors"
        "net"
        "net/http"
        "strings"

        "github.com/agentlab/agentlab/internal/models"
)

// RunnerAPI handles guest runner status reports.
type RunnerAPI struct {
        orchestrator *JobOrchestrator
        agentSubnet  *net.IPNet
}

func NewRunnerAPI(orchestrator *JobOrchestrator, agentSubnet *net.IPNet) *RunnerAPI <span class="cov10" title="2">{
        return &amp;RunnerAPI{orchestrator: orchestrator, agentSubnet: agentSubnet}
}</span>

func (api *RunnerAPI) Register(mux *http.ServeMux) <span class="cov1" title="1">{
        if mux == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov1" title="1">mux.HandleFunc("/v1/runner/report", api.handleRunnerReport)</span>
}

func (api *RunnerAPI) handleRunnerReport(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                writeMethodNotAllowed(w, []string{http.MethodPost})
                return
        }</span>
        <span class="cov1" title="1">if !api.remoteAllowed(r.RemoteAddr) </span><span class="cov1" title="1">{
                writeError(w, http.StatusForbidden, "runner access restricted to agent subnet")
                return
        }</span>
        <span class="cov0" title="0">var req V1RunnerReportRequest
        if err := decodeJSON(w, r, &amp;req); err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, err.Error())
                return
        }</span>
        <span class="cov0" title="0">status, err := parseJobStatus(req.Status)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, err.Error())
                return
        }</span>
        <span class="cov0" title="0">if api.orchestrator == nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusServiceUnavailable, "job orchestration unavailable")
                return
        }</span>
        <span class="cov0" title="0">report := JobReport{
                JobID:     strings.TrimSpace(req.JobID),
                VMID:      req.VMID,
                Status:    status,
                Message:   strings.TrimSpace(req.Message),
                Artifacts: req.Artifacts,
                Result:    req.Result,
        }
        if report.JobID == "" </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "job_id is required")
                return
        }</span>
        <span class="cov0" title="0">if report.VMID &lt;= 0 </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "vmid must be positive")
                return
        }</span>
        <span class="cov0" title="0">if err := api.orchestrator.HandleReport(r.Context(), report); err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, ErrJobNotFound):<span class="cov0" title="0">
                        writeError(w, http.StatusNotFound, "job not found")</span>
                case errors.Is(err, ErrJobSandboxMismatch):<span class="cov0" title="0">
                        writeError(w, http.StatusConflict, "job sandbox mismatch")</span>
                case errors.Is(err, ErrJobFinalized):<span class="cov0" title="0">
                        writeError(w, http.StatusConflict, "job already finalized")</span>
                default:<span class="cov0" title="0">
                        writeError(w, http.StatusInternalServerError, "failed to record job report")</span>
                }
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">resp := V1RunnerReportResponse{
                JobStatus: string(status),
        }
        if status == models.JobRunning </span><span class="cov0" title="0">{
                resp.SandboxStatus = string(models.SandboxRunning)
        }</span> else<span class="cov0" title="0"> if target := sandboxStateForJobStatus(status); target != "" </span><span class="cov0" title="0">{
                resp.SandboxStatus = string(target)
        }</span>
        <span class="cov0" title="0">writeJSON(w, http.StatusOK, resp)</span>
}

func (api *RunnerAPI) remoteAllowed(addr string) bool <span class="cov1" title="1">{
        if api.agentSubnet == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov1" title="1">host, _, err := net.SplitHostPort(addr)
        if err != nil </span><span class="cov0" title="0">{
                host = addr
        }</span>
        <span class="cov1" title="1">host = strings.Trim(host, "[]")
        ip := net.ParseIP(host)
        if ip == nil || ip.IsUnspecified() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov1" title="1">return api.agentSubnet.Contains(ip)</span>
}

func parseJobStatus(value string) (models.JobStatus, error) <span class="cov0" title="0">{
        normalized := strings.ToUpper(strings.TrimSpace(value))
        switch normalized </span>{
        case string(models.JobRunning):<span class="cov0" title="0">
                return models.JobRunning, nil</span>
        case string(models.JobCompleted):<span class="cov0" title="0">
                return models.JobCompleted, nil</span>
        case string(models.JobFailed):<span class="cov0" title="0">
                return models.JobFailed, nil</span>
        case string(models.JobTimeout):<span class="cov0" title="0">
                return models.JobTimeout, nil</span>
        default:<span class="cov0" title="0">
                return "", errors.New("invalid job status")</span>
        }
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package daemon

import (
        "context"
        "errors"
        "fmt"

        "github.com/agentlab/agentlab/internal/db"
        "github.com/agentlab/agentlab/internal/models"
)

func nextSandboxVMID(ctx context.Context, store *db.Store) (int, error) <span class="cov10" title="5">{
        if store == nil </span><span class="cov0" title="0">{
                return 0, errors.New("store is nil")
        }</span>
        <span class="cov10" title="5">maxVMID, err := store.MaxSandboxVMID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov10" title="5">if maxVMID &lt; defaultSandboxVMIDStart </span><span class="cov8" title="4">{
                return defaultSandboxVMIDStart, nil
        }</span>
        <span class="cov1" title="1">return maxVMID + 1, nil</span>
}

func createSandboxWithRetry(ctx context.Context, store *db.Store, sandbox models.Sandbox) (models.Sandbox, error) <span class="cov10" title="5">{
        if store == nil </span><span class="cov0" title="0">{
                return models.Sandbox{}, errors.New("store is nil")
        }</span>
        <span class="cov10" title="5">attempt := sandbox
        for i := 0; i &lt; 5; i++ </span><span class="cov10" title="5">{
                err := store.CreateSandbox(ctx, attempt)
                if err == nil </span><span class="cov10" title="5">{
                        return attempt, nil
                }</span>
                <span class="cov0" title="0">if !isUniqueConstraint(err) </span><span class="cov0" title="0">{
                        return models.Sandbox{}, err
                }</span>
                <span class="cov0" title="0">attempt.VMID++
                if attempt.Name == sandbox.Name </span><span class="cov0" title="0">{
                        attempt.Name = fmt.Sprintf("sandbox-%d", attempt.VMID)
                }</span>
        }
        <span class="cov0" title="0">return models.Sandbox{}, errors.New("vmid allocation failed")</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package daemon

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "log"
        "time"

        "github.com/agentlab/agentlab/internal/db"
        "github.com/agentlab/agentlab/internal/models"
        "github.com/agentlab/agentlab/internal/proxmox"
)

const (
        defaultLeaseGCInterval = 30 * time.Second
)

var (
        ErrInvalidTransition = errors.New("invalid sandbox state transition")
        ErrSandboxNotFound   = errors.New("sandbox not found")
        ErrLeaseNotRenewable = errors.New("sandbox lease is not renewable")
)

// SandboxManager enforces sandbox state transitions and lease GC.
type SandboxManager struct {
        store      *db.Store
        backend    proxmox.Backend
        logger     *log.Logger
        workspace  *WorkspaceManager
        snippetFn  func(vmid int)
        metrics    *Metrics
        now        func() time.Time
        gcInterval time.Duration
}

// NewSandboxManager builds a sandbox manager with defaults.
func NewSandboxManager(store *db.Store, backend proxmox.Backend, logger *log.Logger) *SandboxManager <span class="cov7" title="15">{
        if logger == nil </span><span class="cov0" title="0">{
                logger = log.Default()
        }</span>
        <span class="cov7" title="15">return &amp;SandboxManager{
                store:      store,
                backend:    backend,
                logger:     logger,
                now:        time.Now,
                gcInterval: defaultLeaseGCInterval,
        }</span>
}

// WithWorkspaceManager sets the workspace manager for detach-on-destroy.
func (m *SandboxManager) WithWorkspaceManager(manager *WorkspaceManager) *SandboxManager <span class="cov2" title="2">{
        if m == nil </span><span class="cov0" title="0">{
                return m
        }</span>
        <span class="cov2" title="2">m.workspace = manager
        return m</span>
}

// WithSnippetCleaner sets a callback to clean up cloud-init snippets on destroy.
func (m *SandboxManager) WithSnippetCleaner(cleaner func(vmid int)) *SandboxManager <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return m
        }</span>
        <span class="cov0" title="0">m.snippetFn = cleaner
        return m</span>
}

// WithMetrics wires optional Prometheus metrics.
func (m *SandboxManager) WithMetrics(metrics *Metrics) *SandboxManager <span class="cov1" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return m
        }</span>
        <span class="cov1" title="1">m.metrics = metrics
        return m</span>
}

// StartLeaseGC runs lease GC immediately and then on an interval until ctx is done.
func (m *SandboxManager) StartLeaseGC(ctx context.Context) <span class="cov0" title="0">{
        if m == nil || m.store == nil || m.gcInterval &lt;= 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">m.runLeaseGC(ctx)
        ticker := time.NewTicker(m.gcInterval)
        go func() </span><span class="cov0" title="0">{
                defer ticker.Stop()
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                m.runLeaseGC(ctx)</span>
                        }
                }
        }()
}

// Transition moves a sandbox to the requested state if allowed.
func (m *SandboxManager) Transition(ctx context.Context, vmid int, target models.SandboxState) error <span class="cov10" title="34">{
        if m == nil || m.store == nil </span><span class="cov0" title="0">{
                return errors.New("sandbox manager not configured")
        }</span>
        <span class="cov10" title="34">if target == "" </span><span class="cov0" title="0">{
                return errors.New("target state is required")
        }</span>
        <span class="cov10" title="34">sandbox, err := m.store.GetSandbox(ctx, vmid)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("load sandbox %d: %w", vmid, err)
        }</span>
        <span class="cov10" title="34">current := sandbox.State
        if current == target </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov10" title="34">if !allowedTransition(current, target) </span><span class="cov1" title="1">{
                return fmt.Errorf("%w: %s -&gt; %s", ErrInvalidTransition, current, target)
        }</span>
        <span class="cov9" title="33">updated, err := m.store.UpdateSandboxState(ctx, vmid, current, target)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov9" title="33">if !updated </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: %s -&gt; %s", ErrInvalidTransition, current, target)
        }</span>
        <span class="cov9" title="33">m.recordStateEvent(ctx, vmid, current, target)
        if m.metrics != nil </span><span class="cov0" title="0">{
                m.metrics.IncSandboxTransition(current, target)
                if target == models.SandboxRunning &amp;&amp; !sandbox.CreatedAt.IsZero() </span><span class="cov0" title="0">{
                        m.metrics.ObserveSandboxProvision(m.now().UTC().Sub(sandbox.CreatedAt))
                }</span>
        }
        <span class="cov9" title="33">return nil</span>
}

// RenewLease extends a keepalive sandbox lease.
func (m *SandboxManager) RenewLease(ctx context.Context, vmid int, ttl time.Duration) (time.Time, error) <span class="cov1" title="1">{
        if m == nil || m.store == nil </span><span class="cov0" title="0">{
                return time.Time{}, errors.New("sandbox manager not configured")
        }</span>
        <span class="cov1" title="1">if ttl &lt;= 0 </span><span class="cov0" title="0">{
                return time.Time{}, errors.New("ttl must be positive")
        }</span>
        <span class="cov1" title="1">sandbox, err := m.store.GetSandbox(ctx, vmid)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("load sandbox %d: %w", vmid, err)
        }</span>
        <span class="cov1" title="1">if sandbox.State == models.SandboxDestroyed </span><span class="cov0" title="0">{
                return time.Time{}, ErrSandboxNotFound
        }</span>
        <span class="cov1" title="1">if !sandbox.Keepalive </span><span class="cov0" title="0">{
                return time.Time{}, ErrLeaseNotRenewable
        }</span>
        <span class="cov1" title="1">expiresAt := m.now().UTC().Add(ttl)
        if err := m.store.UpdateSandboxLease(ctx, vmid, expiresAt); err != nil </span><span class="cov0" title="0">{
                return time.Time{}, err
        }</span>
        <span class="cov1" title="1">m.recordLeaseEvent(ctx, vmid, expiresAt)
        return expiresAt, nil</span>
}

// Destroy transitions a sandbox to destroyed after issuing a backend destroy.
func (m *SandboxManager) Destroy(ctx context.Context, vmid int) error <span class="cov5" title="5">{
        if m == nil || m.store == nil </span><span class="cov0" title="0">{
                return errors.New("sandbox manager not configured")
        }</span>
        <span class="cov5" title="5">sandbox, err := m.store.GetSandbox(ctx, vmid)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return ErrSandboxNotFound
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("load sandbox %d: %w", vmid, err)</span>
        }
        <span class="cov5" title="5">if sandbox.State == models.SandboxDestroyed </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov5" title="5">if m.workspace != nil </span><span class="cov0" title="0">{
                if err := m.workspace.DetachFromVM(ctx, vmid); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("detach workspace for vmid %d: %w", vmid, err)
                }</span>
        }
        <span class="cov5" title="5">if err := m.destroySandbox(ctx, vmid); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="5">if err := m.Transition(ctx, vmid, models.SandboxDestroyed); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="5">if m.snippetFn != nil </span><span class="cov0" title="0">{
                m.snippetFn(vmid)
        }</span>
        <span class="cov5" title="5">return nil</span>
}

func (m *SandboxManager) runLeaseGC(ctx context.Context) <span class="cov2" title="2">{
        sandboxes, err := m.store.ListExpiredSandboxes(ctx, m.now().UTC())
        if err != nil </span><span class="cov0" title="0">{
                m.logger.Printf("sandbox lease GC error: %v", err)
                return
        }</span>
        <span class="cov2" title="2">for _, sandbox := range sandboxes </span><span class="cov2" title="2">{
                if err := m.expireSandbox(ctx, sandbox); err != nil </span><span class="cov0" title="0">{
                        m.logger.Printf("sandbox lease GC vmid=%d: %v", sandbox.VMID, err)
                }</span>
        }
}

func (m *SandboxManager) expireSandbox(ctx context.Context, sandbox models.Sandbox) error <span class="cov2" title="2">{
        switch sandbox.State </span>{
        case models.SandboxDestroyed:<span class="cov0" title="0">
                return nil</span>
        case models.SandboxTimeout, models.SandboxCompleted, models.SandboxFailed, models.SandboxStopped:<span class="cov0" title="0"></span>
                // continue
        default:<span class="cov2" title="2">
                if err := m.Transition(ctx, sandbox.VMID, models.SandboxTimeout); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov2" title="2">if sandbox.State != models.SandboxStopped &amp;&amp; sandbox.State != models.SandboxDestroyed </span><span class="cov2" title="2">{
                if err := m.stopSandbox(ctx, sandbox.VMID); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov2" title="2">if err := m.Transition(ctx, sandbox.VMID, models.SandboxStopped); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov2" title="2">if m.workspace != nil </span><span class="cov1" title="1">{
                if err := m.workspace.DetachFromVM(ctx, sandbox.VMID); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("detach workspace for vmid %d: %w", sandbox.VMID, err)
                }</span>
        }
        <span class="cov2" title="2">if err := m.destroySandbox(ctx, sandbox.VMID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov2" title="2">if err := m.Transition(ctx, sandbox.VMID, models.SandboxDestroyed); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov2" title="2">if m.snippetFn != nil </span><span class="cov0" title="0">{
                m.snippetFn(sandbox.VMID)
        }</span>
        <span class="cov2" title="2">return nil</span>
}

func (m *SandboxManager) stopSandbox(ctx context.Context, vmid int) error <span class="cov2" title="2">{
        if m.backend == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov2" title="2">if err := m.backend.Stop(ctx, proxmox.VMID(vmid)); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, proxmox.ErrVMNotFound) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("stop vmid %d: %w", vmid, err)</span>
        }
        <span class="cov2" title="2">return nil</span>
}

func (m *SandboxManager) destroySandbox(ctx context.Context, vmid int) error <span class="cov5" title="7">{
        if m.backend == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov5" title="7">if err := m.backend.Destroy(ctx, proxmox.VMID(vmid)); err != nil </span><span class="cov1" title="1">{
                if errors.Is(err, proxmox.ErrVMNotFound) </span><span class="cov1" title="1">{
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("destroy vmid %d: %w", vmid, err)</span>
        }
        <span class="cov5" title="6">return nil</span>
}

func (m *SandboxManager) recordStateEvent(ctx context.Context, vmid int, from, to models.SandboxState) <span class="cov9" title="33">{
        msg := fmt.Sprintf("%s -&gt; %s", from, to)
        _ = m.store.RecordEvent(ctx, "sandbox.state", &amp;vmid, nil, msg, "")
}</span>

func (m *SandboxManager) recordLeaseEvent(ctx context.Context, vmid int, expiresAt time.Time) <span class="cov1" title="1">{
        msg := fmt.Sprintf("renewed until %s", expiresAt.UTC().Format(time.RFC3339Nano))
        _ = m.store.RecordEvent(ctx, "sandbox.lease", &amp;vmid, nil, msg, "")
}</span>

func allowedTransition(from, to models.SandboxState) bool <span class="cov10" title="34">{
        switch from </span>{
        case models.SandboxRequested:<span class="cov6" title="8">
                return to == models.SandboxProvisioning || to == models.SandboxTimeout || to == models.SandboxDestroyed</span>
        case models.SandboxProvisioning:<span class="cov6" title="9">
                return to == models.SandboxBooting || to == models.SandboxTimeout || to == models.SandboxDestroyed</span>
        case models.SandboxBooting:<span class="cov5" title="5">
                return to == models.SandboxReady || to == models.SandboxTimeout || to == models.SandboxDestroyed</span>
        case models.SandboxReady:<span class="cov4" title="4">
                return to == models.SandboxRunning || to == models.SandboxStopped || to == models.SandboxTimeout || to == models.SandboxDestroyed</span>
        case models.SandboxRunning:<span class="cov3" title="3">
                return to == models.SandboxCompleted || to == models.SandboxFailed || to == models.SandboxTimeout || to == models.SandboxStopped || to == models.SandboxDestroyed</span>
        case models.SandboxCompleted:<span class="cov1" title="1">
                return to == models.SandboxStopped || to == models.SandboxDestroyed</span>
        case models.SandboxFailed:<span class="cov0" title="0">
                return to == models.SandboxStopped || to == models.SandboxDestroyed</span>
        case models.SandboxTimeout:<span class="cov2" title="2">
                return to == models.SandboxStopped || to == models.SandboxDestroyed</span>
        case models.SandboxStopped:<span class="cov2" title="2">
                return to == models.SandboxDestroyed</span>
        case models.SandboxDestroyed:<span class="cov0" title="0">
                return false</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package daemon

import (
        "context"
        "crypto/rand"
        "database/sql"
        "encoding/hex"
        "errors"
        "io"
        "log"
        "strings"
        "time"

        "github.com/agentlab/agentlab/internal/db"
        "github.com/agentlab/agentlab/internal/models"
        "github.com/agentlab/agentlab/internal/proxmox"
)

const (
        defaultWorkspaceStorage = "local-zfs"
        workspaceDiskSlot       = "scsi1"
        workspaceIDBytes        = 8
)

var (
        ErrWorkspaceNotFound    = errors.New("workspace not found")
        ErrWorkspaceExists      = errors.New("workspace already exists")
        ErrWorkspaceAttached    = errors.New("workspace already attached")
        ErrWorkspaceNotAttached = errors.New("workspace not attached")
        ErrWorkspaceVMInUse     = errors.New("vmid already has workspace attached")
)

// WorkspaceManager handles persistent workspace volumes.
type WorkspaceManager struct {
        store   *db.Store
        backend proxmox.Backend
        logger  *log.Logger
        now     func() time.Time
        rand    io.Reader
}

func NewWorkspaceManager(store *db.Store, backend proxmox.Backend, logger *log.Logger) *WorkspaceManager <span class="cov6" title="4">{
        if logger == nil </span><span class="cov0" title="0">{
                logger = log.Default()
        }</span>
        <span class="cov6" title="4">return &amp;WorkspaceManager{
                store:   store,
                backend: backend,
                logger:  logger,
                now:     time.Now,
                rand:    rand.Reader,
        }</span>
}

func (m *WorkspaceManager) Create(ctx context.Context, name, storage string, sizeGB int) (models.Workspace, error) <span class="cov5" title="3">{
        if m == nil || m.store == nil </span><span class="cov0" title="0">{
                return models.Workspace{}, errors.New("workspace manager unavailable")
        }</span>
        <span class="cov5" title="3">if m.backend == nil </span><span class="cov0" title="0">{
                return models.Workspace{}, errors.New("workspace backend unavailable")
        }</span>
        <span class="cov5" title="3">name = strings.TrimSpace(name)
        if name == "" </span><span class="cov0" title="0">{
                return models.Workspace{}, errors.New("workspace name is required")
        }</span>
        <span class="cov5" title="3">if sizeGB &lt;= 0 </span><span class="cov0" title="0">{
                return models.Workspace{}, errors.New("size_gb must be positive")
        }</span>
        <span class="cov5" title="3">storage = strings.TrimSpace(storage)
        if storage == "" </span><span class="cov1" title="1">{
                storage = defaultWorkspaceStorage
        }</span>

        <span class="cov5" title="3">if _, err := m.store.GetWorkspaceByName(ctx, name); err == nil </span><span class="cov0" title="0">{
                return models.Workspace{}, ErrWorkspaceExists
        }</span> else<span class="cov5" title="3"> if !errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                return models.Workspace{}, err
        }</span>

        <span class="cov5" title="3">id, err := newWorkspaceID(m.rand)
        if err != nil </span><span class="cov0" title="0">{
                return models.Workspace{}, err
        }</span>

        <span class="cov5" title="3">volid, err := m.backend.CreateVolume(ctx, storage, id, sizeGB)
        if err != nil </span><span class="cov0" title="0">{
                return models.Workspace{}, err
        }</span>

        <span class="cov5" title="3">now := m.now().UTC()
        workspace := models.Workspace{
                ID:          id,
                Name:        name,
                Storage:     storage,
                VolumeID:    volid,
                SizeGB:      sizeGB,
                CreatedAt:   now,
                LastUpdated: now,
        }

        if err := m.store.CreateWorkspace(ctx, workspace); err != nil </span><span class="cov0" title="0">{
                if isUniqueConstraint(err) </span><span class="cov0" title="0">{
                        _ = m.backend.DeleteVolume(ctx, volid)
                        return models.Workspace{}, ErrWorkspaceExists
                }</span>
                <span class="cov0" title="0">_ = m.backend.DeleteVolume(ctx, volid)
                return models.Workspace{}, err</span>
        }
        <span class="cov5" title="3">return workspace, nil</span>
}

func (m *WorkspaceManager) Resolve(ctx context.Context, idOrName string) (models.Workspace, error) <span class="cov10" title="10">{
        if m == nil || m.store == nil </span><span class="cov0" title="0">{
                return models.Workspace{}, errors.New("workspace manager unavailable")
        }</span>
        <span class="cov10" title="10">idOrName = strings.TrimSpace(idOrName)
        if idOrName == "" </span><span class="cov0" title="0">{
                return models.Workspace{}, errors.New("workspace id is required")
        }</span>
        <span class="cov10" title="10">workspace, err := m.store.GetWorkspace(ctx, idOrName)
        if err == nil </span><span class="cov10" title="10">{
                return workspace, nil
        }</span>
        <span class="cov0" title="0">if !errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                return models.Workspace{}, err
        }</span>
        <span class="cov0" title="0">workspace, err = m.store.GetWorkspaceByName(ctx, idOrName)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return models.Workspace{}, ErrWorkspaceNotFound
                }</span>
                <span class="cov0" title="0">return models.Workspace{}, err</span>
        }
        <span class="cov0" title="0">return workspace, nil</span>
}

func (m *WorkspaceManager) List(ctx context.Context) ([]models.Workspace, error) <span class="cov0" title="0">{
        if m == nil || m.store == nil </span><span class="cov0" title="0">{
                return nil, errors.New("workspace manager unavailable")
        }</span>
        <span class="cov0" title="0">return m.store.ListWorkspaces(ctx)</span>
}

func (m *WorkspaceManager) Attach(ctx context.Context, idOrName string, vmid int) (models.Workspace, error) <span class="cov7" title="5">{
        if m == nil || m.store == nil </span><span class="cov0" title="0">{
                return models.Workspace{}, errors.New("workspace manager unavailable")
        }</span>
        <span class="cov7" title="5">if m.backend == nil </span><span class="cov0" title="0">{
                return models.Workspace{}, errors.New("workspace backend unavailable")
        }</span>
        <span class="cov7" title="5">if vmid &lt;= 0 </span><span class="cov0" title="0">{
                return models.Workspace{}, errors.New("vmid must be positive")
        }</span>
        <span class="cov7" title="5">workspace, err := m.Resolve(ctx, idOrName)
        if err != nil </span><span class="cov0" title="0">{
                return models.Workspace{}, err
        }</span>
        <span class="cov7" title="5">if workspace.AttachedVM != nil </span><span class="cov0" title="0">{
                if *workspace.AttachedVM == vmid </span><span class="cov0" title="0">{
                        return workspace, nil
                }</span>
                <span class="cov0" title="0">return models.Workspace{}, ErrWorkspaceAttached</span>
        }
        <span class="cov7" title="5">if _, err := m.store.GetSandbox(ctx, vmid); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return models.Workspace{}, ErrSandboxNotFound
                }</span>
                <span class="cov0" title="0">return models.Workspace{}, err</span>
        }
        <span class="cov7" title="5">if existing, err := m.store.GetWorkspaceByAttachedVMID(ctx, vmid); err == nil &amp;&amp; existing.ID != workspace.ID </span><span class="cov0" title="0">{
                return models.Workspace{}, ErrWorkspaceVMInUse
        }</span> else<span class="cov7" title="5"> if err != nil &amp;&amp; !errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                return models.Workspace{}, err
        }</span>

        <span class="cov7" title="5">if err := m.backend.AttachVolume(ctx, proxmox.VMID(vmid), workspace.VolumeID, workspaceDiskSlot); err != nil </span><span class="cov0" title="0">{
                return models.Workspace{}, err
        }</span>
        <span class="cov7" title="5">attached, err := m.store.AttachWorkspace(ctx, workspace.ID, vmid)
        if err != nil </span><span class="cov0" title="0">{
                _ = m.backend.DetachVolume(ctx, proxmox.VMID(vmid), workspaceDiskSlot)
                return models.Workspace{}, err
        }</span>
        <span class="cov7" title="5">if !attached </span><span class="cov0" title="0">{
                _ = m.backend.DetachVolume(ctx, proxmox.VMID(vmid), workspaceDiskSlot)
                return models.Workspace{}, ErrWorkspaceAttached
        }</span>
        <span class="cov7" title="5">if err := m.store.UpdateSandboxWorkspace(ctx, vmid, &amp;workspace.ID); err != nil </span><span class="cov0" title="0">{
                _ = m.backend.DetachVolume(ctx, proxmox.VMID(vmid), workspaceDiskSlot)
                _, _ = m.store.DetachWorkspace(ctx, workspace.ID, vmid)
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return models.Workspace{}, ErrSandboxNotFound
                }</span>
                <span class="cov0" title="0">return models.Workspace{}, err</span>
        }
        <span class="cov7" title="5">return m.store.GetWorkspace(ctx, workspace.ID)</span>
}

func (m *WorkspaceManager) Detach(ctx context.Context, idOrName string) (models.Workspace, error) <span class="cov5" title="3">{
        if m == nil || m.store == nil </span><span class="cov0" title="0">{
                return models.Workspace{}, errors.New("workspace manager unavailable")
        }</span>
        <span class="cov5" title="3">if m.backend == nil </span><span class="cov0" title="0">{
                return models.Workspace{}, errors.New("workspace backend unavailable")
        }</span>
        <span class="cov5" title="3">workspace, err := m.Resolve(ctx, idOrName)
        if err != nil </span><span class="cov0" title="0">{
                return models.Workspace{}, err
        }</span>
        <span class="cov5" title="3">if workspace.AttachedVM == nil || *workspace.AttachedVM == 0 </span><span class="cov0" title="0">{
                return workspace, nil
        }</span>
        <span class="cov5" title="3">vmid := *workspace.AttachedVM
        if err := m.backend.DetachVolume(ctx, proxmox.VMID(vmid), workspaceDiskSlot); err != nil </span><span class="cov1" title="1">{
                if !errors.Is(err, proxmox.ErrVMNotFound) </span><span class="cov0" title="0">{
                        return models.Workspace{}, err
                }</span>
        }
        <span class="cov5" title="3">detached, err := m.store.DetachWorkspace(ctx, workspace.ID, vmid)
        if err != nil </span><span class="cov0" title="0">{
                return models.Workspace{}, err
        }</span>
        <span class="cov5" title="3">if !detached </span><span class="cov0" title="0">{
                return models.Workspace{}, ErrWorkspaceNotAttached
        }</span>
        <span class="cov5" title="3">if err := m.store.UpdateSandboxWorkspace(ctx, vmid, nil); err != nil &amp;&amp; !errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                return models.Workspace{}, err
        }</span>
        <span class="cov5" title="3">return m.store.GetWorkspace(ctx, workspace.ID)</span>
}

func (m *WorkspaceManager) DetachFromVM(ctx context.Context, vmid int) error <span class="cov1" title="1">{
        if m == nil || m.store == nil </span><span class="cov0" title="0">{
                return errors.New("workspace manager unavailable")
        }</span>
        <span class="cov1" title="1">if vmid &lt;= 0 </span><span class="cov0" title="0">{
                return errors.New("vmid must be positive")
        }</span>
        <span class="cov1" title="1">workspace, err := m.store.GetWorkspaceByAttachedVMID(ctx, vmid)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov1" title="1">_, err = m.Detach(ctx, workspace.ID)
        return err</span>
}

func newWorkspaceID(r io.Reader) (string, error) <span class="cov5" title="3">{
        if r == nil </span><span class="cov0" title="0">{
                r = rand.Reader
        }</span>
        <span class="cov5" title="3">buf := make([]byte, workspaceIDBytes)
        if _, err := io.ReadFull(r, buf); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov5" title="3">return "workspace-" + hex.EncodeToString(buf), nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package daemon

import (
        "context"
        "errors"
        "fmt"
        "strings"
        "time"

        "github.com/agentlab/agentlab/internal/models"
        "github.com/agentlab/agentlab/internal/proxmox"
)

// WorkspaceRebindResult captures the rebind outcome for API responses.
type WorkspaceRebindResult struct {
        Workspace models.Workspace
        Sandbox   models.Sandbox
        OldVMID   *int
}

// RebindWorkspace provisions a new sandbox for the workspace and attaches the volume.
func (o *JobOrchestrator) RebindWorkspace(ctx context.Context, workspaceID, profileName string, ttlMinutes *int, keepOld bool) (result WorkspaceRebindResult, err error) <span class="cov10" title="2">{
        if o == nil || o.store == nil </span><span class="cov0" title="0">{
                return result, errors.New("workspace rebind unavailable")
        }</span>
        <span class="cov10" title="2">ctx, cancel := o.withProvisionTimeout(ctx)
        defer cancel()
        if o.sandboxManager == nil </span><span class="cov0" title="0">{
                return result, errors.New("sandbox manager unavailable")
        }</span>
        <span class="cov10" title="2">if o.workspaceMgr == nil </span><span class="cov0" title="0">{
                return result, errors.New("workspace manager unavailable")
        }</span>
        <span class="cov10" title="2">if o.backend == nil </span><span class="cov0" title="0">{
                return result, errors.New("proxmox backend unavailable")
        }</span>
        <span class="cov10" title="2">if o.sshPublicKey == "" </span><span class="cov0" title="0">{
                return result, errors.New("ssh public key unavailable")
        }</span>
        <span class="cov10" title="2">if o.controllerURL == "" </span><span class="cov0" title="0">{
                return result, errors.New("controller URL unavailable")
        }</span>

        <span class="cov10" title="2">profileName = strings.TrimSpace(profileName)
        if profileName == "" </span><span class="cov0" title="0">{
                return result, errors.New("profile is required")
        }</span>
        <span class="cov10" title="2">profile, ok := o.profile(profileName)
        if !ok </span><span class="cov0" title="0">{
                return result, fmt.Errorf("unknown profile %q", profileName)
        }</span>
        <span class="cov10" title="2">if err := validateProfileForProvisioning(profile); err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>

        <span class="cov10" title="2">workspace, err := o.workspaceMgr.Resolve(ctx, workspaceID)
        if err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>
        <span class="cov10" title="2">result.Workspace = workspace

        var oldVMID *int
        if workspace.AttachedVM != nil &amp;&amp; *workspace.AttachedVM &gt; 0 </span><span class="cov1" title="1">{
                value := *workspace.AttachedVM
                oldVMID = &amp;value
        }</span>
        <span class="cov10" title="2">result.OldVMID = oldVMID

        newVMID, err := nextSandboxVMID(ctx, o.store)
        if err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>

        <span class="cov10" title="2">now := o.now().UTC()
        var leaseExpires time.Time
        keepalive := false
        if profile.Name != "" </span><span class="cov10" title="2">{
                appliedTTL, appliedKeepalive, err := applyProfileBehaviorDefaults(profile, ttlMinutes, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov10" title="2">if appliedTTL &gt; 0 </span><span class="cov1" title="1">{
                        leaseExpires = now.Add(time.Duration(appliedTTL) * time.Minute)
                }</span>
                <span class="cov10" title="2">keepalive = appliedKeepalive</span>
        } else<span class="cov0" title="0"> if ttlMinutes != nil &amp;&amp; *ttlMinutes &gt; 0 </span><span class="cov0" title="0">{
                leaseExpires = now.Add(time.Duration(*ttlMinutes) * time.Minute)
        }</span>

        <span class="cov10" title="2">sandbox := models.Sandbox{
                VMID:          newVMID,
                Name:          fmt.Sprintf("sandbox-%d", newVMID),
                Profile:       profileName,
                State:         models.SandboxRequested,
                Keepalive:     keepalive,
                LeaseExpires:  leaseExpires,
                CreatedAt:     now,
                LastUpdatedAt: now,
        }

        created, err := createSandboxWithRetry(ctx, o.store, sandbox)
        if err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>

        <span class="cov10" title="2">var (
                snippet        proxmox.CloudInitSnippet
                snippetCreated bool
                attachedToNew  bool
                detachedOld    bool
                ipAddress      string
        )

        defer func() </span><span class="cov10" title="2">{
                if err == nil </span><span class="cov1" title="1">{
                        return
                }</span>
                <span class="cov1" title="1">cleanupCtx, cancel := o.withFailureTimeout()
                defer cancel()
                if attachedToNew </span><span class="cov1" title="1">{
                        _, _ = o.workspaceMgr.Detach(cleanupCtx, workspace.ID)
                }</span>
                <span class="cov1" title="1">if detachedOld &amp;&amp; oldVMID != nil </span><span class="cov1" title="1">{
                        _, _ = o.workspaceMgr.Attach(cleanupCtx, workspace.ID, *oldVMID)
                }</span>
                <span class="cov1" title="1">if created.VMID &gt; 0 </span><span class="cov1" title="1">{
                        _ = o.sandboxManager.Destroy(cleanupCtx, created.VMID)
                }</span>
                <span class="cov1" title="1">if snippetCreated </span><span class="cov1" title="1">{
                        o.cleanupSnippet(created.VMID)
                }</span>
        }()

        <span class="cov10" title="2">if err = o.sandboxManager.Transition(ctx, created.VMID, models.SandboxProvisioning); err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>
        <span class="cov10" title="2">if err = o.backend.Clone(ctx, proxmox.VMID(profile.TemplateVM), proxmox.VMID(created.VMID), created.Name); err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>

        <span class="cov10" title="2">token, tokenHash, expiresAt, err := o.bootstrapToken()
        if err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>
        <span class="cov10" title="2">if err = o.store.CreateBootstrapToken(ctx, tokenHash, created.VMID, expiresAt); err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>

        <span class="cov10" title="2">snippet, err = o.snippetStore.Create(proxmox.SnippetInput{
                VMID:           proxmox.VMID(created.VMID),
                Hostname:       created.Name,
                SSHPublicKey:   o.sshPublicKey,
                BootstrapToken: token,
                ControllerURL:  o.controllerURL,
        })
        if err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>
        <span class="cov10" title="2">o.rememberSnippet(snippet)
        snippetCreated = true

        cfg := proxmox.VMConfig{
                Name:      created.Name,
                CloudInit: snippet.StoragePath,
        }
        cfg, err = applyProfileVMConfig(profile, cfg)
        if err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>
        <span class="cov10" title="2">if err = o.backend.Configure(ctx, proxmox.VMID(created.VMID), cfg); err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>

        <span class="cov10" title="2">if oldVMID != nil </span><span class="cov1" title="1">{
                if _, err = o.workspaceMgr.Detach(ctx, workspace.ID); err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, ErrWorkspaceNotAttached) </span><span class="cov0" title="0">{
                                oldVMID = nil
                                result.OldVMID = nil
                        }</span> else<span class="cov0" title="0"> {
                                return result, err
                        }</span>
                } else<span class="cov1" title="1"> {
                        detachedOld = true
                }</span>
        }

        <span class="cov10" title="2">workspace, err = o.workspaceMgr.Attach(ctx, workspace.ID, created.VMID)
        if err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>
        <span class="cov10" title="2">attachedToNew = true
        result.Workspace = workspace

        if err = o.sandboxManager.Transition(ctx, created.VMID, models.SandboxBooting); err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>
        <span class="cov10" title="2">if err = o.backend.Start(ctx, proxmox.VMID(created.VMID)); err != nil </span><span class="cov1" title="1">{
                return result, err
        }</span>

        <span class="cov1" title="1">ipAddress, err = o.backend.GuestIP(ctx, proxmox.VMID(created.VMID))
        if err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>
        <span class="cov1" title="1">if ipAddress != "" </span><span class="cov1" title="1">{
                if err = o.store.UpdateSandboxIP(ctx, created.VMID, ipAddress); err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
        }

        <span class="cov1" title="1">if err = o.sandboxManager.Transition(ctx, created.VMID, models.SandboxReady); err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>
        <span class="cov1" title="1">if err = o.sandboxManager.Transition(ctx, created.VMID, models.SandboxRunning); err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>

        <span class="cov1" title="1">if !keepOld &amp;&amp; oldVMID != nil </span><span class="cov0" title="0">{
                if destroyErr := o.sandboxManager.Destroy(ctx, *oldVMID); destroyErr != nil &amp;&amp; !errors.Is(destroyErr, ErrSandboxNotFound) </span><span class="cov0" title="0">{
                        if o.logger != nil </span><span class="cov0" title="0">{
                                o.logger.Printf("workspace rebind destroy old vmid=%d: %v", *oldVMID, destroyErr)
                        }</span>
                }
        }

        <span class="cov1" title="1">updated, loadErr := o.store.GetSandbox(ctx, created.VMID)
        if loadErr != nil </span><span class="cov0" title="0">{
                updated = created
                updated.State = models.SandboxRunning
                if ipAddress != "" </span><span class="cov0" title="0">{
                        updated.IP = ipAddress
                }</span>
        }
        <span class="cov1" title="1">if updated.WorkspaceID == nil &amp;&amp; workspace.ID != "" </span><span class="cov0" title="0">{
                id := workspace.ID
                updated.WorkspaceID = &amp;id
        }</span>
        <span class="cov1" title="1">result.Sandbox = updated
        return result, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package db

import (
        "context"
        "crypto/sha256"
        "database/sql"
        "encoding/hex"
        "errors"
        "fmt"
        "strings"
        "time"
)

// ArtifactToken stores hashed upload token metadata.
type ArtifactToken struct {
        TokenHash  string
        JobID      string
        VMID       *int
        ExpiresAt  time.Time
        CreatedAt  time.Time
        LastUsedAt time.Time
}

// HashArtifactToken returns the SHA-256 hex digest of an artifact token.
func HashArtifactToken(token string) (string, error) <span class="cov0" title="0">{
        trimmed := strings.TrimSpace(token)
        if trimmed == "" </span><span class="cov0" title="0">{
                return "", errors.New("token is required")
        }</span>
        <span class="cov0" title="0">sum := sha256.Sum256([]byte(trimmed))
        return hex.EncodeToString(sum[:]), nil</span>
}

// CreateArtifactToken inserts an artifact token record keyed by hash.
func (s *Store) CreateArtifactToken(ctx context.Context, tokenHash, jobID string, vmid int, expiresAt time.Time) error <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">tokenHash = strings.TrimSpace(tokenHash)
        if tokenHash == "" </span><span class="cov0" title="0">{
                return errors.New("token hash is required")
        }</span>
        <span class="cov0" title="0">jobID = strings.TrimSpace(jobID)
        if jobID == "" </span><span class="cov0" title="0">{
                return errors.New("job id is required")
        }</span>
        <span class="cov0" title="0">if vmid &lt;= 0 </span><span class="cov0" title="0">{
                return errors.New("vmid must be positive")
        }</span>
        <span class="cov0" title="0">if expiresAt.IsZero() </span><span class="cov0" title="0">{
                return errors.New("expires_at is required")
        }</span>
        <span class="cov0" title="0">now := formatTime(time.Now().UTC())
        _, err := s.DB.ExecContext(ctx, `INSERT INTO artifact_tokens (token, job_id, vmid, expires_at, created_at) VALUES (?, ?, ?, ?, ?)`,
                tokenHash,
                jobID,
                vmid,
                formatTime(expiresAt),
                now,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("insert artifact token for job %s: %w", jobID, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetArtifactToken loads an artifact token by hash.
func (s *Store) GetArtifactToken(ctx context.Context, tokenHash string) (ArtifactToken, error) <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return ArtifactToken{}, errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">tokenHash = strings.TrimSpace(tokenHash)
        if tokenHash == "" </span><span class="cov0" title="0">{
                return ArtifactToken{}, errors.New("token hash is required")
        }</span>
        <span class="cov0" title="0">row := s.DB.QueryRowContext(ctx, `SELECT token, job_id, vmid, expires_at, created_at, last_used_at
                FROM artifact_tokens WHERE token = ?`, tokenHash)
        return scanArtifactTokenRow(row)</span>
}

// TouchArtifactToken updates last_used_at for a token.
func (s *Store) TouchArtifactToken(ctx context.Context, tokenHash string, now time.Time) error <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">tokenHash = strings.TrimSpace(tokenHash)
        if tokenHash == "" </span><span class="cov0" title="0">{
                return errors.New("token hash is required")
        }</span>
        <span class="cov0" title="0">if now.IsZero() </span><span class="cov0" title="0">{
                now = time.Now().UTC()
        }</span>
        <span class="cov0" title="0">timestamp := formatTime(now)
        _, err := s.DB.ExecContext(ctx, `UPDATE artifact_tokens SET last_used_at = ? WHERE token = ?`, timestamp, tokenHash)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("touch artifact token: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func scanArtifactTokenRow(scanner interface{ Scan(dest ...any) error }) (ArtifactToken, error) <span class="cov0" title="0">{
        var token ArtifactToken
        var tokenHash string
        var jobID string
        var vmid sql.NullInt64
        var expiresAt string
        var createdAt string
        var lastUsed sql.NullString
        if err := scanner.Scan(&amp;tokenHash, &amp;jobID, &amp;vmid, &amp;expiresAt, &amp;createdAt, &amp;lastUsed); err != nil </span><span class="cov0" title="0">{
                return ArtifactToken{}, err
        }</span>
        <span class="cov0" title="0">token.TokenHash = tokenHash
        token.JobID = jobID
        if vmid.Valid </span><span class="cov0" title="0">{
                value := int(vmid.Int64)
                token.VMID = &amp;value
        }</span>
        <span class="cov0" title="0">if expiresAt != "" </span><span class="cov0" title="0">{
                parsed, err := parseTime(expiresAt)
                if err != nil </span><span class="cov0" title="0">{
                        return ArtifactToken{}, fmt.Errorf("parse expires_at: %w", err)
                }</span>
                <span class="cov0" title="0">token.ExpiresAt = parsed</span>
        }
        <span class="cov0" title="0">if createdAt != "" </span><span class="cov0" title="0">{
                parsed, err := parseTime(createdAt)
                if err != nil </span><span class="cov0" title="0">{
                        return ArtifactToken{}, fmt.Errorf("parse created_at: %w", err)
                }</span>
                <span class="cov0" title="0">token.CreatedAt = parsed</span>
        }
        <span class="cov0" title="0">if lastUsed.Valid </span><span class="cov0" title="0">{
                parsed, err := parseTime(lastUsed.String)
                if err != nil </span><span class="cov0" title="0">{
                        return ArtifactToken{}, fmt.Errorf("parse last_used_at: %w", err)
                }</span>
                <span class="cov0" title="0">token.LastUsedAt = parsed</span>
        }
        <span class="cov0" title="0">return token, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package db

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "strings"
        "time"

        "github.com/agentlab/agentlab/internal/models"
)

// Artifact stores artifact metadata.
type Artifact struct {
        ID        int64
        JobID     string
        VMID      *int
        Name      string
        Path      string
        SizeBytes int64
        Sha256    string
        MIME      string
        CreatedAt time.Time
}

// ArtifactRetentionRecord combines artifact metadata with job and sandbox state.
type ArtifactRetentionRecord struct {
        Artifact     Artifact
        JobProfile   string
        JobStatus    models.JobStatus
        JobUpdatedAt time.Time
        SandboxVMID  *int
        SandboxState models.SandboxState
}

// CreateArtifact inserts artifact metadata and returns the row id.
func (s *Store) CreateArtifact(ctx context.Context, artifact Artifact) (int64, error) <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return 0, errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">artifact.JobID = strings.TrimSpace(artifact.JobID)
        if artifact.JobID == "" </span><span class="cov0" title="0">{
                return 0, errors.New("job id is required")
        }</span>
        <span class="cov0" title="0">artifact.Name = strings.TrimSpace(artifact.Name)
        if artifact.Name == "" </span><span class="cov0" title="0">{
                return 0, errors.New("artifact name is required")
        }</span>
        <span class="cov0" title="0">artifact.Path = strings.TrimSpace(artifact.Path)
        if artifact.Path == "" </span><span class="cov0" title="0">{
                return 0, errors.New("artifact path is required")
        }</span>
        <span class="cov0" title="0">if artifact.SizeBytes &lt;= 0 </span><span class="cov0" title="0">{
                return 0, errors.New("artifact size must be positive")
        }</span>
        <span class="cov0" title="0">artifact.Sha256 = strings.TrimSpace(artifact.Sha256)
        if artifact.Sha256 == "" </span><span class="cov0" title="0">{
                return 0, errors.New("artifact sha256 is required")
        }</span>
        <span class="cov0" title="0">createdAt := artifact.CreatedAt
        if createdAt.IsZero() </span><span class="cov0" title="0">{
                createdAt = time.Now().UTC()
        }</span>
        <span class="cov0" title="0">var vmid sql.NullInt64
        if artifact.VMID != nil &amp;&amp; *artifact.VMID &gt; 0 </span><span class="cov0" title="0">{
                vmid = sql.NullInt64{Valid: true, Int64: int64(*artifact.VMID)}
        }</span>
        <span class="cov0" title="0">var mime interface{}
        if strings.TrimSpace(artifact.MIME) != "" </span><span class="cov0" title="0">{
                mime = strings.TrimSpace(artifact.MIME)
        }</span>
        <span class="cov0" title="0">res, err := s.DB.ExecContext(ctx, `INSERT INTO artifacts (job_id, vmid, name, path, size_bytes, sha256, mime, created_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
                artifact.JobID,
                vmid,
                artifact.Name,
                artifact.Path,
                artifact.SizeBytes,
                artifact.Sha256,
                mime,
                formatTime(createdAt),
        )
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("insert artifact for job %s: %w", artifact.JobID, err)
        }</span>
        <span class="cov0" title="0">id, err := res.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("artifact id: %w", err)
        }</span>
        <span class="cov0" title="0">return id, nil</span>
}

// DeleteArtifact removes an artifact record by id.
func (s *Store) DeleteArtifact(ctx context.Context, id int64) error <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">if id &lt;= 0 </span><span class="cov0" title="0">{
                return errors.New("artifact id is required")
        }</span>
        <span class="cov0" title="0">res, err := s.DB.ExecContext(ctx, `DELETE FROM artifacts WHERE id = ?`, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete artifact %d: %w", id, err)
        }</span>
        <span class="cov0" title="0">affected, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("rows affected delete artifact %d: %w", id, err)
        }</span>
        <span class="cov0" title="0">if affected == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ListArtifactRetentionCandidates returns artifacts with job metadata for GC.
func (s *Store) ListArtifactRetentionCandidates(ctx context.Context) ([]ArtifactRetentionRecord, error) <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return nil, errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">rows, err := s.DB.QueryContext(ctx, `SELECT a.id, a.job_id, a.vmid, a.name, a.path, a.size_bytes, a.sha256, a.mime, a.created_at,
                j.profile, j.status, j.updated_at, j.sandbox_vmid, s.state
                FROM artifacts a
                INNER JOIN jobs j ON a.job_id = j.id
                LEFT JOIN sandboxes s ON j.sandbox_vmid = s.vmid`)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list artifact retention candidates: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var out []ArtifactRetentionRecord
        for rows.Next() </span><span class="cov0" title="0">{
                var artifact Artifact
                var vmid sql.NullInt64
                var mime sql.NullString
                var createdAt string
                var profile string
                var status string
                var jobUpdatedAt string
                var jobSandbox sql.NullInt64
                var sandboxState sql.NullString
                if err := rows.Scan(
                        &amp;artifact.ID,
                        &amp;artifact.JobID,
                        &amp;vmid,
                        &amp;artifact.Name,
                        &amp;artifact.Path,
                        &amp;artifact.SizeBytes,
                        &amp;artifact.Sha256,
                        &amp;mime,
                        &amp;createdAt,
                        &amp;profile,
                        &amp;status,
                        &amp;jobUpdatedAt,
                        &amp;jobSandbox,
                        &amp;sandboxState,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if vmid.Valid </span><span class="cov0" title="0">{
                        value := int(vmid.Int64)
                        artifact.VMID = &amp;value
                }</span>
                <span class="cov0" title="0">if mime.Valid </span><span class="cov0" title="0">{
                        artifact.MIME = mime.String
                }</span>
                <span class="cov0" title="0">if createdAt != "" </span><span class="cov0" title="0">{
                        parsed, err := parseTime(createdAt)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("parse artifact created_at: %w", err)
                        }</span>
                        <span class="cov0" title="0">artifact.CreatedAt = parsed</span>
                }
                <span class="cov0" title="0">var updated time.Time
                if jobUpdatedAt != "" </span><span class="cov0" title="0">{
                        parsed, err := parseTime(jobUpdatedAt)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("parse job updated_at: %w", err)
                        }</span>
                        <span class="cov0" title="0">updated = parsed</span>
                }
                <span class="cov0" title="0">record := ArtifactRetentionRecord{
                        Artifact:     artifact,
                        JobProfile:   profile,
                        JobStatus:    models.JobStatus(status),
                        JobUpdatedAt: updated,
                }
                if jobSandbox.Valid </span><span class="cov0" title="0">{
                        value := int(jobSandbox.Int64)
                        record.SandboxVMID = &amp;value
                }</span> else<span class="cov0" title="0"> if artifact.VMID != nil </span><span class="cov0" title="0">{
                        record.SandboxVMID = artifact.VMID
                }</span>
                <span class="cov0" title="0">if sandboxState.Valid </span><span class="cov0" title="0">{
                        record.SandboxState = models.SandboxState(sandboxState.String)
                }</span>
                <span class="cov0" title="0">out = append(out, record)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("iterate artifact retention candidates: %w", err)
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// ListArtifactsByJob returns artifacts for a job ordered by created_at.
func (s *Store) ListArtifactsByJob(ctx context.Context, jobID string) ([]Artifact, error) <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return nil, errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">jobID = strings.TrimSpace(jobID)
        if jobID == "" </span><span class="cov0" title="0">{
                return nil, errors.New("job id is required")
        }</span>
        <span class="cov0" title="0">rows, err := s.DB.QueryContext(ctx, `SELECT id, job_id, vmid, name, path, size_bytes, sha256, mime, created_at
                FROM artifacts WHERE job_id = ? ORDER BY created_at ASC`, jobID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list artifacts: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var out []Artifact
        for rows.Next() </span><span class="cov0" title="0">{
                artifact, err := scanArtifactRow(rows)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">out = append(out, artifact)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("iterate artifacts: %w", err)
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func scanArtifactRow(scanner interface{ Scan(dest ...any) error }) (Artifact, error) <span class="cov0" title="0">{
        var artifact Artifact
        var vmid sql.NullInt64
        var mime sql.NullString
        var createdAt string
        if err := scanner.Scan(
                &amp;artifact.ID,
                &amp;artifact.JobID,
                &amp;vmid,
                &amp;artifact.Name,
                &amp;artifact.Path,
                &amp;artifact.SizeBytes,
                &amp;artifact.Sha256,
                &amp;mime,
                &amp;createdAt,
        ); err != nil </span><span class="cov0" title="0">{
                return Artifact{}, err
        }</span>
        <span class="cov0" title="0">if vmid.Valid </span><span class="cov0" title="0">{
                value := int(vmid.Int64)
                artifact.VMID = &amp;value
        }</span>
        <span class="cov0" title="0">if mime.Valid </span><span class="cov0" title="0">{
                artifact.MIME = mime.String
        }</span>
        <span class="cov0" title="0">if createdAt != "" </span><span class="cov0" title="0">{
                parsed, err := parseTime(createdAt)
                if err != nil </span><span class="cov0" title="0">{
                        return Artifact{}, fmt.Errorf("parse created_at: %w", err)
                }</span>
                <span class="cov0" title="0">artifact.CreatedAt = parsed</span>
        }
        <span class="cov0" title="0">return artifact, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package db

import (
        "context"
        "crypto/sha256"
        "database/sql"
        "encoding/hex"
        "errors"
        "fmt"
        "strings"
        "time"
)

// HashBootstrapToken returns the SHA-256 hex digest of a bootstrap token.
func HashBootstrapToken(token string) (string, error) <span class="cov10" title="6">{
        trimmed := strings.TrimSpace(token)
        if trimmed == "" </span><span class="cov1" title="1">{
                return "", errors.New("token is required")
        }</span>
        <span class="cov9" title="5">sum := sha256.Sum256([]byte(trimmed))
        return hex.EncodeToString(sum[:]), nil</span>
}

// CreateBootstrapToken inserts a bootstrap token record keyed by hash.
func (s *Store) CreateBootstrapToken(ctx context.Context, tokenHash string, vmid int, expiresAt time.Time) error <span class="cov7" title="4">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return errors.New("db store is nil")
        }</span>
        <span class="cov7" title="4">tokenHash = strings.TrimSpace(tokenHash)
        if tokenHash == "" </span><span class="cov0" title="0">{
                return errors.New("token hash is required")
        }</span>
        <span class="cov7" title="4">if vmid &lt;= 0 </span><span class="cov0" title="0">{
                return errors.New("vmid must be positive")
        }</span>
        <span class="cov7" title="4">if expiresAt.IsZero() </span><span class="cov0" title="0">{
                return errors.New("expires_at is required")
        }</span>
        <span class="cov7" title="4">now := formatTime(time.Now().UTC())
        _, err := s.DB.ExecContext(ctx, `INSERT INTO bootstrap_tokens (token, vmid, expires_at, created_at) VALUES (?, ?, ?, ?)`,
                tokenHash,
                vmid,
                formatTime(expiresAt),
                now,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("insert bootstrap token for vmid %d: %w", vmid, err)
        }</span>
        <span class="cov7" title="4">return nil</span>
}

// ValidateBootstrapToken reports whether a token is valid and unconsumed.
func (s *Store) ValidateBootstrapToken(ctx context.Context, tokenHash string, vmid int, now time.Time) (bool, error) <span class="cov7" title="4">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return false, errors.New("db store is nil")
        }</span>
        <span class="cov7" title="4">tokenHash = strings.TrimSpace(tokenHash)
        if tokenHash == "" </span><span class="cov0" title="0">{
                return false, errors.New("token hash is required")
        }</span>
        <span class="cov7" title="4">if vmid &lt;= 0 </span><span class="cov0" title="0">{
                return false, errors.New("vmid must be positive")
        }</span>
        <span class="cov7" title="4">if now.IsZero() </span><span class="cov0" title="0">{
                now = time.Now().UTC()
        }</span>
        <span class="cov7" title="4">timestamp := formatTime(now)
        row := s.DB.QueryRowContext(ctx, `SELECT 1 FROM bootstrap_tokens
                WHERE token = ? AND vmid = ? AND consumed_at IS NULL AND expires_at &gt; ?`,
                tokenHash,
                vmid,
                timestamp,
        )
        var exists int
        if err := row.Scan(&amp;exists); err != nil </span><span class="cov6" title="3">{
                if err == sql.ErrNoRows </span><span class="cov6" title="3">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("validate bootstrap token for vmid %d: %w", vmid, err)</span>
        }
        <span class="cov1" title="1">return true, nil</span>
}

// ConsumeBootstrapToken marks a token as consumed if it is valid and unexpired.
func (s *Store) ConsumeBootstrapToken(ctx context.Context, tokenHash string, vmid int, now time.Time) (bool, error) <span class="cov7" title="4">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return false, errors.New("db store is nil")
        }</span>
        <span class="cov7" title="4">tokenHash = strings.TrimSpace(tokenHash)
        if tokenHash == "" </span><span class="cov0" title="0">{
                return false, errors.New("token hash is required")
        }</span>
        <span class="cov7" title="4">if vmid &lt;= 0 </span><span class="cov0" title="0">{
                return false, errors.New("vmid must be positive")
        }</span>
        <span class="cov7" title="4">if now.IsZero() </span><span class="cov0" title="0">{
                now = time.Now().UTC()
        }</span>
        <span class="cov7" title="4">timestamp := formatTime(now)
        res, err := s.DB.ExecContext(ctx, `UPDATE bootstrap_tokens
                SET consumed_at = ?
                WHERE token = ? AND vmid = ? AND consumed_at IS NULL AND expires_at &gt; ?`,
                timestamp,
                tokenHash,
                vmid,
                timestamp,
        )
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("consume bootstrap token for vmid %d: %w", vmid, err)
        }</span>
        <span class="cov7" title="4">affected, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("rows affected consume bootstrap token: %w", err)
        }</span>
        <span class="cov7" title="4">return affected &gt; 0, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package db

import (
        "database/sql"
        "errors"
        "fmt"
        "os"
        "path/filepath"

        _ "modernc.org/sqlite"
)

const (
        dataDirPerms = 0o750
)

// Store holds the SQLite handle for agentlabd.
type Store struct {
        Path string
        DB   *sql.DB
}

// Open connects to SQLite, applies pragmas, and runs migrations.
func Open(path string) (*Store, error) <span class="cov4" title="2">{
        if path == "" </span><span class="cov0" title="0">{
                return nil, errors.New("db path is required")
        }</span>
        <span class="cov4" title="2">if err := ensureDir(filepath.Dir(path)); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">conn, err := sql.Open("sqlite", path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("open sqlite %s: %w", path, err)
        }</span>
        <span class="cov4" title="2">conn.SetMaxOpenConns(1)
        conn.SetMaxIdleConns(1)
        if err := applyPragmas(conn); err != nil </span><span class="cov0" title="0">{
                _ = conn.Close()
                return nil, err
        }</span>
        <span class="cov4" title="2">if err := conn.Ping(); err != nil </span><span class="cov0" title="0">{
                _ = conn.Close()
                return nil, fmt.Errorf("ping sqlite %s: %w", path, err)
        }</span>
        <span class="cov4" title="2">if err := Migrate(conn); err != nil </span><span class="cov0" title="0">{
                _ = conn.Close()
                return nil, err
        }</span>
        <span class="cov4" title="2">return &amp;Store{Path: path, DB: conn}, nil</span>
}

// Close releases the underlying database connection.
func (s *Store) Close() error <span class="cov4" title="2">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov4" title="2">return s.DB.Close()</span>
}

func ensureDir(path string) error <span class="cov4" title="2">{
        if path == "" </span><span class="cov0" title="0">{
                return errors.New("db directory is required")
        }</span>
        <span class="cov4" title="2">if err := os.MkdirAll(path, dataDirPerms); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create db dir %s: %w", path, err)
        }</span>
        <span class="cov4" title="2">return nil</span>
}

func applyPragmas(db *sql.DB) error <span class="cov4" title="2">{
        pragmas := []string{
                "PRAGMA foreign_keys = ON;",
                "PRAGMA journal_mode = WAL;",
                "PRAGMA busy_timeout = 5000;",
        }
        for _, pragma := range pragmas </span><span class="cov10" title="6">{
                if _, err := db.Exec(pragma); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("apply pragma %q: %w", pragma, err)
                }</span>
        }
        <span class="cov4" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package db

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "strings"
        "time"
)

type Event struct {
        ID          int64
        Timestamp   time.Time
        Kind        string
        SandboxVMID *int
        JobID       *string
        Message     string
        JSON        string
}

func (s *Store) ListEventsBySandbox(ctx context.Context, vmid int, afterID int64, limit int) ([]Event, error) <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return nil, errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">if vmid &lt;= 0 </span><span class="cov0" title="0">{
                return nil, errors.New("vmid must be positive")
        }</span>
        <span class="cov0" title="0">if limit &lt;= 0 </span><span class="cov0" title="0">{
                return nil, errors.New("limit must be positive")
        }</span>
        <span class="cov0" title="0">rows, err := s.DB.QueryContext(ctx, `SELECT id, ts, kind, sandbox_vmid, job_id, msg, json
                FROM events WHERE sandbox_vmid = ? AND id &gt; ? ORDER BY id ASC LIMIT ?`, vmid, afterID, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list events: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var out []Event
        for rows.Next() </span><span class="cov0" title="0">{
                ev, err := scanEventRow(rows)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">out = append(out, ev)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("iterate events: %w", err)
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (s *Store) ListEventsByJob(ctx context.Context, jobID string, afterID int64, limit int) ([]Event, error) <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return nil, errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">jobID = strings.TrimSpace(jobID)
        if jobID == "" </span><span class="cov0" title="0">{
                return nil, errors.New("job id is required")
        }</span>
        <span class="cov0" title="0">if limit &lt;= 0 </span><span class="cov0" title="0">{
                return nil, errors.New("limit must be positive")
        }</span>
        <span class="cov0" title="0">rows, err := s.DB.QueryContext(ctx, `SELECT id, ts, kind, sandbox_vmid, job_id, msg, json
                FROM events WHERE job_id = ? AND id &gt; ? ORDER BY id ASC LIMIT ?`, jobID, afterID, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list events: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var out []Event
        for rows.Next() </span><span class="cov0" title="0">{
                ev, err := scanEventRow(rows)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">out = append(out, ev)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("iterate events: %w", err)
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (s *Store) ListEventsBySandboxTail(ctx context.Context, vmid int, limit int) ([]Event, error) <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return nil, errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">if vmid &lt;= 0 </span><span class="cov0" title="0">{
                return nil, errors.New("vmid must be positive")
        }</span>
        <span class="cov0" title="0">if limit &lt;= 0 </span><span class="cov0" title="0">{
                return nil, errors.New("limit must be positive")
        }</span>
        <span class="cov0" title="0">rows, err := s.DB.QueryContext(ctx, `SELECT id, ts, kind, sandbox_vmid, job_id, msg, json
                FROM events WHERE sandbox_vmid = ? ORDER BY id DESC LIMIT ?`, vmid, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list events tail: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var out []Event
        for rows.Next() </span><span class="cov0" title="0">{
                ev, err := scanEventRow(rows)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">out = append(out, ev)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("iterate events tail: %w", err)
        }</span>
        <span class="cov0" title="0">for i, j := 0, len(out)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov0" title="0">{
                out[i], out[j] = out[j], out[i]
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (s *Store) ListEventsByJobTail(ctx context.Context, jobID string, limit int) ([]Event, error) <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return nil, errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">jobID = strings.TrimSpace(jobID)
        if jobID == "" </span><span class="cov0" title="0">{
                return nil, errors.New("job id is required")
        }</span>
        <span class="cov0" title="0">if limit &lt;= 0 </span><span class="cov0" title="0">{
                return nil, errors.New("limit must be positive")
        }</span>
        <span class="cov0" title="0">rows, err := s.DB.QueryContext(ctx, `SELECT id, ts, kind, sandbox_vmid, job_id, msg, json
                FROM events WHERE job_id = ? ORDER BY id DESC LIMIT ?`, jobID, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list events tail: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var out []Event
        for rows.Next() </span><span class="cov0" title="0">{
                ev, err := scanEventRow(rows)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">out = append(out, ev)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("iterate events tail: %w", err)
        }</span>
        <span class="cov0" title="0">for i, j := 0, len(out)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov0" title="0">{
                out[i], out[j] = out[j], out[i]
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func scanEventRow(scanner interface{ Scan(dest ...any) error }) (Event, error) <span class="cov0" title="0">{
        var ev Event
        var ts string
        var kind string
        var sandboxVMID sql.NullInt64
        var jobID sql.NullString
        var msg sql.NullString
        var jsonPayload sql.NullString
        if err := scanner.Scan(&amp;ev.ID, &amp;ts, &amp;kind, &amp;sandboxVMID, &amp;jobID, &amp;msg, &amp;jsonPayload); err != nil </span><span class="cov0" title="0">{
                return Event{}, err
        }</span>
        <span class="cov0" title="0">if ts != "" </span><span class="cov0" title="0">{
                parsed, err := parseTime(ts)
                if err != nil </span><span class="cov0" title="0">{
                        return Event{}, fmt.Errorf("parse event ts: %w", err)
                }</span>
                <span class="cov0" title="0">ev.Timestamp = parsed</span>
        }
        <span class="cov0" title="0">ev.Kind = kind
        if sandboxVMID.Valid </span><span class="cov0" title="0">{
                value := int(sandboxVMID.Int64)
                ev.SandboxVMID = &amp;value
        }</span>
        <span class="cov0" title="0">if jobID.Valid </span><span class="cov0" title="0">{
                value := jobID.String
                ev.JobID = &amp;value
        }</span>
        <span class="cov0" title="0">if msg.Valid </span><span class="cov0" title="0">{
                ev.Message = msg.String
        }</span>
        <span class="cov0" title="0">if jsonPayload.Valid </span><span class="cov0" title="0">{
                ev.JSON = jsonPayload.String
        }</span>
        <span class="cov0" title="0">return ev, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package db

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "time"

        "github.com/agentlab/agentlab/internal/models"
)

// CreateJob inserts a new job row.
func (s *Store) CreateJob(ctx context.Context, job models.Job) error <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">if job.ID == "" </span><span class="cov0" title="0">{
                return errors.New("job id is required")
        }</span>
        <span class="cov0" title="0">if job.RepoURL == "" </span><span class="cov0" title="0">{
                return errors.New("job repo_url is required")
        }</span>
        <span class="cov0" title="0">if job.Ref == "" </span><span class="cov0" title="0">{
                return errors.New("job ref is required")
        }</span>
        <span class="cov0" title="0">if job.Profile == "" </span><span class="cov0" title="0">{
                return errors.New("job profile is required")
        }</span>
        <span class="cov0" title="0">if job.Status == "" </span><span class="cov0" title="0">{
                return errors.New("job status is required")
        }</span>
        <span class="cov0" title="0">now := time.Now().UTC()
        createdAt := job.CreatedAt
        if createdAt.IsZero() </span><span class="cov0" title="0">{
                createdAt = now
        }</span>
        <span class="cov0" title="0">updatedAt := job.UpdatedAt
        if updatedAt.IsZero() </span><span class="cov0" title="0">{
                updatedAt = createdAt
        }</span>
        <span class="cov0" title="0">var sandbox interface{}
        if job.SandboxVMID != nil &amp;&amp; *job.SandboxVMID &gt; 0 </span><span class="cov0" title="0">{
                sandbox = *job.SandboxVMID
        }</span>
        <span class="cov0" title="0">var ttl interface{}
        if job.TTLMinutes &gt; 0 </span><span class="cov0" title="0">{
                ttl = job.TTLMinutes
        }</span>
        <span class="cov0" title="0">var result interface{}
        if job.ResultJSON != "" </span><span class="cov0" title="0">{
                result = job.ResultJSON
        }</span>
        <span class="cov0" title="0">_, err := s.DB.ExecContext(ctx, `INSERT INTO jobs (
                id, repo_url, ref, profile, status, sandbox_vmid, task, mode, ttl_minutes, keepalive, created_at, updated_at, result_json
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                job.ID,
                job.RepoURL,
                job.Ref,
                job.Profile,
                job.Status,
                sandbox,
                nullIfEmpty(job.Task),
                nullIfEmpty(job.Mode),
                ttl,
                job.Keepalive,
                formatTime(createdAt),
                formatTime(updatedAt),
                result,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("insert job %s: %w", job.ID, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetJob loads a job by id.
func (s *Store) GetJob(ctx context.Context, id string) (models.Job, error) <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return models.Job{}, errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">row := s.DB.QueryRowContext(ctx, `SELECT id, repo_url, ref, profile, task, mode, ttl_minutes, keepalive, status, sandbox_vmid, created_at, updated_at, result_json
                FROM jobs WHERE id = ?`, id)
        return scanJobRow(row)</span>
}

// GetJobBySandboxVMID loads the most recent job attached to a sandbox VMID.
func (s *Store) GetJobBySandboxVMID(ctx context.Context, vmid int) (models.Job, error) <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return models.Job{}, errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">if vmid &lt;= 0 </span><span class="cov0" title="0">{
                return models.Job{}, errors.New("vmid must be positive")
        }</span>
        <span class="cov0" title="0">row := s.DB.QueryRowContext(ctx, `SELECT id, repo_url, ref, profile, task, mode, ttl_minutes, keepalive, status, sandbox_vmid, created_at, updated_at, result_json
                FROM jobs WHERE sandbox_vmid = ?
                ORDER BY created_at DESC LIMIT 1`, vmid)
        return scanJobRow(row)</span>
}

// UpdateJobSandbox updates a job with the attached sandbox vmid.
func (s *Store) UpdateJobSandbox(ctx context.Context, id string, vmid int) (bool, error) <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return false, errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">if id == "" </span><span class="cov0" title="0">{
                return false, errors.New("job id is required")
        }</span>
        <span class="cov0" title="0">if vmid &lt;= 0 </span><span class="cov0" title="0">{
                return false, errors.New("vmid must be positive")
        }</span>
        <span class="cov0" title="0">updatedAt := formatTime(time.Now().UTC())
        res, err := s.DB.ExecContext(ctx, `UPDATE jobs SET sandbox_vmid = ?, updated_at = ? WHERE id = ?`, vmid, updatedAt, id)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("update job %s sandbox: %w", id, err)
        }</span>
        <span class="cov0" title="0">affected, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("rows affected job %s: %w", id, err)
        }</span>
        <span class="cov0" title="0">return affected &gt; 0, nil</span>
}

// UpdateJobStatus updates the status of a job.
func (s *Store) UpdateJobStatus(ctx context.Context, id string, status models.JobStatus) error <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">if id == "" </span><span class="cov0" title="0">{
                return errors.New("job id is required")
        }</span>
        <span class="cov0" title="0">if status == "" </span><span class="cov0" title="0">{
                return errors.New("job status is required")
        }</span>
        <span class="cov0" title="0">updatedAt := formatTime(time.Now().UTC())
        res, err := s.DB.ExecContext(ctx, `UPDATE jobs SET status = ?, updated_at = ? WHERE id = ?`, status, updatedAt, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("update job %s status: %w", id, err)
        }</span>
        <span class="cov0" title="0">affected, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("rows affected job %s: %w", id, err)
        }</span>
        <span class="cov0" title="0">if affected == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UpdateJobResult updates status and result_json for a job.
func (s *Store) UpdateJobResult(ctx context.Context, id string, status models.JobStatus, resultJSON string) error <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">if id == "" </span><span class="cov0" title="0">{
                return errors.New("job id is required")
        }</span>
        <span class="cov0" title="0">if status == "" </span><span class="cov0" title="0">{
                return errors.New("job status is required")
        }</span>
        <span class="cov0" title="0">var result interface{}
        if resultJSON != "" </span><span class="cov0" title="0">{
                result = resultJSON
        }</span>
        <span class="cov0" title="0">updatedAt := formatTime(time.Now().UTC())
        res, err := s.DB.ExecContext(ctx, `UPDATE jobs SET status = ?, result_json = ?, updated_at = ? WHERE id = ?`, status, result, updatedAt, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("update job %s result: %w", id, err)
        }</span>
        <span class="cov0" title="0">affected, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("rows affected job %s: %w", id, err)
        }</span>
        <span class="cov0" title="0">if affected == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func scanJobRow(scanner interface{ Scan(dest ...any) error }) (models.Job, error) <span class="cov0" title="0">{
        var job models.Job
        var task sql.NullString
        var mode sql.NullString
        var ttl sql.NullInt64
        var keepalive sql.NullBool
        var status string
        var sandbox sql.NullInt64
        var createdAt string
        var updatedAt string
        var result sql.NullString
        if err := scanner.Scan(
                &amp;job.ID,
                &amp;job.RepoURL,
                &amp;job.Ref,
                &amp;job.Profile,
                &amp;task,
                &amp;mode,
                &amp;ttl,
                &amp;keepalive,
                &amp;status,
                &amp;sandbox,
                &amp;createdAt,
                &amp;updatedAt,
                &amp;result,
        ); err != nil </span><span class="cov0" title="0">{
                return models.Job{}, err
        }</span>
        <span class="cov0" title="0">if task.Valid </span><span class="cov0" title="0">{
                job.Task = task.String
        }</span>
        <span class="cov0" title="0">if mode.Valid </span><span class="cov0" title="0">{
                job.Mode = mode.String
        }</span>
        <span class="cov0" title="0">if ttl.Valid </span><span class="cov0" title="0">{
                job.TTLMinutes = int(ttl.Int64)
        }</span>
        <span class="cov0" title="0">if keepalive.Valid </span><span class="cov0" title="0">{
                job.Keepalive = keepalive.Bool
        }</span>
        <span class="cov0" title="0">if status == "" </span><span class="cov0" title="0">{
                return models.Job{}, errors.New("job status missing")
        }</span>
        <span class="cov0" title="0">job.Status = models.JobStatus(status)
        if sandbox.Valid </span><span class="cov0" title="0">{
                value := int(sandbox.Int64)
                job.SandboxVMID = &amp;value
        }</span>
        <span class="cov0" title="0">var err error
        if createdAt != "" </span><span class="cov0" title="0">{
                job.CreatedAt, err = parseTime(createdAt)
                if err != nil </span><span class="cov0" title="0">{
                        return models.Job{}, fmt.Errorf("parse created_at: %w", err)
                }</span>
        }
        <span class="cov0" title="0">if updatedAt != "" </span><span class="cov0" title="0">{
                job.UpdatedAt, err = parseTime(updatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return models.Job{}, fmt.Errorf("parse updated_at: %w", err)
                }</span>
        }
        <span class="cov0" title="0">if result.Valid </span><span class="cov0" title="0">{
                job.ResultJSON = result.String
        }</span>
        <span class="cov0" title="0">return job, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package db

import (
        "database/sql"
        "errors"
        "fmt"
        "strings"
        "time"
)

type migration struct {
        version    int
        name       string
        statements []string
}

var migrations = []migration{
        {
                version: 1,
                name:    "init_core_tables",
                statements: []string{
                        `CREATE TABLE IF NOT EXISTS sandboxes (
                                vmid INTEGER PRIMARY KEY,
                                name TEXT NOT NULL,
                                profile TEXT NOT NULL,
                                state TEXT NOT NULL,
                                ip TEXT,
                                workspace_id TEXT,
                                keepalive INTEGER NOT NULL DEFAULT 0,
                                lease_expires_at TEXT,
                                created_at TEXT NOT NULL,
                                updated_at TEXT NOT NULL,
                                meta_json TEXT
                        )`,
                        `CREATE TABLE IF NOT EXISTS jobs (
                                id TEXT PRIMARY KEY,
                                repo_url TEXT NOT NULL,
                                ref TEXT NOT NULL,
                                profile TEXT NOT NULL,
                                status TEXT NOT NULL,
                                sandbox_vmid INTEGER,
                                created_at TEXT NOT NULL,
                                updated_at TEXT NOT NULL,
                                result_json TEXT
                        )`,
                        `CREATE TABLE IF NOT EXISTS profiles (
                                name TEXT PRIMARY KEY,
                                template_vmid INTEGER NOT NULL,
                                yaml TEXT NOT NULL,
                                updated_at TEXT NOT NULL
                        )`,
                        `CREATE TABLE IF NOT EXISTS workspaces (
                                id TEXT PRIMARY KEY,
                                name TEXT NOT NULL UNIQUE,
                                storage TEXT NOT NULL,
                                volid TEXT NOT NULL,
                                size_gb INTEGER NOT NULL,
                                attached_vmid INTEGER,
                                created_at TEXT NOT NULL,
                                updated_at TEXT NOT NULL,
                                meta_json TEXT
                        )`,
                        `CREATE TABLE IF NOT EXISTS bootstrap_tokens (
                                token TEXT PRIMARY KEY,
                                vmid INTEGER NOT NULL,
                                expires_at TEXT NOT NULL,
                                consumed_at TEXT,
                                created_at TEXT NOT NULL
                        )`,
                        `CREATE TABLE IF NOT EXISTS events (
                                id INTEGER PRIMARY KEY AUTOINCREMENT,
                                ts TEXT NOT NULL,
                                kind TEXT NOT NULL,
                                sandbox_vmid INTEGER,
                                job_id TEXT,
                                msg TEXT,
                                json TEXT
                        )`,
                        `CREATE INDEX IF NOT EXISTS idx_sandboxes_state ON sandboxes(state)`,
                        `CREATE INDEX IF NOT EXISTS idx_sandboxes_profile ON sandboxes(profile)`,
                        `CREATE INDEX IF NOT EXISTS idx_jobs_status ON jobs(status)`,
                        `CREATE INDEX IF NOT EXISTS idx_jobs_sandbox ON jobs(sandbox_vmid)`,
                        `CREATE INDEX IF NOT EXISTS idx_workspaces_attached ON workspaces(attached_vmid)`,
                        `CREATE INDEX IF NOT EXISTS idx_bootstrap_tokens_vmid ON bootstrap_tokens(vmid)`,
                        `CREATE INDEX IF NOT EXISTS idx_events_sandbox ON events(sandbox_vmid)`,
                        `CREATE INDEX IF NOT EXISTS idx_events_job ON events(job_id)`,
                },
        },
        {
                version: 2,
                name:    "add_job_spec_fields",
                statements: []string{
                        `ALTER TABLE jobs ADD COLUMN task TEXT`,
                        `ALTER TABLE jobs ADD COLUMN mode TEXT`,
                        `ALTER TABLE jobs ADD COLUMN ttl_minutes INTEGER`,
                        `ALTER TABLE jobs ADD COLUMN keepalive INTEGER NOT NULL DEFAULT 0`,
                },
        },
        {
                version: 3,
                name:    "add_artifacts",
                statements: []string{
                        `CREATE TABLE IF NOT EXISTS artifact_tokens (
                                token TEXT PRIMARY KEY,
                                job_id TEXT NOT NULL,
                                vmid INTEGER,
                                expires_at TEXT NOT NULL,
                                created_at TEXT NOT NULL,
                                last_used_at TEXT,
                                FOREIGN KEY(job_id) REFERENCES jobs(id) ON DELETE CASCADE
                        )`,
                        `CREATE INDEX IF NOT EXISTS idx_artifact_tokens_job ON artifact_tokens(job_id)`,
                        `CREATE INDEX IF NOT EXISTS idx_artifact_tokens_vmid ON artifact_tokens(vmid)`,
                        `CREATE TABLE IF NOT EXISTS artifacts (
                                id INTEGER PRIMARY KEY AUTOINCREMENT,
                                job_id TEXT NOT NULL,
                                vmid INTEGER,
                                name TEXT NOT NULL,
                                path TEXT NOT NULL,
                                size_bytes INTEGER NOT NULL,
                                sha256 TEXT NOT NULL,
                                mime TEXT,
                                created_at TEXT NOT NULL,
                                FOREIGN KEY(job_id) REFERENCES jobs(id) ON DELETE CASCADE
                        )`,
                        `CREATE INDEX IF NOT EXISTS idx_artifacts_job ON artifacts(job_id)`,
                        `CREATE INDEX IF NOT EXISTS idx_artifacts_vmid ON artifacts(vmid)`,
                },
        },
}

// Migrate runs any pending migrations against the provided database.
func Migrate(db *sql.DB) error <span class="cov2" title="2">{
        if db == nil </span><span class="cov0" title="0">{
                return errors.New("db is nil")
        }</span>
        <span class="cov2" title="2">if err := validateMigrations(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov2" title="2">if err := ensureSchemaMigrations(db); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov2" title="2">applied, err := loadAppliedVersions(db)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov2" title="2">if err := verifyKnownMigrations(applied); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov2" title="2">for _, m := range migrations </span><span class="cov5" title="6">{
                if _, ok := applied[m.version]; ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov5" title="6">if err := applyMigration(db, m); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov2" title="2">return nil</span>
}

func ensureSchemaMigrations(db *sql.DB) error <span class="cov2" title="2">{
        _, err := db.Exec(`CREATE TABLE IF NOT EXISTS schema_migrations (
                version INTEGER PRIMARY KEY,
                name TEXT NOT NULL,
                applied_at TEXT NOT NULL
        )`)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create schema_migrations: %w", err)
        }</span>
        <span class="cov2" title="2">return nil</span>
}

func loadAppliedVersions(db *sql.DB) (map[int]struct{}, error) <span class="cov2" title="2">{
        rows, err := db.Query(`SELECT version FROM schema_migrations ORDER BY version`)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list schema_migrations: %w", err)
        }</span>
        <span class="cov2" title="2">defer rows.Close()
        applied := make(map[int]struct{})
        for rows.Next() </span><span class="cov0" title="0">{
                var version int
                if err := rows.Scan(&amp;version); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("scan schema_migrations: %w", err)
                }</span>
                <span class="cov0" title="0">applied[version] = struct{}{}</span>
        }
        <span class="cov2" title="2">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("iterate schema_migrations: %w", err)
        }</span>
        <span class="cov2" title="2">return applied, nil</span>
}

func verifyKnownMigrations(applied map[int]struct{}) error <span class="cov2" title="2">{
        known := make(map[int]struct{}, len(migrations))
        for _, m := range migrations </span><span class="cov5" title="6">{
                known[m.version] = struct{}{}
        }</span>
        <span class="cov2" title="2">for version := range applied </span><span class="cov0" title="0">{
                if _, ok := known[version]; !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unknown schema migration version %d", version)
                }</span>
        }
        <span class="cov2" title="2">return nil</span>
}

func applyMigration(db *sql.DB, m migration) error <span class="cov5" title="6">{
        if len(m.statements) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("migration %d has no statements", m.version)
        }</span>
        <span class="cov5" title="6">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("begin migration %d: %w", m.version, err)
        }</span>
        <span class="cov5" title="6">for _, stmt := range m.statements </span><span class="cov10" title="48">{
                trimmed := strings.TrimSpace(stmt)
                if trimmed == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov10" title="48">if _, err := tx.Exec(trimmed); err != nil </span><span class="cov0" title="0">{
                        _ = tx.Rollback()
                        return fmt.Errorf("exec migration %d: %w", m.version, err)
                }</span>
        }
        <span class="cov5" title="6">appliedAt := time.Now().UTC().Format(time.RFC3339Nano)
        if _, err := tx.Exec(`INSERT INTO schema_migrations (version, name, applied_at) VALUES (?, ?, ?)`, m.version, m.name, appliedAt); err != nil </span><span class="cov0" title="0">{
                _ = tx.Rollback()
                return fmt.Errorf("record migration %d: %w", m.version, err)
        }</span>
        <span class="cov5" title="6">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("commit migration %d: %w", m.version, err)
        }</span>
        <span class="cov5" title="6">return nil</span>
}

func validateMigrations() error <span class="cov2" title="2">{
        if len(migrations) == 0 </span><span class="cov0" title="0">{
                return errors.New("no migrations defined")
        }</span>
        <span class="cov2" title="2">seen := make(map[int]struct{}, len(migrations))
        prev := 0
        for _, m := range migrations </span><span class="cov5" title="6">{
                if m.version &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("migration version must be positive: %d", m.version)
                }</span>
                <span class="cov5" title="6">if _, ok := seen[m.version]; ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("duplicate migration version %d", m.version)
                }</span>
                <span class="cov5" title="6">if m.version &lt; prev </span><span class="cov0" title="0">{
                        return fmt.Errorf("migration version %d is out of order", m.version)
                }</span>
                <span class="cov5" title="6">if strings.TrimSpace(m.name) == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("migration %d missing name", m.version)
                }</span>
                <span class="cov5" title="6">seen[m.version] = struct{}{}
                prev = m.version</span>
        }
        <span class="cov2" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package db

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "strings"
        "time"

        "github.com/agentlab/agentlab/internal/models"
)

const timeLayout = time.RFC3339Nano

// CreateSandbox inserts a new sandbox row.
func (s *Store) CreateSandbox(ctx context.Context, sandbox models.Sandbox) error <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">if sandbox.VMID &lt;= 0 </span><span class="cov0" title="0">{
                return errors.New("sandbox vmid is required")
        }</span>
        <span class="cov0" title="0">if sandbox.Name == "" </span><span class="cov0" title="0">{
                return errors.New("sandbox name is required")
        }</span>
        <span class="cov0" title="0">if sandbox.Profile == "" </span><span class="cov0" title="0">{
                return errors.New("sandbox profile is required")
        }</span>
        <span class="cov0" title="0">if sandbox.State == "" </span><span class="cov0" title="0">{
                return errors.New("sandbox state is required")
        }</span>
        <span class="cov0" title="0">now := time.Now().UTC()
        createdAt := sandbox.CreatedAt
        if createdAt.IsZero() </span><span class="cov0" title="0">{
                createdAt = now
        }</span>
        <span class="cov0" title="0">updatedAt := sandbox.LastUpdatedAt
        if updatedAt.IsZero() </span><span class="cov0" title="0">{
                updatedAt = createdAt
        }</span>
        <span class="cov0" title="0">var lease interface{}
        if !sandbox.LeaseExpires.IsZero() </span><span class="cov0" title="0">{
                lease = formatTime(sandbox.LeaseExpires)
        }</span>
        <span class="cov0" title="0">var workspace interface{}
        if sandbox.WorkspaceID != nil &amp;&amp; *sandbox.WorkspaceID != "" </span><span class="cov0" title="0">{
                workspace = *sandbox.WorkspaceID
        }</span>
        <span class="cov0" title="0">_, err := s.DB.ExecContext(ctx, `INSERT INTO sandboxes (
                vmid, name, profile, state, ip, workspace_id, keepalive, lease_expires_at, created_at, updated_at, meta_json
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                sandbox.VMID,
                sandbox.Name,
                sandbox.Profile,
                sandbox.State,
                nullIfEmpty(sandbox.IP),
                workspace,
                sandbox.Keepalive,
                lease,
                formatTime(createdAt),
                formatTime(updatedAt),
                nil,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("insert sandbox %d: %w", sandbox.VMID, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetSandbox loads a sandbox by vmid.
func (s *Store) GetSandbox(ctx context.Context, vmid int) (models.Sandbox, error) <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return models.Sandbox{}, errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">row := s.DB.QueryRowContext(ctx, `SELECT vmid, name, profile, state, ip, workspace_id, keepalive, lease_expires_at, created_at, updated_at
                FROM sandboxes WHERE vmid = ?`, vmid)
        return scanSandboxRow(row)</span>
}

// ListSandboxes returns all sandboxes ordered by created_at descending.
func (s *Store) ListSandboxes(ctx context.Context) ([]models.Sandbox, error) <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return nil, errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">rows, err := s.DB.QueryContext(ctx, `SELECT vmid, name, profile, state, ip, workspace_id, keepalive, lease_expires_at, created_at, updated_at
                FROM sandboxes ORDER BY created_at DESC`)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list sandboxes: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var out []models.Sandbox
        for rows.Next() </span><span class="cov0" title="0">{
                sb, err := scanSandboxRow(rows)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">out = append(out, sb)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("iterate sandboxes: %w", err)
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// MaxSandboxVMID returns the highest vmid stored, or 0 if none.
func (s *Store) MaxSandboxVMID(ctx context.Context) (int, error) <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return 0, errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">row := s.DB.QueryRowContext(ctx, `SELECT COALESCE(MAX(vmid), 0) FROM sandboxes`)
        var max int
        if err := row.Scan(&amp;max); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("scan max vmid: %w", err)
        }</span>
        <span class="cov0" title="0">return max, nil</span>
}

// ListExpiredSandboxes returns sandboxes with leases expired at or before now.
func (s *Store) ListExpiredSandboxes(ctx context.Context, now time.Time) ([]models.Sandbox, error) <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return nil, errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">cutoff := formatTime(now)
        rows, err := s.DB.QueryContext(ctx, `SELECT vmid, name, profile, state, ip, workspace_id, keepalive, lease_expires_at, created_at, updated_at
                FROM sandboxes
                WHERE lease_expires_at IS NOT NULL AND lease_expires_at &lt;= ? AND state != ?`, cutoff, models.SandboxDestroyed)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list expired sandboxes: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var out []models.Sandbox
        for rows.Next() </span><span class="cov0" title="0">{
                sb, err := scanSandboxRow(rows)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">out = append(out, sb)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("iterate expired sandboxes: %w", err)
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// UpdateSandboxState performs a compare-and-swap state transition.
func (s *Store) UpdateSandboxState(ctx context.Context, vmid int, from, to models.SandboxState) (bool, error) <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return false, errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">updatedAt := formatTime(time.Now().UTC())
        res, err := s.DB.ExecContext(ctx, `UPDATE sandboxes SET state = ?, updated_at = ? WHERE vmid = ? AND state = ?`,
                to, updatedAt, vmid, from)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("update sandbox %d state: %w", vmid, err)
        }</span>
        <span class="cov0" title="0">affected, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("rows affected sandbox %d: %w", vmid, err)
        }</span>
        <span class="cov0" title="0">return affected &gt; 0, nil</span>
}

// UpdateSandboxLease updates the lease expiration timestamp.
func (s *Store) UpdateSandboxLease(ctx context.Context, vmid int, leaseExpiresAt time.Time) error <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">var lease interface{}
        if !leaseExpiresAt.IsZero() </span><span class="cov0" title="0">{
                lease = formatTime(leaseExpiresAt)
        }</span>
        <span class="cov0" title="0">updatedAt := formatTime(time.Now().UTC())
        _, err := s.DB.ExecContext(ctx, `UPDATE sandboxes SET lease_expires_at = ?, updated_at = ? WHERE vmid = ?`, lease, updatedAt, vmid)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("update sandbox %d lease: %w", vmid, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UpdateSandboxIP updates the IP address for a sandbox.
func (s *Store) UpdateSandboxIP(ctx context.Context, vmid int, ip string) error <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">if vmid &lt;= 0 </span><span class="cov0" title="0">{
                return errors.New("vmid must be positive")
        }</span>
        <span class="cov0" title="0">updatedAt := formatTime(time.Now().UTC())
        _, err := s.DB.ExecContext(ctx, `UPDATE sandboxes SET ip = ?, updated_at = ? WHERE vmid = ?`,
                nullIfEmpty(ip),
                updatedAt,
                vmid,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("update sandbox %d ip: %w", vmid, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UpdateSandboxWorkspace updates the workspace id for a sandbox.
func (s *Store) UpdateSandboxWorkspace(ctx context.Context, vmid int, workspaceID *string) error <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">if vmid &lt;= 0 </span><span class="cov0" title="0">{
                return errors.New("vmid must be positive")
        }</span>
        <span class="cov0" title="0">var workspace interface{}
        if workspaceID != nil &amp;&amp; strings.TrimSpace(*workspaceID) != "" </span><span class="cov0" title="0">{
                workspace = strings.TrimSpace(*workspaceID)
        }</span>
        <span class="cov0" title="0">updatedAt := formatTime(time.Now().UTC())
        res, err := s.DB.ExecContext(ctx, `UPDATE sandboxes SET workspace_id = ?, updated_at = ? WHERE vmid = ?`,
                workspace,
                updatedAt,
                vmid,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("update sandbox %d workspace: %w", vmid, err)
        }</span>
        <span class="cov0" title="0">affected, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("rows affected sandbox %d workspace: %w", vmid, err)
        }</span>
        <span class="cov0" title="0">if affected == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// RecordEvent inserts an event row.
func (s *Store) RecordEvent(ctx context.Context, kind string, sandboxVMID *int, jobID *string, msg string, jsonPayload string) error <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">if kind == "" </span><span class="cov0" title="0">{
                return errors.New("event kind is required")
        }</span>
        <span class="cov0" title="0">now := formatTime(time.Now().UTC())
        var vmid sql.NullInt64
        if sandboxVMID != nil </span><span class="cov0" title="0">{
                vmid = sql.NullInt64{Valid: true, Int64: int64(*sandboxVMID)}
        }</span>
        <span class="cov0" title="0">var job sql.NullString
        if jobID != nil &amp;&amp; *jobID != "" </span><span class="cov0" title="0">{
                job = sql.NullString{Valid: true, String: *jobID}
        }</span>
        <span class="cov0" title="0">var msgVal interface{}
        if msg != "" </span><span class="cov0" title="0">{
                msgVal = msg
        }</span>
        <span class="cov0" title="0">var jsonVal interface{}
        if jsonPayload != "" </span><span class="cov0" title="0">{
                jsonVal = jsonPayload
        }</span>
        <span class="cov0" title="0">_, err := s.DB.ExecContext(ctx, `INSERT INTO events (ts, kind, sandbox_vmid, job_id, msg, json) VALUES (?, ?, ?, ?, ?, ?)`,
                now, kind, vmid, job, msgVal, jsonVal)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("insert event %q: %w", kind, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func scanSandboxRow(scanner interface{ Scan(dest ...any) error }) (models.Sandbox, error) <span class="cov0" title="0">{
        var sb models.Sandbox
        var state string
        var ip sql.NullString
        var workspace sql.NullString
        var keepalive sql.NullBool
        var lease sql.NullString
        var createdAt string
        var updatedAt string
        if err := scanner.Scan(&amp;sb.VMID, &amp;sb.Name, &amp;sb.Profile, &amp;state, &amp;ip, &amp;workspace, &amp;keepalive, &amp;lease, &amp;createdAt, &amp;updatedAt); err != nil </span><span class="cov0" title="0">{
                return models.Sandbox{}, err
        }</span>
        <span class="cov0" title="0">if state == "" </span><span class="cov0" title="0">{
                return models.Sandbox{}, errors.New("sandbox state missing")
        }</span>
        <span class="cov0" title="0">sb.State = models.SandboxState(state)
        if ip.Valid </span><span class="cov0" title="0">{
                sb.IP = ip.String
        }</span>
        <span class="cov0" title="0">if workspace.Valid </span><span class="cov0" title="0">{
                value := workspace.String
                sb.WorkspaceID = &amp;value
        }</span>
        <span class="cov0" title="0">if keepalive.Valid </span><span class="cov0" title="0">{
                sb.Keepalive = keepalive.Bool
        }</span>
        <span class="cov0" title="0">if lease.Valid </span><span class="cov0" title="0">{
                parsed, err := parseTime(lease.String)
                if err != nil </span><span class="cov0" title="0">{
                        return models.Sandbox{}, fmt.Errorf("parse lease_expires_at: %w", err)
                }</span>
                <span class="cov0" title="0">sb.LeaseExpires = parsed</span>
        }
        <span class="cov0" title="0">var err error
        if createdAt != "" </span><span class="cov0" title="0">{
                sb.CreatedAt, err = parseTime(createdAt)
                if err != nil </span><span class="cov0" title="0">{
                        return models.Sandbox{}, fmt.Errorf("parse created_at: %w", err)
                }</span>
        }
        <span class="cov0" title="0">if updatedAt != "" </span><span class="cov0" title="0">{
                sb.LastUpdatedAt, err = parseTime(updatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return models.Sandbox{}, fmt.Errorf("parse updated_at: %w", err)
                }</span>
        }
        <span class="cov0" title="0">return sb, nil</span>
}

func parseTime(value string) (time.Time, error) <span class="cov0" title="0">{
        if value == "" </span><span class="cov0" title="0">{
                return time.Time{}, nil
        }</span>
        <span class="cov0" title="0">parsed, err := time.Parse(timeLayout, value)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, err
        }</span>
        <span class="cov0" title="0">return parsed, nil</span>
}

func formatTime(value time.Time) string <span class="cov10" title="16">{
        return value.UTC().Format(timeLayout)
}</span>

func nullIfEmpty(value string) interface{} <span class="cov0" title="0">{
        if value == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return value</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package db

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "strings"
        "time"

        "github.com/agentlab/agentlab/internal/models"
)

// CreateWorkspace inserts a new workspace row.
func (s *Store) CreateWorkspace(ctx context.Context, workspace models.Workspace) error <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(workspace.ID) == "" </span><span class="cov0" title="0">{
                return errors.New("workspace id is required")
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(workspace.Name) == "" </span><span class="cov0" title="0">{
                return errors.New("workspace name is required")
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(workspace.Storage) == "" </span><span class="cov0" title="0">{
                return errors.New("workspace storage is required")
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(workspace.VolumeID) == "" </span><span class="cov0" title="0">{
                return errors.New("workspace volume id is required")
        }</span>
        <span class="cov0" title="0">if workspace.SizeGB &lt;= 0 </span><span class="cov0" title="0">{
                return errors.New("workspace size_gb must be positive")
        }</span>
        <span class="cov0" title="0">now := time.Now().UTC()
        createdAt := workspace.CreatedAt
        if createdAt.IsZero() </span><span class="cov0" title="0">{
                createdAt = now
        }</span>
        <span class="cov0" title="0">updatedAt := workspace.LastUpdated
        if updatedAt.IsZero() </span><span class="cov0" title="0">{
                updatedAt = createdAt
        }</span>
        <span class="cov0" title="0">var attached interface{}
        if workspace.AttachedVM != nil &amp;&amp; *workspace.AttachedVM &gt; 0 </span><span class="cov0" title="0">{
                attached = *workspace.AttachedVM
        }</span>
        <span class="cov0" title="0">_, err := s.DB.ExecContext(ctx, `INSERT INTO workspaces (
                id, name, storage, volid, size_gb, attached_vmid, created_at, updated_at, meta_json
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                workspace.ID,
                workspace.Name,
                workspace.Storage,
                workspace.VolumeID,
                workspace.SizeGB,
                attached,
                formatTime(createdAt),
                formatTime(updatedAt),
                nil,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("insert workspace %s: %w", workspace.ID, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetWorkspace loads a workspace by id.
func (s *Store) GetWorkspace(ctx context.Context, id string) (models.Workspace, error) <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return models.Workspace{}, errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">row := s.DB.QueryRowContext(ctx, `SELECT id, name, storage, volid, size_gb, attached_vmid, created_at, updated_at
                FROM workspaces WHERE id = ?`, id)
        return scanWorkspaceRow(row)</span>
}

// GetWorkspaceByName loads a workspace by name.
func (s *Store) GetWorkspaceByName(ctx context.Context, name string) (models.Workspace, error) <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return models.Workspace{}, errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">row := s.DB.QueryRowContext(ctx, `SELECT id, name, storage, volid, size_gb, attached_vmid, created_at, updated_at
                FROM workspaces WHERE name = ?`, name)
        return scanWorkspaceRow(row)</span>
}

// GetWorkspaceByAttachedVMID loads a workspace attached to a vmid.
func (s *Store) GetWorkspaceByAttachedVMID(ctx context.Context, vmid int) (models.Workspace, error) <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return models.Workspace{}, errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">if vmid &lt;= 0 </span><span class="cov0" title="0">{
                return models.Workspace{}, errors.New("vmid must be positive")
        }</span>
        <span class="cov0" title="0">row := s.DB.QueryRowContext(ctx, `SELECT id, name, storage, volid, size_gb, attached_vmid, created_at, updated_at
                FROM workspaces WHERE attached_vmid = ?`, vmid)
        return scanWorkspaceRow(row)</span>
}

// ListWorkspaces returns all workspaces ordered by created_at descending.
func (s *Store) ListWorkspaces(ctx context.Context) ([]models.Workspace, error) <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return nil, errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">rows, err := s.DB.QueryContext(ctx, `SELECT id, name, storage, volid, size_gb, attached_vmid, created_at, updated_at
                FROM workspaces ORDER BY created_at DESC`)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list workspaces: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var out []models.Workspace
        for rows.Next() </span><span class="cov0" title="0">{
                ws, err := scanWorkspaceRow(rows)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">out = append(out, ws)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("iterate workspaces: %w", err)
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// AttachWorkspace sets attached_vmid if currently unattached.
func (s *Store) AttachWorkspace(ctx context.Context, id string, vmid int) (bool, error) <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return false, errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(id) == "" </span><span class="cov0" title="0">{
                return false, errors.New("workspace id is required")
        }</span>
        <span class="cov0" title="0">if vmid &lt;= 0 </span><span class="cov0" title="0">{
                return false, errors.New("vmid must be positive")
        }</span>
        <span class="cov0" title="0">updatedAt := formatTime(time.Now().UTC())
        res, err := s.DB.ExecContext(ctx, `UPDATE workspaces SET attached_vmid = ?, updated_at = ?
                WHERE id = ? AND attached_vmid IS NULL`, vmid, updatedAt, id)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("attach workspace %s: %w", id, err)
        }</span>
        <span class="cov0" title="0">affected, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("rows affected attach workspace %s: %w", id, err)
        }</span>
        <span class="cov0" title="0">return affected &gt; 0, nil</span>
}

// DetachWorkspace clears attached_vmid if it matches the provided vmid.
func (s *Store) DetachWorkspace(ctx context.Context, id string, vmid int) (bool, error) <span class="cov0" title="0">{
        if s == nil || s.DB == nil </span><span class="cov0" title="0">{
                return false, errors.New("db store is nil")
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(id) == "" </span><span class="cov0" title="0">{
                return false, errors.New("workspace id is required")
        }</span>
        <span class="cov0" title="0">if vmid &lt;= 0 </span><span class="cov0" title="0">{
                return false, errors.New("vmid must be positive")
        }</span>
        <span class="cov0" title="0">updatedAt := formatTime(time.Now().UTC())
        res, err := s.DB.ExecContext(ctx, `UPDATE workspaces SET attached_vmid = NULL, updated_at = ?
                WHERE id = ? AND attached_vmid = ?`, updatedAt, id, vmid)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("detach workspace %s: %w", id, err)
        }</span>
        <span class="cov0" title="0">affected, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("rows affected detach workspace %s: %w", id, err)
        }</span>
        <span class="cov0" title="0">return affected &gt; 0, nil</span>
}

func scanWorkspaceRow(scanner interface{ Scan(dest ...any) error }) (models.Workspace, error) <span class="cov0" title="0">{
        var ws models.Workspace
        var attached sql.NullInt64
        var createdAt string
        var updatedAt string
        if err := scanner.Scan(&amp;ws.ID, &amp;ws.Name, &amp;ws.Storage, &amp;ws.VolumeID, &amp;ws.SizeGB, &amp;attached, &amp;createdAt, &amp;updatedAt); err != nil </span><span class="cov0" title="0">{
                return models.Workspace{}, err
        }</span>
        <span class="cov0" title="0">if attached.Valid </span><span class="cov0" title="0">{
                value := int(attached.Int64)
                ws.AttachedVM = &amp;value
        }</span>
        <span class="cov0" title="0">var err error
        if createdAt != "" </span><span class="cov0" title="0">{
                ws.CreatedAt, err = parseTime(createdAt)
                if err != nil </span><span class="cov0" title="0">{
                        return models.Workspace{}, fmt.Errorf("parse created_at: %w", err)
                }</span>
        }
        <span class="cov0" title="0">if updatedAt != "" </span><span class="cov0" title="0">{
                ws.LastUpdated, err = parseTime(updatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return models.Workspace{}, fmt.Errorf("parse updated_at: %w", err)
                }</span>
        }
        <span class="cov0" title="0">return ws, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package proxmox

import (
        "crypto/rand"
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
)

const (
        defaultSnippetStorage = "local"
        defaultSnippetDir     = "/var/lib/vz/snippets"
)

// SnippetInput describes the minimal data needed to build a cloud-init snippet.
type SnippetInput struct {
        VMID           VMID
        Hostname       string
        SSHPublicKey   string
        BootstrapToken string
        ControllerURL  string
}

// CloudInitSnippet represents a stored snippet file and its Proxmox reference.
type CloudInitSnippet struct {
        VMID        VMID
        Filename    string
        FullPath    string
        Storage     string
        StoragePath string
}

// SnippetStore manages cloud-init snippet files for Proxmox.
type SnippetStore struct {
        Storage string
        Dir     string
        Rand    io.Reader
}

// Create writes a cloud-init user-data snippet and returns its storage reference.
func (s SnippetStore) Create(input SnippetInput) (CloudInitSnippet, error) <span class="cov10" title="3">{
        if input.VMID &lt;= 0 </span><span class="cov0" title="0">{
                return CloudInitSnippet{}, errors.New("vmid must be greater than zero")
        }</span>
        <span class="cov10" title="3">hostname := strings.TrimSpace(input.Hostname)
        if hostname == "" </span><span class="cov6" title="2">{
                hostname = fmt.Sprintf("sandbox-%d", input.VMID)
        }</span>
        <span class="cov10" title="3">if strings.ContainsAny(hostname, " \t\n") </span><span class="cov0" title="0">{
                return CloudInitSnippet{}, fmt.Errorf("hostname contains whitespace: %q", hostname)
        }</span>
        <span class="cov10" title="3">sshKey := strings.TrimSpace(input.SSHPublicKey)
        if sshKey == "" </span><span class="cov0" title="0">{
                return CloudInitSnippet{}, errors.New("ssh public key is required")
        }</span>
        <span class="cov10" title="3">if strings.ContainsAny(sshKey, "\n\r") </span><span class="cov0" title="0">{
                return CloudInitSnippet{}, errors.New("ssh public key must be a single line")
        }</span>
        <span class="cov10" title="3">token := strings.TrimSpace(input.BootstrapToken)
        if token == "" </span><span class="cov1" title="1">{
                return CloudInitSnippet{}, errors.New("bootstrap token is required")
        }</span>
        <span class="cov6" title="2">controller := strings.TrimSpace(input.ControllerURL)
        if controller == "" </span><span class="cov0" title="0">{
                return CloudInitSnippet{}, errors.New("controller URL is required")
        }</span>

        <span class="cov6" title="2">storage := strings.TrimSpace(s.Storage)
        if storage == "" </span><span class="cov1" title="1">{
                storage = defaultSnippetStorage
        }</span>
        <span class="cov6" title="2">dir := strings.TrimSpace(s.Dir)
        if dir == "" </span><span class="cov0" title="0">{
                dir = defaultSnippetDir
        }</span>

        <span class="cov6" title="2">content, err := renderCloudInitUserData(hostname, sshKey, token, controller, int(input.VMID))
        if err != nil </span><span class="cov0" title="0">{
                return CloudInitSnippet{}, err
        }</span>
        <span class="cov6" title="2">if err := os.MkdirAll(dir, 0o755); err != nil </span><span class="cov0" title="0">{
                return CloudInitSnippet{}, fmt.Errorf("create snippets dir: %w", err)
        }</span>

        <span class="cov6" title="2">for attempt := 0; attempt &lt; 5; attempt++ </span><span class="cov6" title="2">{
                suffix, err := randomSuffix(s.randReader(), 8)
                if err != nil </span><span class="cov0" title="0">{
                        return CloudInitSnippet{}, fmt.Errorf("generate suffix: %w", err)
                }</span>
                <span class="cov6" title="2">filename := fmt.Sprintf("agentlab-%d-%s.yaml", input.VMID, suffix)
                fullPath := filepath.Join(dir, filename)
                file, err := os.OpenFile(fullPath, os.O_WRONLY|os.O_CREATE|os.O_EXCL, 0o600)
                if err != nil </span><span class="cov0" title="0">{
                        if os.IsExist(err) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">return CloudInitSnippet{}, fmt.Errorf("create snippet file: %w", err)</span>
                }
                <span class="cov6" title="2">_, writeErr := io.WriteString(file, content)
                closeErr := file.Close()
                if writeErr != nil </span><span class="cov0" title="0">{
                        _ = os.Remove(fullPath)
                        return CloudInitSnippet{}, fmt.Errorf("write snippet: %w", writeErr)
                }</span>
                <span class="cov6" title="2">if closeErr != nil </span><span class="cov0" title="0">{
                        _ = os.Remove(fullPath)
                        return CloudInitSnippet{}, fmt.Errorf("close snippet: %w", closeErr)
                }</span>
                <span class="cov6" title="2">storagePath := fmt.Sprintf("%s:snippets/%s", storage, filename)
                return CloudInitSnippet{
                        VMID:        input.VMID,
                        Filename:    filename,
                        FullPath:    fullPath,
                        Storage:     storage,
                        StoragePath: storagePath,
                }, nil</span>
        }

        <span class="cov0" title="0">return CloudInitSnippet{}, errors.New("unable to create unique snippet filename")</span>
}

// Delete removes the snippet file from disk.
func (s SnippetStore) Delete(snippet CloudInitSnippet) error <span class="cov6" title="2">{
        path := snippet.FullPath
        if path == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov6" title="2">if err := os.Remove(path); err != nil </span><span class="cov1" title="1">{
                if os.IsNotExist(err) </span><span class="cov1" title="1">{
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("remove snippet: %w", err)</span>
        }
        <span class="cov1" title="1">return nil</span>
}

func (s SnippetStore) randReader() io.Reader <span class="cov6" title="2">{
        if s.Rand != nil </span><span class="cov6" title="2">{
                return s.Rand
        }</span>
        <span class="cov0" title="0">return rand.Reader</span>
}

func randomSuffix(r io.Reader, bytesLen int) (string, error) <span class="cov6" title="2">{
        if bytesLen &lt;= 0 </span><span class="cov0" title="0">{
                return "", errors.New("suffix length must be positive")
        }</span>
        <span class="cov6" title="2">buf := make([]byte, bytesLen)
        if _, err := io.ReadFull(r, buf); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov6" title="2">return hex.EncodeToString(buf), nil</span>
}

func renderCloudInitUserData(hostname, sshKey, token, controller string, vmid int) (string, error) <span class="cov6" title="2">{
        payload := struct {
                Token      string `json:"token"`
                Controller string `json:"controller"`
                VMID       int    `json:"vmid"`
        }{
                Token:      token,
                Controller: controller,
                VMID:       vmid,
        }
        jsonBytes, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("marshal bootstrap payload: %w", err)
        }</span>

        <span class="cov6" title="2">content := strings.Join([]string{
                "#cloud-config",
                "hostname: " + hostname,
                "users:",
                "  - name: agent",
                "    ssh_authorized_keys:",
                "      - " + sshKey,
                "write_files:",
                "  - path: /etc/agentlab/bootstrap.json",
                "    owner: agent:agent",
                "    permissions: \"0600\"",
                "    content: |",
                "      " + string(jsonBytes),
                "",
        }, "\n")

        return content, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package proxmox

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "net"
        "os"
        "os/exec"
        "path/filepath"
        "sort"
        "strconv"
        "strings"
        "time"
)

var ErrGuestIPNotFound = errors.New("guest IP not found")

// CommandRunner executes external commands and returns stdout.
type CommandRunner interface {
        Run(ctx context.Context, name string, args ...string) (string, error)
}

// ExecRunner runs commands via os/exec.
type ExecRunner struct{}

func (ExecRunner) Run(ctx context.Context, name string, args ...string) (string, error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, name, args...)
        var stdout bytes.Buffer
        var stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                errMsg := strings.TrimSpace(stderr.String())
                if errMsg != "" </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("command %s %s failed: %w: %s", name, strings.Join(args, " "), err, errMsg)
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("command %s %s failed: %w", name, strings.Join(args, " "), err)</span>
        }
        <span class="cov0" title="0">return stdout.String(), nil</span>
}

// ShellBackend implements Backend using qm and pvesh commands.
type ShellBackend struct {
        Node               string
        AgentCIDR          string
        QmPath             string
        PveShPath          string
        PveSmPath          string
        Runner             CommandRunner
        CommandTimeout     time.Duration
        GuestIPAttempts    int
        GuestIPInitialWait time.Duration
        GuestIPMaxWait     time.Duration
        DHCPLeasePaths     []string
        Sleep              func(ctx context.Context, d time.Duration) error
}

var _ Backend = (*ShellBackend)(nil)

func (b *ShellBackend) Clone(ctx context.Context, template VMID, target VMID, name string) error <span class="cov1" title="1">{
        args := []string{"clone", strconv.Itoa(int(template)), strconv.Itoa(int(target)), "--full", "0"}
        if name != "" </span><span class="cov1" title="1">{
                args = append(args, "--name", name)
        }</span>
        <span class="cov1" title="1">_, err := b.run(ctx, b.qmPath(), args...)
        return err</span>
}

func (b *ShellBackend) Configure(ctx context.Context, vmid VMID, cfg VMConfig) error <span class="cov1" title="1">{
        args := []string{"set", strconv.Itoa(int(vmid))}
        if cfg.Name != "" </span><span class="cov1" title="1">{
                args = append(args, "--name", cfg.Name)
        }</span>
        <span class="cov1" title="1">if cfg.Cores &gt; 0 </span><span class="cov1" title="1">{
                args = append(args, "--cores", strconv.Itoa(cfg.Cores))
        }</span>
        <span class="cov1" title="1">if cfg.MemoryMB &gt; 0 </span><span class="cov1" title="1">{
                args = append(args, "--memory", strconv.Itoa(cfg.MemoryMB))
        }</span>
        <span class="cov1" title="1">if cfg.CPUPinning != "" </span><span class="cov1" title="1">{
                args = append(args, "--cpulist", cfg.CPUPinning)
        }</span>
        <span class="cov1" title="1">if cfg.Bridge != "" || cfg.NetModel != "" </span><span class="cov1" title="1">{
                net0 := buildNet0(cfg.NetModel, cfg.Bridge)
                args = append(args, "--net0", net0)
        }</span>
        <span class="cov1" title="1">if cfg.CloudInit != "" </span><span class="cov1" title="1">{
                args = append(args, "--cicustom", formatCICustom(cfg.CloudInit))
        }</span>
        <span class="cov1" title="1">if len(args) == 2 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov1" title="1">_, err := b.run(ctx, b.qmPath(), args...)
        return err</span>
}

func (b *ShellBackend) Start(ctx context.Context, vmid VMID) error <span class="cov0" title="0">{
        _, err := b.run(ctx, b.qmPath(), "start", strconv.Itoa(int(vmid)))
        return err
}</span>

func (b *ShellBackend) Stop(ctx context.Context, vmid VMID) error <span class="cov0" title="0">{
        _, err := b.run(ctx, b.qmPath(), "stop", strconv.Itoa(int(vmid)))
        if err != nil </span><span class="cov0" title="0">{
                if isMissingVMError(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("%w: %v", ErrVMNotFound, err)
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (b *ShellBackend) Destroy(ctx context.Context, vmid VMID) error <span class="cov0" title="0">{
        _, err := b.run(ctx, b.qmPath(), "destroy", strconv.Itoa(int(vmid)), "--purge", "1")
        if err != nil </span><span class="cov0" title="0">{
                if isMissingVMError(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("%w: %v", ErrVMNotFound, err)
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (b *ShellBackend) Status(ctx context.Context, vmid VMID) (Status, error) <span class="cov1" title="1">{
        out, err := b.run(ctx, b.qmPath(), "status", strconv.Itoa(int(vmid)))
        if err != nil </span><span class="cov0" title="0">{
                return StatusUnknown, err
        }</span>
        <span class="cov1" title="1">status, err := parseStatus(out)
        if err != nil </span><span class="cov0" title="0">{
                return StatusUnknown, err
        }</span>
        <span class="cov1" title="1">return status, nil</span>
}

func (b *ShellBackend) GuestIP(ctx context.Context, vmid VMID) (string, error) <span class="cov5" title="4">{
        node, err := b.ensureNode(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov5" title="4">ip, err := b.pollGuestAgentIP(ctx, node, vmid)
        if err == nil </span><span class="cov4" title="3">{
                return ip, nil
        }</span>
        <span class="cov1" title="1">if ctx.Err() != nil </span><span class="cov0" title="0">{
                return "", ctx.Err()
        }</span>
        <span class="cov1" title="1">qgaErr := err
        ip, dhcpErr := b.dhcpLeaseIP(ctx, vmid)
        if dhcpErr == nil </span><span class="cov1" title="1">{
                return ip, nil
        }</span>
        <span class="cov0" title="0">if errors.Is(dhcpErr, ErrGuestIPNotFound) </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%w: qemu-guest-agent=%v dhcp=%v", ErrGuestIPNotFound, qgaErr, dhcpErr)
        }</span>
        <span class="cov0" title="0">return "", dhcpErr</span>
}

func (b *ShellBackend) runner() CommandRunner <span class="cov10" title="16">{
        if b.Runner != nil </span><span class="cov10" title="16">{
                return b.Runner
        }</span>
        <span class="cov0" title="0">return ExecRunner{}</span>
}

func (b *ShellBackend) qmPath() string <span class="cov6" title="6">{
        if b.QmPath != "" </span><span class="cov0" title="0">{
                return b.QmPath
        }</span>
        <span class="cov6" title="6">return "qm"</span>
}

func (b *ShellBackend) pveshPath() string <span class="cov7" title="8">{
        if b.PveShPath != "" </span><span class="cov0" title="0">{
                return b.PveShPath
        }</span>
        <span class="cov7" title="8">return "pvesh"</span>
}

func (b *ShellBackend) pvesmPath() string <span class="cov3" title="2">{
        if b.PveSmPath != "" </span><span class="cov0" title="0">{
                return b.PveSmPath
        }</span>
        <span class="cov3" title="2">return "pvesm"</span>
}

func (b *ShellBackend) pollGuestAgentIP(ctx context.Context, node string, vmid VMID) (string, error) <span class="cov5" title="4">{
        attempts := b.guestIPAttempts()
        wait := b.guestIPInitialWait()
        maxWait := b.guestIPMaxWait()
        var lastErr error
        for i := 0; i &lt; attempts; i++ </span><span class="cov6" title="6">{
                ip, err := b.guestAgentIP(ctx, node, vmid)
                if err == nil &amp;&amp; ip != "" </span><span class="cov4" title="3">{
                        return ip, nil
                }</span>
                <span class="cov4" title="3">if err != nil </span><span class="cov4" title="3">{
                        lastErr = err
                }</span> else<span class="cov0" title="0"> {
                        lastErr = ErrGuestIPNotFound
                }</span>
                <span class="cov4" title="3">if i == attempts-1 </span><span class="cov1" title="1">{
                        break</span>
                }
                <span class="cov3" title="2">if err := b.sleep(ctx, wait); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov3" title="2">wait = nextBackoff(wait, maxWait)</span>
        }
        <span class="cov1" title="1">if lastErr == nil </span><span class="cov0" title="0">{
                lastErr = ErrGuestIPNotFound
        }</span>
        <span class="cov1" title="1">return "", lastErr</span>
}

func (b *ShellBackend) guestAgentIP(ctx context.Context, node string, vmid VMID) (string, error) <span class="cov6" title="6">{
        path := fmt.Sprintf("/nodes/%s/qemu/%d/agent/network-get-interfaces", node, vmid)
        out, err := b.run(ctx, b.pveshPath(), "get", path, "--output-format", "json")
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>
        <span class="cov6" title="5">ips, err := parseAgentIPs(out)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov6" title="5">return b.selectIP(ips)</span>
}

func (b *ShellBackend) selectIP(ips []net.IP) (string, error) <span class="cov6" title="5">{
        if len(ips) == 0 </span><span class="cov3" title="2">{
                return "", ErrGuestIPNotFound
        }</span>
        <span class="cov4" title="3">if b.AgentCIDR != "" </span><span class="cov4" title="3">{
                ip, err := selectIPByCIDR(ips, b.AgentCIDR)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov4" title="3">if ip == "" </span><span class="cov0" title="0">{
                        return "", ErrGuestIPNotFound
                }</span>
                <span class="cov4" title="3">return ip, nil</span>
        }
        <span class="cov0" title="0">return ips[0].String(), nil</span>
}

func (b *ShellBackend) dhcpLeaseIP(ctx context.Context, vmid VMID) (string, error) <span class="cov1" title="1">{
        var netblock *net.IPNet
        if b.AgentCIDR != "" </span><span class="cov1" title="1">{
                _, parsed, err := net.ParseCIDR(b.AgentCIDR)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("invalid agent CIDR %q: %w", b.AgentCIDR, err)
                }</span>
                <span class="cov1" title="1">netblock = parsed</span>
        }
        <span class="cov1" title="1">out, err := b.run(ctx, b.qmPath(), "config", strconv.Itoa(int(vmid)))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">macs := parseNetMACs(out)
        if len(macs) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%w: no MAC addresses found", ErrGuestIPNotFound)
        }</span>
        <span class="cov1" title="1">leaseFiles := b.leasePaths()
        if len(leaseFiles) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%w: no DHCP lease files configured", ErrGuestIPNotFound)
        }</span>
        <span class="cov1" title="1">var readErr error
        for _, path := range leaseFiles </span><span class="cov1" title="1">{
                content, err := os.ReadFile(path)
                if err != nil </span><span class="cov0" title="0">{
                        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">readErr = err
                        continue</span>
                }
                <span class="cov1" title="1">if ip := findLeaseIP(content, macs, netblock); ip != "" </span><span class="cov1" title="1">{
                        return ip, nil
                }</span>
        }
        <span class="cov0" title="0">if readErr != nil </span><span class="cov0" title="0">{
                return "", readErr
        }</span>
        <span class="cov0" title="0">return "", ErrGuestIPNotFound</span>
}

func (b *ShellBackend) CreateVolume(ctx context.Context, storage, name string, sizeGB int) (string, error) <span class="cov1" title="1">{
        storage = strings.TrimSpace(storage)
        if storage == "" </span><span class="cov0" title="0">{
                return "", errors.New("storage is required")
        }</span>
        <span class="cov1" title="1">name = strings.TrimSpace(name)
        if name == "" </span><span class="cov0" title="0">{
                return "", errors.New("volume name is required")
        }</span>
        <span class="cov1" title="1">if sizeGB &lt;= 0 </span><span class="cov0" title="0">{
                return "", errors.New("size_gb must be positive")
        }</span>
        <span class="cov1" title="1">sizeArg := fmt.Sprintf("%dG", sizeGB)
        out, err := b.run(ctx, b.pvesmPath(), "alloc", storage, "0", name, sizeArg)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">volid := strings.TrimSpace(out)
        if volid == "" </span><span class="cov0" title="0">{
                return "", errors.New("empty volume id")
        }</span>
        <span class="cov1" title="1">return volid, nil</span>
}

func (b *ShellBackend) AttachVolume(ctx context.Context, vmid VMID, volumeID, slot string) error <span class="cov1" title="1">{
        volumeID = strings.TrimSpace(volumeID)
        if volumeID == "" </span><span class="cov0" title="0">{
                return errors.New("volume id is required")
        }</span>
        <span class="cov1" title="1">slot = strings.TrimSpace(slot)
        if slot == "" </span><span class="cov0" title="0">{
                return errors.New("slot is required")
        }</span>
        <span class="cov1" title="1">_, err := b.run(ctx, b.qmPath(), "set", strconv.Itoa(int(vmid)), "--"+slot, volumeID)
        return err</span>
}

func (b *ShellBackend) DetachVolume(ctx context.Context, vmid VMID, slot string) error <span class="cov1" title="1">{
        slot = strings.TrimSpace(slot)
        if slot == "" </span><span class="cov0" title="0">{
                return errors.New("slot is required")
        }</span>
        <span class="cov1" title="1">_, err := b.run(ctx, b.qmPath(), "set", strconv.Itoa(int(vmid)), "--delete", slot)
        if err != nil </span><span class="cov0" title="0">{
                if isMissingVMError(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("%w: %v", ErrVMNotFound, err)
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov1" title="1">return nil</span>
}

func (b *ShellBackend) DeleteVolume(ctx context.Context, volumeID string) error <span class="cov1" title="1">{
        volumeID = strings.TrimSpace(volumeID)
        if volumeID == "" </span><span class="cov0" title="0">{
                return errors.New("volume id is required")
        }</span>
        <span class="cov1" title="1">_, err := b.run(ctx, b.pvesmPath(), "free", volumeID)
        return err</span>
}

func (b *ShellBackend) guestIPAttempts() int <span class="cov5" title="4">{
        if b.GuestIPAttempts &gt; 0 </span><span class="cov5" title="4">{
                return b.GuestIPAttempts
        }</span>
        <span class="cov0" title="0">return 6</span>
}

func (b *ShellBackend) guestIPInitialWait() time.Duration <span class="cov5" title="4">{
        if b.GuestIPInitialWait &gt; 0 </span><span class="cov1" title="1">{
                return b.GuestIPInitialWait
        }</span>
        <span class="cov4" title="3">return 500 * time.Millisecond</span>
}

func (b *ShellBackend) guestIPMaxWait() time.Duration <span class="cov5" title="4">{
        if b.GuestIPMaxWait &gt; 0 </span><span class="cov1" title="1">{
                return b.GuestIPMaxWait
        }</span>
        <span class="cov4" title="3">return 5 * time.Second</span>
}

func (b *ShellBackend) sleep(ctx context.Context, d time.Duration) error <span class="cov3" title="2">{
        if b.Sleep != nil </span><span class="cov3" title="2">{
                return b.Sleep(ctx, d)
        }</span>
        <span class="cov0" title="0">if d &lt;= 0 </span><span class="cov0" title="0">{
                return ctx.Err()
        }</span>
        <span class="cov0" title="0">timer := time.NewTimer(d)
        defer timer.Stop()
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        case &lt;-timer.C:<span class="cov0" title="0">
                return nil</span>
        }
}

func (b *ShellBackend) run(ctx context.Context, name string, args ...string) (string, error) <span class="cov10" title="16">{
        ctx, cancel := b.withCommandTimeout(ctx)
        defer cancel()
        return b.runner().Run(ctx, name, args...)
}</span>

func (b *ShellBackend) withCommandTimeout(ctx context.Context) (context.Context, context.CancelFunc) <span class="cov10" title="16">{
        if b.CommandTimeout &lt;= 0 </span><span class="cov10" title="16">{
                return ctx, func() </span>{<span class="cov10" title="16">}</span>
        }
        <span class="cov0" title="0">return context.WithTimeout(ctx, b.CommandTimeout)</span>
}

func nextBackoff(current, max time.Duration) time.Duration <span class="cov3" title="2">{
        if current &lt;= 0 </span><span class="cov0" title="0">{
                return max
        }</span>
        <span class="cov3" title="2">next := current * 2
        if next &gt; max </span><span class="cov3" title="2">{
                return max
        }</span>
        <span class="cov0" title="0">return next</span>
}

func (b *ShellBackend) leasePaths() []string <span class="cov1" title="1">{
        paths := b.DHCPLeasePaths
        if len(paths) == 0 </span><span class="cov0" title="0">{
                paths = []string{
                        "/var/lib/misc/dnsmasq.leases",
                        "/var/lib/dnsmasq/dnsmasq.leases",
                        "/var/lib/misc/dnsmasq.*.leases",
                        "/var/lib/misc/dnsmasq*.leases",
                        "/var/lib/dhcp/dhcpd.leases",
                        "/var/lib/dhcp/dhcpd.leases~",
                        "/var/lib/dhcp3/dhcpd.leases",
                        "/var/lib/pve-firewall/dhcpd.leases",
                }
        }</span>
        <span class="cov1" title="1">expanded := make([]string, 0, len(paths))
        seen := map[string]struct{}{}
        for _, path := range paths </span><span class="cov1" title="1">{
                if hasGlob(path) </span><span class="cov0" title="0">{
                        matches, err := filepath.Glob(path)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">for _, match := range matches </span><span class="cov0" title="0">{
                                if _, ok := seen[match]; ok </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">seen[match] = struct{}{}
                                expanded = append(expanded, match)</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov1" title="1">if _, ok := seen[path]; ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov1" title="1">seen[path] = struct{}{}
                expanded = append(expanded, path)</span>
        }
        <span class="cov1" title="1">sort.Strings(expanded)
        return expanded</span>
}

func hasGlob(path string) bool <span class="cov1" title="1">{
        return strings.ContainsAny(path, "*?[")
}</span>

func parseNetMACs(config string) []string <span class="cov1" title="1">{
        var macs []string
        for _, line := range strings.Split(config, "\n") </span><span class="cov3" title="2">{
                line = strings.TrimSpace(line)
                if !strings.HasPrefix(line, "net") </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov1" title="1">parts := strings.SplitN(line, ":", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov1" title="1">fields := strings.Split(strings.TrimSpace(parts[1]), ",")
                for _, field := range fields </span><span class="cov3" title="2">{
                        kv := strings.SplitN(strings.TrimSpace(field), "=", 2)
                        if len(kv) != 2 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov3" title="2">mac := strings.TrimSpace(kv[1])
                        if isMAC(mac) </span><span class="cov1" title="1">{
                                macs = append(macs, normalizeMAC(mac))
                        }</span>
                }
        }
        <span class="cov1" title="1">return uniqueStrings(macs)</span>
}

func findLeaseIP(content []byte, macs []string, netblock *net.IPNet) string <span class="cov1" title="1">{
        if len(macs) == 0 || len(content) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov1" title="1">macset := make(map[string]struct{}, len(macs))
        for _, mac := range macs </span><span class="cov1" title="1">{
                macset[normalizeMAC(mac)] = struct{}{}
        }</span>
        <span class="cov1" title="1">if ip := findDNSMasqLease(content, macset, netblock); ip != "" </span><span class="cov1" title="1">{
                return ip
        }</span>
        <span class="cov0" title="0">if ip := findDHCPDLease(content, macset, netblock); ip != "" </span><span class="cov0" title="0">{
                return ip
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func findDNSMasqLease(content []byte, macset map[string]struct{}, netblock *net.IPNet) string <span class="cov1" title="1">{
        var found string
        for _, line := range strings.Split(string(content), "\n") </span><span class="cov3" title="2">{
                line = strings.TrimSpace(line)
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov1" title="1">fields := strings.Fields(line)
                if len(fields) &lt; 3 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov1" title="1">mac := normalizeMAC(fields[1])
                if _, ok := macset[mac]; !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov1" title="1">ip := net.ParseIP(fields[2])
                if ip == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov1" title="1">ip = ip.To4()
                if ip == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov1" title="1">if netblock != nil &amp;&amp; !netblock.Contains(ip) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov1" title="1">found = ip.String()</span>
        }
        <span class="cov1" title="1">return found</span>
}

func findDHCPDLease(content []byte, macset map[string]struct{}, netblock *net.IPNet) string <span class="cov0" title="0">{
        var found string
        var currentIP string
        var currentMAC string
        inLease := false
        active := true
        bindingSeen := false
        for _, raw := range strings.Split(string(content), "\n") </span><span class="cov0" title="0">{
                line := strings.TrimSpace(raw)
                if strings.HasPrefix(line, "lease ") &amp;&amp; strings.Contains(line, "{") </span><span class="cov0" title="0">{
                        fields := strings.Fields(line)
                        if len(fields) &gt;= 2 </span><span class="cov0" title="0">{
                                currentIP = fields[1]
                                currentMAC = ""
                                active = true
                                bindingSeen = false
                                inLease = true
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">if !inLease </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if strings.HasPrefix(line, "hardware ethernet ") </span><span class="cov0" title="0">{
                        fields := strings.Fields(line)
                        if len(fields) &gt;= 3 </span><span class="cov0" title="0">{
                                currentMAC = normalizeMAC(strings.TrimSuffix(fields[2], ";"))
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">if strings.HasPrefix(line, "binding state ") </span><span class="cov0" title="0">{
                        bindingSeen = true
                        active = strings.Contains(line, "active")
                        continue</span>
                }
                <span class="cov0" title="0">if line == "}" </span><span class="cov0" title="0">{
                        if currentIP != "" &amp;&amp; currentMAC != "" </span><span class="cov0" title="0">{
                                if _, ok := macset[currentMAC]; ok &amp;&amp; (!bindingSeen || active) </span><span class="cov0" title="0">{
                                        ip := net.ParseIP(currentIP)
                                        if ip != nil </span><span class="cov0" title="0">{
                                                ip = ip.To4()
                                                if ip != nil &amp;&amp; (netblock == nil || netblock.Contains(ip)) </span><span class="cov0" title="0">{
                                                        found = ip.String()
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">inLease = false</span>
                }
        }
        <span class="cov0" title="0">return found</span>
}

func normalizeMAC(mac string) string <span class="cov4" title="3">{
        return strings.ToLower(strings.TrimSpace(mac))
}</span>

func isMAC(value string) bool <span class="cov3" title="2">{
        _, err := net.ParseMAC(value)
        return err == nil
}</span>

func uniqueStrings(values []string) []string <span class="cov1" title="1">{
        if len(values) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov1" title="1">seen := map[string]struct{}{}
        out := make([]string, 0, len(values))
        for _, value := range values </span><span class="cov1" title="1">{
                if _, ok := seen[value]; ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov1" title="1">seen[value] = struct{}{}
                out = append(out, value)</span>
        }
        <span class="cov1" title="1">return out</span>
}

func (b *ShellBackend) ensureNode(ctx context.Context) (string, error) <span class="cov5" title="4">{
        if b.Node != "" </span><span class="cov3" title="2">{
                return b.Node, nil
        }</span>
        <span class="cov3" title="2">out, err := b.run(ctx, b.pveshPath(), "get", "/nodes", "--output-format", "json")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov3" title="2">node, err := parseNode(out)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov3" title="2">b.Node = node
        return node, nil</span>
}

func buildNet0(model, bridge string) string <span class="cov1" title="1">{
        if model == "" </span><span class="cov0" title="0">{
                model = "virtio"
        }</span>
        <span class="cov1" title="1">parts := []string{model}
        if bridge != "" &amp;&amp; !strings.Contains(model, "bridge=") </span><span class="cov1" title="1">{
                parts = append(parts, "bridge="+bridge)
        }</span>
        <span class="cov1" title="1">return strings.Join(parts, ",")</span>
}

func formatCICustom(value string) string <span class="cov1" title="1">{
        if strings.Contains(value, "=") </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov1" title="1">return "user=" + value</span>
}

func isMissingVMError(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">msg := strings.ToLower(err.Error())
        indicators := []string{
                "does not exist",
                "no such vm",
                "no such qemu",
                "no such vmid",
                "vmid does not exist",
        }
        for _, indicator := range indicators </span><span class="cov0" title="0">{
                if strings.Contains(msg, indicator) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return strings.Contains(msg, "not found") &amp;&amp; strings.Contains(msg, "vm")</span>
}

func parseStatus(output string) (Status, error) <span class="cov1" title="1">{
        out := strings.TrimSpace(output)
        if out == "" </span><span class="cov0" title="0">{
                return StatusUnknown, errors.New("empty status output")
        }</span>
        <span class="cov1" title="1">if strings.Contains(out, "status:") </span><span class="cov1" title="1">{
                parts := strings.SplitN(out, "status:", 2)
                out = strings.TrimSpace(parts[1])
                if idx := strings.Index(out, "\n"); idx != -1 </span><span class="cov0" title="0">{
                        out = strings.TrimSpace(out[:idx])
                }</span>
        } else<span class="cov0" title="0"> {
                fields := strings.Fields(out)
                if len(fields) &gt; 0 </span><span class="cov0" title="0">{
                        out = fields[0]
                }</span>
        }
        <span class="cov1" title="1">switch out </span>{
        case "running":<span class="cov1" title="1">
                return StatusRunning, nil</span>
        case "stopped":<span class="cov0" title="0">
                return StatusStopped, nil</span>
        default:<span class="cov0" title="0">
                return StatusUnknown, fmt.Errorf("unknown status %q", out)</span>
        }
}

type agentInterface struct {
        Name        string      `json:"name"`
        IPAddresses []agentAddr `json:"ip-addresses"`
}

type agentAddr struct {
        IPAddress     string `json:"ip-address"`
        IPAddressType string `json:"ip-address-type"`
}

type agentNetResp struct {
        Result []agentInterface `json:"result"`
        Data   []agentInterface `json:"data"`
}

func parseAgentIPs(output string) ([]net.IP, error) <span class="cov6" title="5">{
        payload := strings.TrimSpace(output)
        if payload == "" </span><span class="cov0" title="0">{
                return nil, errors.New("empty agent response")
        }</span>
        <span class="cov6" title="5">var resp agentNetResp
        if err := json.Unmarshal([]byte(payload), &amp;resp); err == nil </span><span class="cov6" title="5">{
                ifaces := resp.Result
                if len(ifaces) == 0 </span><span class="cov0" title="0">{
                        ifaces = resp.Data
                }</span>
                <span class="cov6" title="5">if len(ifaces) &gt; 0 </span><span class="cov6" title="5">{
                        return collectIPv4(ifaces), nil
                }</span>
        }
        <span class="cov0" title="0">var direct []agentInterface
        if err := json.Unmarshal([]byte(payload), &amp;direct); err == nil </span><span class="cov0" title="0">{
                return collectIPv4(direct), nil
        }</span>
        <span class="cov0" title="0">return nil, errors.New("unrecognized agent response")</span>
}

func collectIPv4(ifaces []agentInterface) []net.IP <span class="cov6" title="5">{
        var ips []net.IP
        for _, iface := range ifaces </span><span class="cov6" title="6">{
                for _, addr := range iface.IPAddresses </span><span class="cov7" title="7">{
                        if addr.IPAddressType != "ipv4" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov7" title="7">ip := net.ParseIP(addr.IPAddress)
                        if ip == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov7" title="7">if ip.IsLoopback() || ip.IsLinkLocalUnicast() </span><span class="cov4" title="3">{
                                continue</span>
                        }
                        <span class="cov5" title="4">ip = ip.To4()
                        if ip == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov5" title="4">if ip.Equal(net.IPv4zero) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov5" title="4">ips = append(ips, ip)</span>
                }
        }
        <span class="cov6" title="5">return ips</span>
}

func selectIPByCIDR(ips []net.IP, cidr string) (string, error) <span class="cov4" title="3">{
        _, netblock, err := net.ParseCIDR(cidr)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid agent CIDR %q: %w", cidr, err)
        }</span>
        <span class="cov4" title="3">for _, ip := range ips </span><span class="cov5" title="4">{
                if netblock.Contains(ip) </span><span class="cov4" title="3">{
                        return ip.String(), nil
                }</span>
        }
        <span class="cov0" title="0">return "", nil</span>
}

type nodeEntry struct {
        Node string `json:"node"`
        Name string `json:"name"`
}

type nodeResp struct {
        Data []nodeEntry `json:"data"`
}

func parseNode(output string) (string, error) <span class="cov3" title="2">{
        payload := strings.TrimSpace(output)
        if payload == "" </span><span class="cov0" title="0">{
                return "", errors.New("empty node list")
        }</span>
        <span class="cov3" title="2">var resp nodeResp
        if err := json.Unmarshal([]byte(payload), &amp;resp); err == nil &amp;&amp; len(resp.Data) &gt; 0 </span><span class="cov3" title="2">{
                if node := firstNode(resp.Data); node != "" </span><span class="cov3" title="2">{
                        return node, nil
                }</span>
        }
        <span class="cov0" title="0">var nodes []nodeEntry
        if err := json.Unmarshal([]byte(payload), &amp;nodes); err == nil &amp;&amp; len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                if node := firstNode(nodes); node != "" </span><span class="cov0" title="0">{
                        return node, nil
                }</span>
        }
        <span class="cov0" title="0">return "", errors.New("no nodes found")</span>
}

func firstNode(nodes []nodeEntry) string <span class="cov3" title="2">{
        for _, entry := range nodes </span><span class="cov3" title="2">{
                if entry.Node != "" </span><span class="cov3" title="2">{
                        return entry.Node
                }</span>
                <span class="cov0" title="0">if entry.Name != "" </span><span class="cov0" title="0">{
                        return entry.Name
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package secrets

import (
        "bufio"
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "filippo.io/age"
        "gopkg.in/yaml.v3"
)

const BundleVersion = 1

// Bundle describes decrypted secrets content.
type Bundle struct {
        Version  int               `json:"version" yaml:"version"`
        Git      GitBundle         `json:"git,omitempty" yaml:"git,omitempty"`
        Env      map[string]string `json:"env,omitempty" yaml:"env,omitempty"`
        Claude   ClaudeBundle      `json:"claude,omitempty" yaml:"claude,omitempty"`
        Artifact ArtifactBundle    `json:"artifact,omitempty" yaml:"artifact,omitempty"`
        Metadata map[string]string `json:"metadata,omitempty" yaml:"metadata,omitempty"`
}

// GitBundle stores git-related credentials.
type GitBundle struct {
        Token         string `json:"token,omitempty" yaml:"token,omitempty"`
        Username      string `json:"username,omitempty" yaml:"username,omitempty"`
        SSHPrivateKey string `json:"ssh_private_key,omitempty" yaml:"ssh_private_key,omitempty"`
        SSHPublicKey  string `json:"ssh_public_key,omitempty" yaml:"ssh_public_key,omitempty"`
        KnownHosts    string `json:"known_hosts,omitempty" yaml:"known_hosts,omitempty"`
}

// ClaudeBundle holds optional Claude Code settings fragments.
type ClaudeBundle struct {
        SettingsJSON string                 `json:"settings_json,omitempty" yaml:"settings_json,omitempty"`
        Settings     map[string]interface{} `json:"settings,omitempty" yaml:"settings,omitempty"`
}

// ArtifactBundle holds artifact upload parameters.
type ArtifactBundle struct {
        Endpoint string `json:"endpoint,omitempty" yaml:"endpoint,omitempty"`
        Token    string `json:"token,omitempty" yaml:"token,omitempty"`
}

// ClaudeSettingsJSON returns the settings fragment as JSON.
func (b Bundle) ClaudeSettingsJSON() (string, error) <span class="cov1" title="1">{
        if strings.TrimSpace(b.Claude.SettingsJSON) != "" </span><span class="cov0" title="0">{
                return b.Claude.SettingsJSON, nil
        }</span>
        <span class="cov1" title="1">if len(b.Claude.Settings) == 0 </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov1" title="1">data, err := json.Marshal(b.Claude.Settings)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("marshal claude settings: %w", err)
        }</span>
        <span class="cov1" title="1">return string(data), nil</span>
}

// Store locates and decrypts secrets bundles.
type Store struct {
        Dir            string
        AgeKeyPath     string
        SopsPath       string
        AllowPlaintext bool
        SopsDecrypt    func(ctx context.Context, path string, env []string) ([]byte, error)
}

// Load locates, decrypts, and parses the bundle by name or path.
func (s Store) Load(ctx context.Context, name string) (Bundle, error) <span class="cov6" title="2">{
        name = strings.TrimSpace(name)
        if name == "" </span><span class="cov0" title="0">{
                return Bundle{}, errors.New("bundle name is required")
        }</span>
        <span class="cov6" title="2">path, err := s.resolvePath(name)
        if err != nil </span><span class="cov0" title="0">{
                return Bundle{}, err
        }</span>
        <span class="cov6" title="2">payload, err := s.decrypt(ctx, path)
        if err != nil </span><span class="cov0" title="0">{
                return Bundle{}, err
        }</span>
        <span class="cov6" title="2">bundle, err := parseBundle(payload)
        if err != nil </span><span class="cov0" title="0">{
                return Bundle{}, fmt.Errorf("parse bundle %s: %w", path, err)
        }</span>
        <span class="cov6" title="2">return bundle, nil</span>
}

func (s Store) resolvePath(name string) (string, error) <span class="cov6" title="2">{
        candidates := []string{}
        if filepath.IsAbs(name) </span><span class="cov0" title="0">{
                candidates = append(candidates, name)
        }</span> else<span class="cov6" title="2"> {
                if s.Dir != "" </span><span class="cov6" title="2">{
                        candidates = append(candidates, filepath.Join(s.Dir, name))
                }</span>
                <span class="cov6" title="2">candidates = append(candidates, name)</span>
        }
        <span class="cov6" title="2">if filepath.Ext(name) != "" </span><span class="cov0" title="0">{
                for _, candidate := range candidates </span><span class="cov0" title="0">{
                        if fileExists(candidate) </span><span class="cov0" title="0">{
                                return candidate, nil
                        }</span>
                }
                <span class="cov0" title="0">return "", fmt.Errorf("bundle %s not found", name)</span>
        }
        <span class="cov6" title="2">for _, candidate := range candidates </span><span class="cov6" title="2">{
                if path, ok := findBundleFile(candidate, s.AllowPlaintext); ok </span><span class="cov6" title="2">{
                        return path, nil
                }</span>
        }
        <span class="cov0" title="0">return "", fmt.Errorf("bundle %s not found", name)</span>
}

func (s Store) decrypt(ctx context.Context, path string) ([]byte, error) <span class="cov6" title="2">{
        lower := strings.ToLower(filepath.Base(path))
        if strings.HasSuffix(lower, ".age") </span><span class="cov1" title="1">{
                return decryptAge(path, s.AgeKeyPath)
        }</span>
        <span class="cov1" title="1">data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read bundle %s: %w", path, err)
        }</span>
        <span class="cov1" title="1">if looksLikeSops(lower, data) </span><span class="cov1" title="1">{
                return s.decryptSops(ctx, path)
        }</span>
        <span class="cov0" title="0">if s.AllowPlaintext </span><span class="cov0" title="0">{
                return data, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("bundle %s is not encrypted (.age or sops)", path)</span>
}

func (s Store) decryptSops(ctx context.Context, path string) ([]byte, error) <span class="cov1" title="1">{
        if s.SopsDecrypt != nil </span><span class="cov1" title="1">{
                return s.SopsDecrypt(ctx, path, s.sopsEnv())
        }</span>
        <span class="cov0" title="0">return decryptSops(ctx, s.sopsPath(), path, s.sopsEnv())</span>
}

func (s Store) sopsPath() string <span class="cov0" title="0">{
        if strings.TrimSpace(s.SopsPath) != "" </span><span class="cov0" title="0">{
                return s.SopsPath
        }</span>
        <span class="cov0" title="0">return "sops"</span>
}

func (s Store) sopsEnv() []string <span class="cov1" title="1">{
        if strings.TrimSpace(s.AgeKeyPath) == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov1" title="1">return []string{"SOPS_AGE_KEY_FILE=" + s.AgeKeyPath}</span>
}

func findBundleFile(base string, allowPlain bool) (string, bool) <span class="cov6" title="2">{
        candidates := []string{
                base + ".age",
                base + ".sops.yaml",
                base + ".sops.yml",
                base + ".sops.json",
        }
        if allowPlain </span><span class="cov0" title="0">{
                candidates = append(candidates,
                        base+".yaml",
                        base+".yml",
                        base+".json",
                )
        }</span>
        <span class="cov6" title="2">for _, candidate := range candidates </span><span class="cov10" title="3">{
                if fileExists(candidate) </span><span class="cov6" title="2">{
                        return candidate, true
                }</span>
        }
        <span class="cov0" title="0">return "", false</span>
}

func fileExists(path string) bool <span class="cov10" title="3">{
        info, err := os.Stat(path)
        if err != nil </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov6" title="2">return !info.IsDir()</span>
}

func looksLikeSops(name string, data []byte) bool <span class="cov1" title="1">{
        lower := strings.ToLower(name)
        if strings.Contains(lower, ".sops.") || strings.HasSuffix(lower, ".sops") </span><span class="cov1" title="1">{
                return true
        }</span>
        <span class="cov0" title="0">if bytes.Contains(data, []byte("\nsops:")) || bytes.Contains(data, []byte("\nsops:\r\n")) </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return bytes.Contains(data, []byte(`"sops"`))</span>
}

func parseBundle(data []byte) (Bundle, error) <span class="cov6" title="2">{
        var bundle Bundle
        if err := yaml.Unmarshal(data, &amp;bundle); err != nil </span><span class="cov0" title="0">{
                return Bundle{}, err
        }</span>
        <span class="cov6" title="2">if bundle.Version == 0 </span><span class="cov0" title="0">{
                bundle.Version = BundleVersion
        }</span>
        <span class="cov6" title="2">if bundle.Version != BundleVersion </span><span class="cov0" title="0">{
                return Bundle{}, fmt.Errorf("unsupported bundle version %d", bundle.Version)
        }</span>
        <span class="cov6" title="2">return bundle, nil</span>
}

func decryptAge(path, keyPath string) ([]byte, error) <span class="cov1" title="1">{
        if strings.TrimSpace(keyPath) == "" </span><span class="cov0" title="0">{
                return nil, errors.New("age key path is required for .age bundles")
        }</span>
        <span class="cov1" title="1">keyData, err := os.ReadFile(keyPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read age key %s: %w", keyPath, err)
        }</span>
        <span class="cov1" title="1">identities, err := parseAgeIdentities(keyData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">file, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("open bundle %s: %w", path, err)
        }</span>
        <span class="cov1" title="1">defer file.Close()
        reader, err := age.Decrypt(file, identities...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("decrypt bundle %s: %w", path, err)
        }</span>
        <span class="cov1" title="1">payload, err := io.ReadAll(reader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read bundle %s: %w", path, err)
        }</span>
        <span class="cov1" title="1">return payload, nil</span>
}

func parseAgeIdentities(data []byte) ([]age.Identity, error) <span class="cov1" title="1">{
        var identities []age.Identity
        scanner := bufio.NewScanner(bytes.NewReader(data))
        for scanner.Scan() </span><span class="cov1" title="1">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov1" title="1">if !strings.HasPrefix(line, "AGE-SECRET-KEY-") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov1" title="1">identity, err := age.ParseX25519Identity(line)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("parse age identity: %w", err)
                }</span>
                <span class="cov1" title="1">identities = append(identities, identity)</span>
        }
        <span class="cov1" title="1">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read age key: %w", err)
        }</span>
        <span class="cov1" title="1">if len(identities) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("no age identities found")
        }</span>
        <span class="cov1" title="1">return identities, nil</span>
}

func decryptSops(ctx context.Context, sopsPath, bundlePath string, extraEnv []string) ([]byte, error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, sopsPath, "-d", bundlePath)
        cmd.Env = append(os.Environ(), extraEnv...)
        var stdout bytes.Buffer
        var stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                errMsg := strings.TrimSpace(stderr.String())
                if errMsg != "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("sops decrypt %s: %w: %s", bundlePath, err, errMsg)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("sops decrypt %s: %w", bundlePath, err)</span>
        }
        <span class="cov0" title="0">return stdout.Bytes(), nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">// Package testing provides shared test utilities for agentlab.
package testing

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/http/httptest"
        "sync"
        "time"

        "github.com/agentlab/agentlab/internal/models"
)

// MockProxmoxBackend is a mock implementation of a Proxmox backend for testing.
type MockProxmoxBackend struct {
        mu                sync.Mutex
        VMs               map[int]*MockVM
        NextVMID          int
        CreateDelay       time.Duration
        CreateError       error
        ShouldFailCreate  bool
        ShouldFailStart   bool
        ShouldFailDestroy bool
}

// MockVM represents a mock virtual machine.
type MockVM struct {
        VMID        int
        Name        string
        State       string
        IP          string
        Profile     string
        CreatedAt   time.Time
        StartedAt   *time.Time
        DestroyedAt *time.Time
}

// NewMockProxmoxBackend creates a new mock Proxmox backend.
func NewMockProxmoxBackend() *MockProxmoxBackend <span class="cov0" title="0">{
        return &amp;MockProxmoxBackend{
                VMs:      make(map[int]*MockVM),
                NextVMID: 100,
        }
}</span>

// CreateVM simulates creating a VM.
func (m *MockProxmoxBackend) CreateVM(ctx context.Context, name string, profile string) (int, error) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if m.CreateDelay &gt; 0 </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-time.After(m.CreateDelay):<span class="cov0" title="0"></span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return 0, ctx.Err()</span>
                }
        }

        <span class="cov0" title="0">if m.ShouldFailCreate || m.CreateError != nil </span><span class="cov0" title="0">{
                return 0, m.CreateError
        }</span>

        <span class="cov0" title="0">vmid := m.NextVMID
        m.NextVMID++

        m.VMs[vmid] = &amp;MockVM{
                VMID:      vmid,
                Name:      name,
                State:     string(models.SandboxProvisioning),
                Profile:   profile,
                CreatedAt: time.Now(),
        }

        return vmid, nil</span>
}

// StartVM simulates starting a VM.
func (m *MockProxmoxBackend) StartVM(ctx context.Context, vmid int) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        vm, exists := m.VMs[vmid]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("vm %d not found", vmid)
        }</span>

        <span class="cov0" title="0">if m.ShouldFailStart </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start vm %d", vmid)
        }</span>

        <span class="cov0" title="0">now := time.Now()
        vm.StartedAt = &amp;now
        vm.State = string(models.SandboxReady)
        vm.IP = fmt.Sprintf("10.77.0.%d", vmid%100)

        return nil</span>
}

// StopVM simulates stopping a VM.
func (m *MockProxmoxBackend) StopVM(ctx context.Context, vmid int) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        vm, exists := m.VMs[vmid]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("vm %d not found", vmid)
        }</span>

        <span class="cov0" title="0">vm.State = string(models.SandboxStopped)
        return nil</span>
}

// DestroyVM simulates destroying a VM.
func (m *MockProxmoxBackend) DestroyVM(ctx context.Context, vmid int) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if m.ShouldFailDestroy </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to destroy vm %d", vmid)
        }</span>

        <span class="cov0" title="0">vm, exists := m.VMs[vmid]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("vm %d not found", vmid)
        }</span>

        <span class="cov0" title="0">now := time.Now()
        vm.DestroyedAt = &amp;now
        vm.State = string(models.SandboxDestroyed)

        return nil</span>
}

// GetVM returns a VM by ID.
func (m *MockProxmoxBackend) GetVM(vmid int) *MockVM <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        return m.VMs[vmid]
}</span>

// MockSecretsStore is a mock implementation of a secrets store for testing.
type MockSecretsStore struct {
        mu        sync.Mutex
        secrets   map[string]string
        getError  error
        putError  error
        shouldLag bool
}

// NewMockSecretsStore creates a new mock secrets store.
func NewMockSecretsStore() *MockSecretsStore <span class="cov0" title="0">{
        return &amp;MockSecretsStore{
                secrets: make(map[string]string),
        }
}</span>

// Get retrieves a secret value by key.
func (m *MockSecretsStore) Get(ctx context.Context, key string) (string, error) <span class="cov0" title="0">{
        if m.shouldLag </span><span class="cov0" title="0">{
                time.Sleep(10 * time.Millisecond)
        }</span>

        <span class="cov0" title="0">if m.getError != nil </span><span class="cov0" title="0">{
                return "", m.getError
        }</span>

        <span class="cov0" title="0">m.mu.Lock()
        defer m.mu.Unlock()

        val, ok := m.secrets[key]
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("secret not found: %s", key)
        }</span>
        <span class="cov0" title="0">return val, nil</span>
}

// Put stores a secret value by key.
func (m *MockSecretsStore) Put(ctx context.Context, key, value string) error <span class="cov0" title="0">{
        if m.putError != nil </span><span class="cov0" title="0">{
                return m.putError
        }</span>

        <span class="cov0" title="0">m.mu.Lock()
        defer m.mu.Unlock()

        m.secrets[key] = value
        return nil</span>
}

// Delete removes a secret by key.
func (m *MockSecretsStore) Delete(ctx context.Context, key string) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        delete(m.secrets, key)
        return nil
}</span>

// SetGetError sets an error to be returned by Get.
func (m *MockSecretsStore) SetGetError(err error) <span class="cov0" title="0">{
        m.getError = err
}</span>

// SetPutError sets an error to be returned by Put.
func (m *MockSecretsStore) SetPutError(err error) <span class="cov0" title="0">{
        m.putError = err
}</span>

// SetShouldLag enables artificial lag in operations.
func (m *MockSecretsStore) SetShouldLag(lag bool) <span class="cov0" title="0">{
        m.shouldLag = lag
}</span>

// MockHTTPHandler is a mock HTTP handler for testing API clients.
type MockHTTPHandler struct {
        mu            sync.Mutex
        responses     map[string][]*MockResponse
        requests      []*MockRequest
        defaultStatus int
        delay         time.Duration
}

// MockResponse represents a mock HTTP response.
type MockResponse struct {
        Status int
        Body   any
        Header map[string]string
}

// MockRequest represents a captured HTTP request.
type MockRequest struct {
        Method  string
        Path    string
        Header  http.Header
        Body    []byte
        At      time.Time
}

// NewMockHTTPHandler creates a new mock HTTP handler.
func NewMockHTTPHandler() *MockHTTPHandler <span class="cov0" title="0">{
        return &amp;MockHTTPHandler{
                responses:     make(map[string][]*MockResponse),
                defaultStatus: http.StatusOK,
        }
}</span>

// ServeHTTP implements http.Handler.
func (m *MockHTTPHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        // Capture request
        body, _ := io.ReadAll(r.Body)
        req := &amp;MockRequest{
                Method: r.Method,
                Path:   r.URL.Path,
                Header: r.Header.Clone(),
                Body:   body,
                At:     time.Now(),
        }
        m.requests = append(m.requests, req)

        // Apply delay if set
        if m.delay &gt; 0 </span><span class="cov0" title="0">{
                time.Sleep(m.delay)
        }</span>

        // Get response for this path
        <span class="cov0" title="0">key := r.Method + ":" + r.URL.Path
        responses, ok := m.responses[key]
        if !ok || len(responses) == 0 </span><span class="cov0" title="0">{
                w.WriteHeader(m.defaultStatus)
                return
        }</span>

        // Get next response in round-robin fashion
        <span class="cov0" title="0">resp := responses[0]
        if len(responses) &gt; 1 </span><span class="cov0" title="0">{
                m.responses[key] = responses[1:]
        }</span>

        // Set headers
        <span class="cov0" title="0">for k, v := range resp.Header </span><span class="cov0" title="0">{
                w.Header().Set(k, v)
        }</span>

        // Write status
        <span class="cov0" title="0">if resp.Status != 0 </span><span class="cov0" title="0">{
                w.WriteHeader(resp.Status)
        }</span> else<span class="cov0" title="0"> {
                w.WriteHeader(http.StatusOK)
        }</span>

        // Write body
        <span class="cov0" title="0">if resp.Body != nil </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                enc := json.NewEncoder(w)
                _ = enc.Encode(resp.Body)
        }</span>
}

// AddResponse adds a mock response for a given method and path.
func (m *MockHTTPHandler) AddResponse(method, path string, status int, body any) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        key := method + ":" + path
        m.responses[key] = append(m.responses[key], &amp;MockResponse{
                Status: status,
                Body:   body,
        })
}</span>

// AddResponseWithHeaders adds a mock response with custom headers.
func (m *MockHTTPHandler) AddResponseWithHeaders(method, path string, status int, body any, headers map[string]string) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        key := method + ":" + path
        m.responses[key] = append(m.responses[key], &amp;MockResponse{
                Status: status,
                Body:   body,
                Header: headers,
        })
}</span>

// SetDelay sets an artificial delay for all responses.
func (m *MockHTTPHandler) SetDelay(d time.Duration) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.delay = d
}</span>

// GetRequests returns all captured requests.
func (m *MockHTTPHandler) GetRequests() []*MockRequest <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        return m.requests
}</span>

// ClearRequests clears all captured requests.
func (m *MockHTTPHandler) ClearRequests() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.requests = nil
}</span>

// NewTestServer creates a test HTTP server with the mock handler.
func (m *MockHTTPHandler) NewTestServer(t interface {
        Cleanup(func())
}) *httptest.Server <span class="cov0" title="0">{
        srv := httptest.NewServer(m)
        if t, ok := t.(interface{ Cleanup(func()) }); ok </span><span class="cov0" title="0">{
                t.Cleanup(srv.Close)
        }</span>
        <span class="cov0" title="0">return srv</span>
}

// Reset clears all responses and requests.
func (m *MockHTTPHandler) Reset() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.responses = make(map[string][]*MockResponse)
        m.requests = nil
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">// Package testing provides shared test utilities for agentlab.
package testing

import (
        "encoding/json"
        "os"
        "path/filepath"
        "testing"
        "time"

        "github.com/stretchr/testify/assert"
        "github.com/stretchr/testify/require"
)

// AssertJSONEqual asserts that two JSON values are semantically equal.
func AssertJSONEqual(t *testing.T, want, got any, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        t.Helper()
        wantBytes, err := json.Marshal(want)
        require.NoError(t, err, "failed to marshal 'want' to JSON")
        gotBytes, err := json.Marshal(got)
        require.NoError(t, err, "failed to marshal 'got' to JSON")

        var wantAny, gotAny any
        require.NoError(t, json.Unmarshal(wantBytes, &amp;wantAny), "failed to unmarshal 'want'")
        require.NoError(t, json.Unmarshal(gotBytes, &amp;gotAny), "failed to unmarshal 'got'")

        assert.Equal(t, wantAny, gotAny, msgAndArgs...)
}</span>

// TempFile creates a temporary file with the given content and returns its path.
// The file is automatically cleaned up when the test completes.
func TempFile(t *testing.T, content string) string <span class="cov0" title="0">{
        t.Helper()
        tmpDir := t.TempDir()
        path := filepath.Join(tmpDir, "testfile")
        err := os.WriteFile(path, []byte(content), 0o644)
        require.NoError(t, err, "failed to write temp file")
        return path
}</span>

// MkdirTempInDir creates a temporary directory under the given parent directory.
// Unlike t.TempDir(), this allows specifying the parent.
func MkdirTempInDir(t *testing.T, parentDir string) string <span class="cov0" title="0">{
        t.Helper()
        path, err := os.MkdirTemp(parentDir, "testdir*")
        require.NoError(t, err, "failed to create temp dir")
        t.Cleanup(func() </span><span class="cov0" title="0">{
                _ = os.RemoveAll(path)
        }</span>)
        <span class="cov0" title="0">return path</span>
}

// ParseTime parses an RFC3339 timestamp.
func ParseTime(t *testing.T, s string) time.Time <span class="cov0" title="0">{
        t.Helper()
        ts, err := time.Parse(time.RFC3339, s)
        require.NoError(t, err, "failed to parse time %q", s)
        return ts
}</span>

// RequireNoError asserts that err is nil, with a more descriptive message.
func RequireNoError(t *testing.T, err error, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        t.Helper()
        require.NoError(t, err, msgAndArgs...)
}</span>

// RequireEqual asserts that two values are equal, with a more descriptive message.
func RequireEqual(t *testing.T, expected, actual any, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        t.Helper()
        require.Equal(t, expected, actual, msgAndArgs...)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
